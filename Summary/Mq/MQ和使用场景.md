### MQ和使用场景

***

##### 消息队列(Message Queue)
**消息(Message)是指在应用间传送的数据**, 消息可以非常简单, 比如只包含文本字符串, 也可以更复杂, 可能包含嵌入对象.
**消息队列(Message Queue)是一种应用间的通信方式**, 消息发送后可以立即返回, **由消息系统来确保消息的可靠传递**. *消息发布者只管把消息发布到 MQ 中而不用管谁来取, 消息使用者只管从MQ中取消息而不管是谁发布的*. **这样发布者和使用者都不用知道对方的存在, 这样能大大平台解耦能力**, 将每一个功能都具体到模块化操作.



##### 消息队列基本术语
**Broker**:  它提供一种传输服务, 它的角色就是维护一条从生产者到消费者的路线, 保证数据能按照指定的方式进行传输.
**Exchange**：消息交换机, 它指定消息按什么规则,路由到哪个队列.
**Queue**: 消息的载体, 每个消息都会被投到一个或多个队列.
**Binding**: 绑定, 它的作用就是把exchange和queue按照路由规则绑定起来.
**Routing Key**: 路由关键字, exchange根据这个关键字进行消息投递. 
**vhost**: 虚拟主机,一个broker里可以有多个vhost, 用作不同用户的权限分离. 
**Producer**: 消息生产者, 就是投递消息的程序.
**Consumer**: 消息消费者, 就是接受消息的程序.
**Channel**: 消息通道,在客户端的每个连接里, 可建立多个channel.
![aboutmq](../../images/aboutmq.png)



##### 为何需要消息队列
**解耦** 
在项目启动之初来预测将来项目会碰到什么需求, 是极其困难的. 消息系统在处理过程中间插入了一个隐含的, 基于数据的接口层, 两边的处理过程都要实现这一接口. 这允许你独立的扩展或修改两边的处理过程, 只要确保它们遵守同样的接口约束. 
**冗余** 
有些情况下, 处理数据的过程会失败. 除非数据被持久化, 否则将造成丢失. 消息队列把数据进行持久化直到它们已经被完全处理, 通过这一方式规避了数据丢失风险. 许多消息队列所采用的”插入-获取-删除”范式中, 在把一个消息从队列中删除之前, 需要你的处理系统明确的指出该消息已经被处理完毕, 从而确保你的数据被安全的保存直到你使用完毕. 
**扩展性** 
因为消息队列解耦了你的处理过程, 所以增大消息入队和处理的频率是很容易的, 只要另外增加处理过程即可. 不需要改变代码, 不需要调节参数. 扩展就像调大电力按钮一样简单. 
**灵活性 & 峰值处理能力** 
在访问量剧增的情况下, 应用仍然需要继续发挥作用, 但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费. 使用消息队列能够使关键组件顶住突发的访问压力, 而不会因为突发的超负荷的请求而完全崩溃. 
**可恢复性** 
系统的一部分组件失效时, 不会影响到整个系统. 消息队列降低了进程间的耦合度, 所以即使一个处理消息的进程挂掉, 加入队列中的消息仍然可以在系统恢复后被处理. 
**顺序保证** 
在大多使用场景下, 数据处理的顺序都很重要. 大部分消息队列本来就是排序的, 并且能保证数据会按照特定的顺序来处理. Kafka保证一个Partition内的消息的有序性. 
**缓冲** 
在任何重要的系统中, 都会有需要不同的处理时间的元素. 例如, 加载一张图片比应用过滤器花费更少的时间. 消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速. 该缓冲有助于控制和优化数据流经过系统的速度. 
**异步通信** 
很多时候, 用户不想也不需要立即处理消息. 消息队列提供了异步处理机制, 允许用户把一个消息放入队列, 但并不立即处理它. 想向队列中放入多少消息就放多少, 然后在需要的时候再去处理它们. 



##### 消息队列的应用场景

todo

ref:
1.[rabbitmq管理界面开启](http://blog.51cto.com/xiong51/2113794),   2.[Java常用消息队列原理介绍及性能对比](https://blog.csdn.net/songfeihu0810232/article/details/78648706)