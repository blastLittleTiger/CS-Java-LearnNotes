### 后端框架学习笔记5
***

[TOC]

##### 124 : RTTI和反射(reflect)的区别
A : **RTTI和"反射"之间唯一的区别就是, 对RTTI来说, 编译器会在编译期打开和检查.class文件. 但对"反射"来说,.class文件在编译期间是不可使用的, 而是由运行时环境打开和检查.class文件**. 

**RTTI**: 运行时类型识别(Run-Time Type Identification), 在运行时识别一个对象的类型, 其对应的类是Class对象, 每个java里面的类都对应一个Class对象(在编写并且编译后), 这个对象被保存在这个类的同名class文件里.

**反射**: 可以认为是一种高级的RTTI. **传统RTTI的功能主要通过Class文件来实现, 而反射机制通过使用`java.lang.reflect`包提供给我们的类和方法**. 反射是一种高级的RTTI, 一般把普通的RTTI叫做传统的RTTI, **传统的RTTI帮助实现了多态和继承**.

RTTI的形式包括三种: 
1.传统的类型转换. 如`(Apple)Fruit`, 由RTTI确保类型转换的正确性, 如果执行了一个错误的类型转换, 就会抛出一个ClassCastException异常. 
2.通过Class对象来获取对象的类型. 如`Class c = Class.forName("Apple"); Object o = c.newInstance();`
3.通过关键字`instanceof`或`Class.isInstance()`方法来确定对象是否属于某个特定类型的实例.



##### 125 : RTTI和反射(reflect)的应用例子
A : `UseTranditionalRTTI`和`UseReflect`分别是RTTI和反射的使用例子
`UseTranditionalRTTI`

```java
/*使用传统的RTTI*/
/**
 * RTTI的形式包括三种:
 * 1.传统的类型转换. 如(Apple)Fruit, 由RTTI确保类型转换的正确性, 如果执行了一个错误的类型转换, 就会抛出一个ClassCastException异常.
 * 2.通过Class对象来获取对象的类型. 如Class c = Class.forName("Apple"); Object o = c.newInstance();
 * 3.通过关键字instanceof或Class.isInstance()方法来确定对象是否属于某个特定类型的实例.
 **/
@Slf4j
public class UseTranditionalRTTI {
    public static void main(String[] args) {
        System.out.println("RTTI类型转换功能例子:");
        Fruit f1 = new Cherry();
        Fruit f2 = new Pineapple();
        Fruit f3 = new Pineapple();
        ((Cherry) f1).setPrice(129.8f);//1. 类型转换
        (f1).setName("巴西樱桃");//上面一句已经转换过了, 所以此处可以不用转换
        System.out.println(f1.toString() + ", 类型是: " + f1.getClass());
        // 每个类的类型是确定的, 只有一种直接class类型, 但是由于有继承关系, 可以upcast或者downcast,
        // Fruit f2 = new Pineapple(); 虽然使用Fruit来定义类型, 但是实际上其直接类型是Pineapple, 而非Fruit
        System.out.println("f2的类型是: " + f2.getClass());

        System.out.println("\nRTTI通过Class对象来获取对象的类型:");
        try {
            Class<?> cls = Class.forName("com.cqu.rjx.syntax.reflect.Cherry");//获取对象类型
            Cherry cherry = (Cherry) cls.newInstance();//创建无参对象
            cherry.setName("美国樱桃");
            cherry.setPrice(88.9f);
            System.out.println(cherry.toString());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }

        System.out.println("\nRTTI使用instanceof或Class.isInstance():");
        Class<?> cls2 = Pineapple.class;//获取对象类型
        if (f3 instanceof Fruit) {
            System.out.println("f3 is Fruit类的对象");
        }
        if (!cls2.isInstance(f1)) {
            System.out.println("f1 is not " + cls2.getCanonicalName() + "类 的对象");
        }
    }
}

@Data
class Fruit {
    String name;
}

@Data
class Pineapple extends Fruit {
    String name;
    String area;

    Pineapple() {
        super();
    }

    Pineapple(String name, String area) {
        super();
        this.area = area;
        this.name = name;
    }
}

@Data
class Cherry extends Fruit {
    String name;
    float price;

    Cherry() {
        super();
    }

    Cherry(String name, float price) {
        super();
        this.name = name;
        this.price = price;
    }
}
```

`UseReflect`
```java
/*使用反射*/
//RTTI的核心是Class类, 反射的核心是操作Class类对象, 所以反射比RTTI更深入
public class UseReflect {
    public static List<String> getTeamList() {
        List<String> team = new ArrayList<>();
        team.add("中国象棋社");
        team.add("动漫社");
        team.add("插花茶艺社");
        team.add("飞天诗社");
        team.add("友爱互助社");
        team.add("道教文化研究社");
        team.add("海贼王研究社");
        team.add("挑战数学社");
        team.add("有机化学学习社");
        team.add("万有引力社");
        team.add("日本动作片鉴赏中心");
        return team;
    }

    public static List<String> getCourseList() {
        List<String> course = new ArrayList<>();
        course.add("高等数学");
        course.add("电路理论");
        course.add("java");
        course.add("计算机组成原理");
        course.add("大学物理");
        course.add("设计模式");
        course.add("先秦文学理论研究");
        course.add("初级日语");
        course.add("经济学原理");
        course.add("专业日语");
        return course;
    }

    public static List<String> getRandomList(List<String> list, int num) throws MyParamException {
        if (num <= 0) {
            throw new MyParamException("参数不符合规范!", "第2个参数必须大于0!!!");
        }
        if (num > list.size()) {
            int size = list.size();
            throw new MyParamException("第二个参数参数发生错误!", "参数list的长度为" + size + "小于要求的长度" + num);
        }
        List<String> ls = new ArrayList<>(num);
        Random random = new Random(System.currentTimeMillis());
        while (ls.size() < num) {
            int n = random.nextInt(list.size());
            ls.add(list.get(n));
        }
        return ls;
    }

    /**
     * getXXX和getDeclaredXXX之间有什么关系? 什么区别?
     **/
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException,
            IllegalAccessException, InstantiationException, InvocationTargetException, MyParamException,
            NoSuchFieldException {
        System.out.println("获取信息阶段...");
        /*获取了类对象*/
        Class<?> teacherClsObj = Class.forName("com.cqu.rjx.syntax.reflect.Teacher");
        //Class<?> studentClsObj = Student.class;
        Class<?> studentClsObj = Class.forName("com.cqu.rjx.syntax.reflect.Student");
        Class<?> departmentClsObj = Department.class;

        /*获取构造器*/
        // 基本类型换也直接使用xxx.class, 如float.class
        Constructor teacherCon = teacherClsObj.getDeclaredConstructor(String.class, String.class, float.class);
        Constructor[] teacherConArray = teacherClsObj.getDeclaredConstructors();

        /*getConstructor导致失败, getDeclaredConstructor却是成功的? 这是为何? */
        //Constructor studentCon = studentClsObj.getConstructor(String.class, List.class, List.class);// error
        //Constructor[] studentConArray = studentClsObj.getConstructors(); //这样数组里面是null的?

        // 后面两个参数类型 ArrayList.class, List.class, 定义处是List<String> team, 如此模式不可以, 必须是和原定义相同的!
        Constructor studentCon = studentClsObj.getDeclaredConstructor(String.class, List.class, List.class);
        Constructor[] studentConArray = studentClsObj.getDeclaredConstructors();

        /*获取方法*/
        // 按照名字获取方法
        Method teacherMethod = teacherClsObj.getDeclaredMethod("setTeacherSalary", float.class);
        // 所有的方法
        Method[] teacherMethodArray = teacherClsObj.getMethods();
        Method studentCourseMethod = studentClsObj.getDeclaredMethod("getCourseStr");//无参函数
        Method studentInfoMethod = studentClsObj.getDeclaredMethod("getStudentInfo");
        Method[] studentMethodArray = studentClsObj.getDeclaredMethods();

        /*获取字段*/
        Field teacherFieldSalary = teacherClsObj.getDeclaredField("salary");
        Field[] teacherFiledArray = teacherClsObj.getDeclaredFields();
        Field DepartmentField = departmentClsObj.getDeclaredField("name");
        Field[] DepartmentFieldArray = departmentClsObj.getDeclaredFields();


        System.out.println("\n使用提取的信息阶段...");
        /*创建对象*/
        // 创建无参数对象
        Teacher teacherZhang = (Teacher) teacherClsObj.newInstance();//未对参数进行初始化
        Student studentZhang = (Student) studentClsObj.newInstance();
        // 创建有参对象
        Teacher teacherLee = (Teacher) teacherCon.newInstance("李海洋", "化学", 7894.5f);
        List<String> stuCourseList = getRandomList(getCourseList(), 5);
        List<String> stuTeamList = getRandomList(getTeamList(), 3);
        Student studentLee = (Student) studentCon.newInstance("李阳", stuCourseList, stuTeamList);

        /*输出父类*/
        System.out.println("\n展示Teacher类的父类:");
        System.out.println("Teacher类的父类:" + teacherClsObj.getSuperclass());
        System.out.println("teacherLee的name: " + teacherLee.getName());

        /*展示构造器*/
        System.out.println("\n展示Student类的构造器:");
        for (Constructor s : studentConArray) {
            System.out.println(s.toGenericString());
            //System.out.println(s.toString());
        }

        /*调用方法*/
        System.out.println("\n展示使用反射调用方法:");
        System.out.println(studentLee.toString());
        System.out.print(teacherLee.getName() + "老师改变工资之前的工资数: " + teacherLee.getSalary() + "; ");
        teacherMethod.invoke(teacherLee, 12345f);// object ,arguments
        System.out.println(teacherLee.getName() + "老师改变工资之后的工资数: " + teacherLee.getSalary());
        //studentCourseMethod.invoke(studentZhang,null); //NullPointerException, 无参函数怎么调用?
        //studentCourseMethod.invoke(studentLee);

        /*展示字段*/
        System.out.println("\n展示输出Department类的字段:");
        for (Field filed : DepartmentFieldArray) {
            System.out.println(filed.getName() + "的类型为:" + filed.getType());
        }

        /*实际使用*/
        createByFiled(departmentClsObj);
    }

    /*实际的使用, 通过判断字段的多少,创建一个对象, 然后打印输出信息*/
    public static void createByFiled(Class<?> cls) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {
        //获取Constructor[]
        //获取Field[]
        boolean flag = false;
        Constructor[] cons = cls.getDeclaredConstructors();
        Constructor con = null;
        Field[] fields = cls.getDeclaredFields();
        boolean[] flags = new boolean[fields.length];
        List<String> fieldTypeList = new ArrayList<>();//问题是要按照顺序
        for (Field f : fields) {//field的类型的list
            fieldTypeList.add(f.getType().toString());
        }
        int fieldNo = fields.length;
        for (int i = 0; i < cons.length; i++) {
            Parameter[] parameters = cons[i].getParameters();//参数类型
            if (parameters.length == fieldNo) {
                con = cons[i];
                for (int j = 0; j < parameters.length; j++) {
                    if (fieldTypeList.get(j).equals(parameters[j].getType().toString())) {
                        flags[j] = true;
                    } else {
                        flags[j] = false;
                    }
                }
            } else {
                continue;//跳出本次循环
            }
        }
        flag = getState(flags);
        if (flag) {
            System.out.println("有可以使用的构造器!");
            String classTypeName = cls.getTypeName();
            System.out.println(classTypeName);
            for (int i = 0; i < fields.length; i++) {
                System.out.print("第" + i + "个参数名为: " + fields[i].getName() + ", 类型为: " + fields[i].getType());
            }
            // 已知类名, 如何将其转化成对应的class类型
            String[] s = new String[]{"123", "234"};
            //cls.newInstance("a", s); 无参数的可以直接创建, 有参数的不可以直接诶创建
            Object obj = con.newInstance("日语", s);
            System.out.println(obj.getClass());

            Department d = (Department) con.newInstance("日语", s);
            System.out.println(d.getInfo());
        } else {
            System.out.println("...");
        }
    }

    public static boolean getState(boolean[] b) {
        boolean a = false;
        for (boolean l : b) {
            if (l != true) {
                a = false;
                break;//直接跳出循环
            }
            a = true;
        }
        return a;
    }
}

@Data
class School {
    String name;
    String address;

    School() {
        System.out.println("School Constructor...");
    }

}

@Data
class Department extends School {
    String name;//名称
    String[] branch;//分支

    Department() {
        super();
        System.out.println("Department Constructor...");
    }

    Department(String name, String[] branch) {
        super();
        System.out.println("Department Constructor...");
        this.name = name;
        this.branch = branch;
    }

    public String getInfo() {
        // Arrays.deepToString(branch), 讲一个array数组, 转化成一个字符串
        return "Department name is: " + this.name + ", Department branch has" + Arrays.deepToString(branch);
    }
}

@Data
class Teacher extends Department {
    String name;//姓名
    String major;//专业
    float salary;//工资

    Teacher() {
        super();
        System.out.println("Teacher Constructor...");
    }

    Teacher(String name, String major, float salary) {
        super();
        this.name = name;
        this.major = major;
        this.salary = salary;
        System.out.println("Teacher Constructor...");
    }

    public String setTeacherSalary(float salary) {
        this.salary = salary;
        return "设置Teacher" + this.getName() + "的salary为: " + salary;
    }

}

@Data
class Student extends Department {
    String name;//姓名
    List<String> course;//主课
    List<String> team;//社团

    Student() {
        super();
        System.out.println("Student Constructor...");
    }

    Student(String name, List<String> course, List<String> team) {
        super();
        this.name = name;
        this.course = course;
        this.team = team;
        System.out.println("Student Constructor...");
    }

    public String getStudentInfo() {
        return "name为 " + this.getName() + "的 student的主课是" + this.getCourseStr()
                + ", TA参加了" + this.getTeamStr() + " 等社团";
    }

    public String getCourseStr() {
        StringBuilder sb = null;
        for (String s : this.getCourse()) {
            sb.append(s + ", ");
        }
        return (sb.toString().substring(0, sb.length() - 1));
    }

    public String getTeamStr() {
        StringBuilder sb = null;
        for (String s : this.getTeam()) {
            sb.append(s);
        }
        return (sb.toString().substring(0, sb.length() - 1));
    }

}

/*自定义的异常类*/
class MyParamException extends Exception {
    @Setter
    @Getter
    String message;
    @Setter
    @Getter
    String name;

    MyParamException(String name, String message) {
        super(name);
        this.name = name;
        this.message = message;
    }
}
```



##### 126 : "已知类名, 如何将其转化成对应的class类型, 也就是创建对象"问题的思考
A: 这其实是一种思维方式上的震荡, 需要将以前的面向对象的思维, 转化一下, 从它的反面观察.
>使用了特定参数的构造器的话, 其实不必将新建的对象强转成某种类型, 但这样确实有点不方便;
坚持使用[已知类名, 将其转化成对应的class类型], 创建对象, 其实是新建对象, 调用方法思维的延续;
反射, 应该是从一个匿名的对象出发, 找出其类, 然后通过Constructor,Method 将对象作为方法的一个参数, 来使用的;
而且, 如果我们知道了类名, 可以直接使用类名去强制转化, 不用再去想怎么转了;
/*已知类名, 如何将其转化成对应的class类型, 也就是创建对象*/实际上是要把String--->Class Type;
```java
/*已知类名, 如何将其转化成对应的class类型*/
public class ClsName2ClsType {
    static String[] words = new String[]{
            "再接再厉",
            "百尺竿头更进一步",
            "继续加油",
            "勿骄勿躁",
            "继续保持良好的学习状态",
    };

    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException,
            IllegalAccessException, InstantiationException, InvocationTargetException {
        Class c = Class.forName("com.cqu.rjx.syntax.reflect.Singleton");
        Method m = c.getMethod("print"); //Sigleton有一个方法为print
        m.invoke(c.newInstance()); //调用print方法

        Random r = new Random();
        /*已知类名, 如何将其转化成对应的class类型, 也就是创建对象*/
        Class c2 = Class.forName("com.cqu.rjx.syntax.reflect.LittleStudent");//已知类名
        Constructor con = c2.getDeclaredConstructor(String.class, int.class);
        Method method = c2.getMethod("getEvaluate", String.class);
        System.out.println("使用了特定参数的构造器的话, 其实不必将新建的对象强转成某种类型, 但这样确实有点不方便");
        System.out.println("坚持使用[已知类名, 将其转化成对应的class类型], 创建对象, 其实是新建对象, 调用方法思维的延续");
        System.out.println("反射, 应该是从一个匿名的对象出发, 找出其类, 然后通过Constructor,Method 将对象作为方法的一个参数, 来使用的");
        System.out.println("而且, 如果我们知道了类名, 可以直接使用类名去强制转化, 不用再去想怎么转了");
        System.out.println("/*已知类名, 如何将其转化成对应的class类型, 也就是创建对象*/实际上是要把String--->Class Type");
        System.out.println(c2.getTypeName());
        LittleStudent ls = (LittleStudent) con.newInstance("lili", 65);
        method.invoke(con.newInstance("张三", 85), words[r.nextInt(5)]);
        method.invoke(con.newInstance("李四", 92), words[r.nextInt(5)]);
    }
}

class Singleton {
    private static Singleton inst = null;

    public static Singleton getInstance() {
        if (inst == null) {
            inst = new Singleton();
        }
        return inst;
    }

    public void print() {
        System.out.println("i am singleton");
    }
}

@Data
class LittleStudent {
    private String name;
    private int score;

    LittleStudent() {
    }

    LittleStudent(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public void getEvaluate(String words) {
        System.out.println(this.getName() + "同学, 你的成绩是: " + getScore() + ", " + words + "!");
    }
}
```



##### 127 : 反射之中getXXX和getDeclaredXXX的区别
A : 以`getDeclaredMethod()`和`getMethod()`为例, `getDeclaredMethod()`获取的是类自身声明的所有方法, 包含public, protected和private方法. `getMethod()`获取的是类的所有共有方法, 这就包括自身的所有public方法, 和从基类继承的, 从接口实现的所有public方法.
| ` Method`   | `**getDeclaredMethod**(String name, Class... parameterTypes)`            Returns a `Method` object that reflects the specified **declared** method of the class or interface represented by this `Class` object. |
| ----------- | ------------------------------------------------------------ |
| ` Method[]` | `**getDeclaredMethods**()`            Returns an array of `Method` objects reflecting all the methods **declared** by the class or interface represented by this `Class` object. |



| ` Method`   | `**getMethod**(String name, Class... parameterTypes)`            Returns a `Method` object that reflects the specified **public** member method of the class or interface represented by this `Class` object. |
| ----------- | ------------------------------------------------------------ |
| ` Method[]` | `**getMethods**()`            Returns an array containing `Method` objects reflecting all the **public** *member* methods of the class or interface represented by this `Class`object, including those declared by the class or interface and those inherited from superclasses and superinterfaces. |

```java
public class DeclaredOrNot {
    public static void main(String[] args) throws Exception {
        Class<?> cls1 = Class.forName("com.cqu.rjx.syntax.reflect.GirlSay");
        Class<?> cls2 = Class.forName("com.cqu.rjx.syntax.reflect.Say");
        Method[] methodCls1 = cls1.getDeclaredMethods();
        Method[] methodCls2 = cls1.getMethods();
        System.out.println("getDeclaredMethods... ...");
        for (Method m : methodCls1) {
            System.out.println(m.getName() + ", " + m.getDeclaringClass() + ",");
        }
        System.out.println("以上暂时没有返回方法的访问权限...");

        System.out.println("\ngetMethods... ...");
        for (Method m : methodCls2) {
            System.out.println(m.getName() + ", " + m.getDeclaringClass());
        }
    }
}

class JanpaneseGirlSay extends GirlSay {
    private void yamiedieSay() {
        System.out.println("雅蠛蝶....");
    }

}

class GirlSay extends Say {
    public void littleVoice() {
        System.out.println("little voice");
    }

    public void gentleVoice() {
        System.out.println("gentle voice");
    }
}

class Say {
    public void say(String methodStr, String name, int age) throws SecurityException, IllegalArgumentException,
            NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        //  Method method = this.getClass().getMethod("say" + methodStr, new Class[]{String.class,int.class});   //1
        Method method = this.getClass().getDeclaredMethod("say" + methodStr, new Class[]{String.class, int.class}); //2
        method.invoke(this, new Object[]{name, age});
    }

    public void sayHello(String name, int age) {
        System.out.println("hello " + name + ",I know you are " + age);
    }

    protected void sayHi(String name, int age) {
        System.out.println("hi " + name + ",I know you are " + age);
    }

    private void sayBye(String name, int age) {
        System.out.println("bye " + name + ",I know you are " + age);
    }
}
```



##### 128 : Java可变参数的使用例子
```java
/*方法名称相同, 参数列表不同, 可变参数和非可变参数的方法*/
public class VarParam {
    @Getter
    @Setter
    private String girl;
    @Getter
    @Setter
    private String[] args;

    VarParam() {
    }

    VarParam(String girl) {
        this.girl = girl;
    }

    // 可变参数在构造器之中的使用
    VarParam(String girl, String... args) {
        this.girl = girl;
        this.args = args;
    }

    public static void main(String[] args) {
        //当有多个同名的函数, 其中一个是可变参数的函数, 首选固定参数的函数
        VarParam vp = new VarParam();
        vp.test("张三!");
        vp.test("李四");
        vp.test("李四", "张三!");

        //一个函数只能有一个可变参数, 而且必须放在最后一个位置
        VarParam magicQ = new VarParam("magicQ");
        magicQ.getGirlInfo(36, "35C", "174CM", "越南胡志明");

        //测试可变参数为null的情况, 返回java.lang.NullPointerException
        //VarParam testNull = new VarParam("faker beauty");
        //testNull.getGirlInfo(36, null);
        //String[] strs = null;
        //testNull.getGirlInfo(36, strs);


        //构造函数可变参数
        VarParam milkTea = new VarParam("奶茶妹妹", "20A", "165cm", "江苏南京", "京东");
        milkTea.printGirlInfo();
    }

    public void test(String name) {
        System.out.println(name);
        System.out.println("----------");
    }

    public void test(String... names) {
        StringBuilder sb = new StringBuilder();
        for (String s : names) {
            sb.append(s + ", ");
        }
        System.out.println(sb.toString().substring(0, sb.length() - 2));
    }


    public void getGirlInfo(Integer girlAge, String... args) {
        System.out.print("\ngirl' name is: " + this.getGirl() + ", ");
        System.out.print("girl' age is: " + girlAge + ", ");
        StringBuilder sb = new StringBuilder();
        for (String s : args) {
            sb.append(s + ", ");
        }
        System.out.println("girl's other info :" + sb.toString().substring(0, sb.length() - 2));
    }

    // 一个函数只能有一个可变参数, 而且必须放在最后一个位置, 如下的写法是错误的
    // public void getGirlInfo2(String girl, String... args, Integer... others) {
    //
    // }

    public void printGirlInfo() {
        System.out.println("\ngirl' name is: " + this.getGirl() + ", girl's other info :" + Arrays.deepToString(this.getArgs()));
    }
}
```



##### 129 : Spring定时任务
A : 在日常开发中, 经常会用到任务调度这类程序. 实现方法常用的有以下的三种. :one:.通过`java.util.Timer`, `TimerTask`实现.  :two:.通过Spring自带的SpringTask.  :three:. 通过Spring结合Quartz实现.  SpringTask的触发器实现方案有两种, 一种是基于Cron表达式的CronTrigger触发器, 另一种是基于接受固定周期的PeriodicTrigger触发器. 下面说一下Cron表达式的含义.
```java
*     *    *      *     *     *      * 
秒    分    时     日    月     周     年
```

| 字段                     | 允许值                                 | 允许的特殊字符               |
| ------------------------ | -------------------------------------- | ---------------------------- |
| 秒（Seconds）            | 0~59的整数                             | , - * /    四个字符          |
| 分（*Minutes*）          | 0~59的整数                             | , - * /    四个字符          |
| 小时（*Hours*）          | 0~23的整数                             | , - * /    四个字符          |
| 日期（*DayofMonth*）     | 1~31的整数（但是你需要考虑你月的天数） | ,- * ? / L W C     八个字符  |
| 月份（*Month*）          | 1~12的整数或者 JAN-DEC                 | , - * /    四个字符          |
| 星期（*DayofWeek*）      | 1~7的整数或者 SUN-SAT （1=SUN）        | , - * ? / L C #     八个字符 |
| **年(可选，留空)（*Year*）** | 1970~2099                              | , - * /    四个字符          |

每一个域都使用数字，但还可以出现如下特殊字符，它们的含义如下:
```java
1. *：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。
2. ?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。
3. -：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 
4. /：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. 
5. ,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。同一个字段如果有多个值,那么多个值之间用","(逗号)来区分各个值, 不同的字段之间使用空格来区分
6. L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 
7. W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。
8. LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 
9. #:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。
```
几个例子, 如下:
0 0 12 * * ?   每天中午12点触发 
0 15 10 ? * *    每天上午10:15触发 
0 15 10 * * ?     每天上午10:15触发 
0 15 10 * * ? *    每天上午10:15触发 
0 15 10 * * ? 2009    2009年的每天上午10:15触发 
0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发 



ref:
125.[Java进阶04 RTTI](https://www.cnblogs.com/vamei/archive/2013/04/14/3013985.html),   126.[Java中的RTTI与反射](https://www.cnblogs.com/dosmile/p/6444429.html),   127.[Java反射机制(Reflect)解析](https://www.cnblogs.com/fzz9/p/7738381.html),   128.[Java系列笔记(2) - Java RTTI和反射机制](https://www.cnblogs.com/zhguang/p/3091378.html),   129.[Thinking in Java RTTI和反射机制](https://blog.csdn.net/justmantao/article/details/21180813),   130.[Java RTTI和反射的区别？](https://blog.csdn.net/u011694328/article/details/52131562),   131.[Java RTTI和反射的区别](https://zhidao.baidu.com/question/692248071273662884.html),   132.[RTTI和反射](https://blog.csdn.net/dazhong159/article/details/12284251),   133.[Java如何根据类名和方法名创建类的实例，并调用对应方法？](https://blog.csdn.net/zwc2xm/article/details/72912364),   134.[Java反射机制之权限压制](https://blog.csdn.net/milhua/article/details/75050293),   135.[java 反射(reflect)总结，附对象打印工具类](https://www.cnblogs.com/klguang/p/5013399.html),   136.[试用Java中的反射reflect之getDeclaredMethods和getMethods](https://www.cnblogs.com/jianjianjiao/articles/1853409.html), 137.[cron表达式详解](https://www.cnblogs.com/javahr/p/8318728.html),   138.[Spring 定时任务之 @Scheduled cron表达式](https://www.cnblogs.com/softidea/p/5833248.html),   139.[spring @scheduled 定时任务详解](https://blog.csdn.net/chenyiminnanjing/article/details/78491654),   140.[Spring定时任务(一)：SpringTask使用](https://www.cnblogs.com/ark-blog/p/8995243.html)