### 黑盒测试
***
 1. 将软件视为一个打不开的盒子，**主要根据功能需求设计测试用例**，进行测试，也称*功能测试*或*基于规格说明的测试*。测试时，不知道软件是如何实现的，也不关心软件结构，，++只关心软件的输入数据和输出结果++，==黑盒测试主要用于集成测试、系统测试和验收测试==。
 2. 黑盒从用户角度出发，**目的是尽可能多的发现软件外部的行为错误**，从一下4个方面展开：
  1. 检测软件功能能否按照需求规格说明书的规定正常工作，是否有功能遗漏；
  2. 检测是否有人机交互错误，是否有数据结构和外部数据库访问错误，是否能恰当地接收数据并保持外部信息（如数据库或文件）等的完整性；
  3. 检测行为、性能等特性是否满足要求等；
  4. 检测程序初始化和终止方面的错误等。
 3. <font color="red">穷举输入测试是不现实的</font>，++用尽可能少的用例，尽可能多的发现软件故障++。
 4. ==等价类划分、边界值分析、决策表测试是常用的方法==。
 5. **等价类划分**：不考虑程序内部结构，只根据程序规格说明书对输入范围进行划分，**把所有可能的输入数据，划分为若干个互不相交的子集，称为*等价类***，然后从每个等价类中选取少数具有代表性的数据作为测试用例测试。
  - 等价类的划分
 ```mermaid
    graph TD
    O[输入域]-->A["等价类"]
    A-->|"检查:是否实现预先功能和性能"|B["有效等价类"]
    A-->|"检查:是否有不符合要求的之处"|C["无效等价类"]
 ```
  - 等价类划分原则
 ```mermaid
    graph LR
    O(划分原则)
    O-->A[按区间划分]
	O-->B[按数值划分]
	O-->C[按数值集合划分]
	O-->D[按限制条件或规则划分]
    O-->E[细分等价类]
 ```
   在确定了等价类之后，就可形成等价类表，如下：
| 输入条件  | 有效等价类 | 无效等价类 |
| --- | --- |  --- |
|   X  |   x  |  x   |
|  XX  |   x  |  x   |

   - 等价类划分方法
     - 为每个等价类规定一个**唯一**的编号。
     - 设计一个新的测试用例，==尽可能多地覆盖尚未被覆盖的有效等价类==，重复这一步，直到测试用例覆盖了所有的有效等价类。
     - 设计一个新的测试用例，==使其覆盖并且只覆盖一个还没有被覆盖的无效等价类==。重复这一步，直至测试用例覆盖了所有的无效等价类。
  - 等价类方法缺点
     - 规格说明往往没有定义无效测试用例的期望输出的类型与定义。
     - 强类型语言没有必要考虑无效输入。

 6. **边界值分析法**：故障往往出现在*定义域或值域*的**边界上**，而不是在其内部。
  - ==边缘条件描述词==：第一个/最后一个，最小值／最大值，开始／完成，超过/在内，空／满，最短／最长，最慢/最快，最早/最迟，最高／最低，相邻／最远等。
  - 等价类与边界值关系密切，等价类中选取测试数据时应该关注边界值，数据的选取选择**正好等于**、**刚刚大于**或**刚刚小于**等价类边界的值作为测试数据，在测试分析中，还需要取正常域内的Normal值。
  - 一个有n个输入的程序，普通的边界值测试，有4n+1个测试用例，考虑了++健壮性(加入略大于最大值的情况)++的边界值测试，则有6n+1个测试用例。
    *普通边界值测试*
    ![普通边界值测试](http://images.cnblogs.com/cnblogs_com/prayjourney/1041349/o_b1.png)
    *健壮性边界值测试*		
    ![健壮性边界值测试](http://images.cnblogs.com/cnblogs_com/prayjourney/1041349/o_b2.png)
  - 分析原则
      (1). 如果输入条件对取值范围进行了限定，则应以边界内部以及刚超出范围边界外的值作为测试用例。
      (2). 如果对取值的个数进行了界定，则应分别以最大、稍小于最大、稍大于最大、最小、稍小于最小、稍大于最小个数作为测试用例。
      (3). 对于输出条件，同样可以应用上面提到的两条原则来进行测试用例设计。
      (4). 如果程序规格说明书中指明输入或者输出域是一个有序的集合，如顺序文件、表格等，则应注意选取有序集合中的第一个和最后一个元素作为测试用例。

 7. **因果图法**:以上两种方法注重输入条件，当输入条件之间无关联时，以上两种方法较为有效，但是当输入之间有++约束，组合++等关系时，因果图方法的效果较好。
  - 基本符号
    ![基本符号](http://images.cnblogs.com/cnblogs_com/prayjourney/1041349/o_%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB1.png)
  - 约束符号
    ![约束符号](http://images.cnblogs.com/cnblogs_com/prayjourney/1041349/o_%E7%BA%A6%E6%9D%9F%E5%85%B3%E7%B3%BB1.png)
  - 设计步骤
    (1). 确定软件规格(需求)中的原因和结果
    (2). 确定原因和结果之间的逻辑关系
    (3). 确定因果图中的各个约束(constraints)
    (4). 画出因果图并转换为决策表
    (5). 根据决策表设计测试用例

 8. **决策表法**:在所有的黑盒测试之中，最严格，最具逻辑性的方法。==决策表是把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格==。其简明且可以避免遗漏，++*利用决策表可以设计出完整的测似用例集合*++。
  - 决策表组成
| 组成项 | 说明 |
|------------------------|------------------------|
| 条件桩（Condition Stub） |列出了问题的所有条件。通常认为列出的条件的次序无关紧要|
| 动作桩（Action Stub） |列出了问题规定可能采取的操作。这些操作的排列顺序没有约束  |
| 条件项（Condition Entry） | 列出针对它左列条件的取值。在所有可能情况下的真假值 |
| 动作项（Action Entry）  | 列出在条件项的各种取值情况下应该采取的动作 |
  - 决策表建立步骤
    (1).确定规则的个数。有n个条件的决策表有2n 个规则（每个条件取真、假值）。
    (2).列出所有的条件桩和动作桩。
    (3).填入条件项。
    (4).填入动作项，得到初始决策表。
    (5).简化决策表，合并相似规则。
    ==若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并==。合并后的条件项用符号“-”表示，说明执行的动作与该条件的取值无关，称为无关条件。
  - 基本形式与扩展形式
      *基本形式的决策表*，在动作项中仅填以“真”或“假”或类似的表达（如T/F, Y/N, 1/0）。*扩展形式的决策表*，在动作项中还可以填入数值或简短的文字。

 9. **错误推测法**：凭借的是测试人员的**直觉和经验**来推测系统中可能出现的各种缺陷。
 10. **场景法**：软件的工作流程往往对应着现实生活的场景。**在了解系统的业务流程，了解功能模块，熟悉流程的基础上**讨论局部细节的测试设计。场景法的核心是事件流和场景。

  - 示意图：
    ![场景法模式](http://images.cnblogs.com/cnblogs_com/prayjourney/1041349/o_%E5%9C%BA%E6%99%AF%E6%B3%95.jpg)
  - 基本方法：**场景=基本流+备选流**，==基本流==：采用直黑线表示，是经过用例的最简单的路径（无任何差错，程序从开始直接执行到结束），==备选流==：采用不同颜色表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中，也可以起源于另一个备选流，或终止用例，不在加入到基本流中，是一些分支情况。

  - 设计步骤：
      (1). 根据说明，描述出程序的基本流及各项备选流
      (2). 根据基本流和各项备选流生成不同的场景
      (3). 对每一个场景生成相应的测试用例
      (4). 对生成的所有测试用例重新复审，去掉多余的测试用例，测试用例确定后，对每一个测试用例确定测试数据值

   - 以上示意图对应的场景
| 场景 |流 |
|--------|--------|
|  场景 1      | 基本流       |
|  场景 2      | 基本流   ，备选流 1    |
|  场景 3      | 基本流   ，备选流 1   ，备选流 2 |
|  场景 4      | 基本流   ，备选流 3    |
|  场景 5      | 基本流   ，备选流 3   ，备选流 1 |
|  场景 6      | 基本流   ，备选流 3   ，备选流 1   ， 备选流 2   |
|  场景 7      | 基本流   ，备选流 4    |
|  场景 8      | 基本流   ，备选流 3   ，备选流 4 |

 11. **方法的比较和选择**
  - 如果变量引用的是物理量，可采用边界值分析测试和等价类测试。
  - 如果变量是独立的，可采用边界值分析测试和等价类测试。
  - 如果变量不是独立的，可采用决策表测试。
  - 如果可保证是单缺陷假设，可采用边界值分析和健壮性测试。
  - 如果可保证是多缺陷假设，可采用边界值分析测试和决策表测试
  - 如果程序包含大量例外处理，可采用健壮性测试和决策表测试。
  - 如果变量引用的是逻辑量，可采用等价类测试用例和决策表测试。

 12.  **测试工具**
      WinRunner & QTP





ref:
1.[软件测试：因果图法](http://blog.csdn.net/xionghuixionghui/article/details/68216564),   2.[简介一些黑盒测试的方法](http://blog.csdn.net/ilikeprograming/article/details/9255267),   3.[测试用例设计—因果图法](http://www.51testing.com/html/34/247534-153313.html),   4.[测试用例设计—决策表法](http://www.51testing.com/html/70/n-3578470.html),   5.[测试用例设计白皮书－－因果图方法](http://blog.csdn.net/vincetest/article/details/1478552).