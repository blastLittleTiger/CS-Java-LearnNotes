### Java面试总结
***

##### 1.Http报文结构
**Answer**： 答案如下
Http报文分为**请求报文**和**响应报文**, Http响应报文主要由状态行、响应头部、响应正文3部分组成. Http请求报文主要由请求行、请求头部、请求正文3部分组成. 请求方法包括GET、HEAD、PUT、POST、TRACE、OPTIONS、DELETE以及扩展方法, 协议版本的格式为：HTTP/主版本号.次版本号, 常用的有HTTP/1.0和HTTP/1.1协议. 
> [HTTP请求、响应报文格式](http://blog.csdn.net/a19881029/article/details/14002273)



##### 2.Hashtable和HashMap的相同点和不同点, 以及它们的内部实现
**Answer**: 
**相同点**: 存储方式相同, 利用一个内部类, 实现的是Map.Entity接口, 内部实现不一样, 但是都是以节点方式进行存储的. 是一种单向链表, 链表是基于数组的. 

**不同点**: 

  - HashMap可以允许key为null, value为null, HashTable都不允许为null
  - 继承的类不一样, Hashtable<K,V> extends Dictionary<K,V> , HashMap<K,V> extends AbstractMap<K,V>
  - HashMap没有提供同步机制, 是线程不安全的, 需要自己在外面写同步代码, HashTable 部分方法上有自己的 synchronize 同步, 是线程安全的
  - HashMap中没有contains()方法
  - 它们的数组初始化大小和扩容方式不一样, HashTable中hash数组默认大小是11, 增加的方式是 old*2+1. HashMap中hash数组的默认大小是16, 而且一定是2的指数
> [HashMap和HashTable的区别](http://www.cnblogs.com/wuqinglong/p/5746473.html), [HashMap 和 HashTable 到底哪不同 ？](http://www.importnew.com/24822.html)



##### 3.Hibernate的二级缓存
**Answer**: 



##### 4. 活锁是什么
**Answer**:**死锁**是指两个或两个以上的进程(或线程)在执行过程中, 因为争夺资源而造成的一种互相等待的现象, 若无外力作用, 它们都将无法推进下去. 此时称系统处于死锁状态或系统产生了死锁, **这些永远在互相等待的进程称为死锁进程**.
**活锁**: 是指线程1可以使用资源, 但它很礼貌, 让其他线程先使用资源, 线程2也可以使用资源, 但它很绅士, 也让其他线程先使用资源. **这样两个线程之间, 你让我, 我让你, 最后两个线程都无法使用资源的现象**. 活锁不会被阻塞, 而是不停检测一个永远不可能为真的条件. 除去进程本身持有的资源外, 活锁状态的进程会持续耗费宝贵的CPU时间. 
>[Java多线程的死锁, 活锁, 饥饿](https://blog.csdn.net/qq_29924795/article/details/72772251)



##### 5.HashMap内部实现方式
**Answer**:



##### 6.MySQL调优
**Answer**:



##### 7. 设计模式的6个原则
**Answer**:

1.**单一职责原则(Single Responsibility Principle)**,  应该有且只有一个原因引起类的变化, 这里的类不光指类,也适用于方法和接口,比如我们常说的一个方法实现一个功能
2.**里氏代换原则(Liskov Substitution Principle)**, 只要父类出现的地方子类就一定可以出现,而且替换为子类也不会出现任何异常或错误,使用者不需要知道是父类还是子类.但是返回来就不行了,有子类出现的地方,不一定能使用父类. 注意: 采用里氏替换原则时, 尽量避免子类的"个性", 一旦子类有了"个性", 子类和父类的关系就会变得不好调和
3.**依赖倒置原则(Dependence Inversion Principle)**,  依赖倒置原则包含三个含义
- 高层模块不应该依赖低层模块,两者都应该依赖其抽象

- 抽象不应该依赖细节

- 细节应该依赖抽象
  4.**接口隔离原则(Interface Segregation Principle)**, 这个是开闭原则的基础, 具体内容: 针对接口编程, 依赖于抽象而不依赖于具体.
  5.**迪米特法则(Demeter Principle)**,  迪米特法则也叫**最少知识原则**, 含义是 一个对象应该对其他对象有最少的了解, 这个应该很好理解, 就是降低各模块之间的耦合
  6.**开闭原则(Open Close Principle)**, : 一个软件实体如类, 模块和函数应该对扩展开放, 对修改关闭, 开闭原则也是其他五个原则的基石
>[设计模式六大原则](https://www.cnblogs.com/kafeibuku/p/5671394.html)


##### 8.懒汉模式和饿汉模式对线程安全的影响
**Answer**:



##### 9.线程池的框架原理
**Answer**:



##### 10.三次握手和四次挥手
**Answer**: 三次握手是连接, 四次挥手是断开, 分别如下
三次握手
![3woshou](../../../images/3woshou.png)
四次挥手
![4huishou](../../../images/4huishou2.png)
>[TCP协议中的三次握手和四次挥手(图解)](https://www.cnblogs.com/thrillerz/p/6464203.html),   [TCP的三次握手与四次挥手（详解+动图）](https://blog.csdn.net/qzcsu/article/details/72861891)



##### 11.死锁产生的条件
**Answer**: 死锁产生有如下4个必要条件
1. **互斥条件**: 进程对所分配到的资源不允许其他进程进行访问, 若其他进程访问该资源, 只能等待, 直至占有该资源的进程使用完成后释放该资源
2. **请求和保持条件**: 进程获得一定的资源之后, 又对其他资源发出请求, 但是该资源可能被其他进程占有, 此事请求阻塞, 但又对自己获得的资源保持不放
3. **不可剥夺条件**: 是指进程已获得的资源, 在未完成使用之前, 不可被剥夺, 只能在使用完后自己释放
4. **环路等待条件**: 是指进程发生死锁后, 必然存在一个进程--资源之间的环形链
>[死锁产生的四个必要条件及处理死锁的策略](https://www.cnblogs.com/-zyj/p/5683140.html)



##### 12.并发和并行的异同
**Answer**: 并行是指两个或者多个事件在同一时刻发生； 而并发是指两个或多个事件在同一时间间隔发生.
>[并发和并行有什么区别？](http://ifeve.com/parallel_and_con/)



##### 13. 守护线程和非守护线程
**Answer**: Java分为两种线程: 用户线程和守护线程, 所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程, 比如垃圾回收线程就是一个很称职的守护者, 并且这种线程并不属于程序中不可或缺的部分. **因此, 当所有的非守护线程结束时, 程序也就终止了, 同时会杀死进程中的所有守护线程**. 反过来说, 只要任何非守护线程还在运行, 程序就不会终止.

> [Java的守护线程与非守护线程](https://www.cnblogs.com/lixuan1998/p/6937986.html)