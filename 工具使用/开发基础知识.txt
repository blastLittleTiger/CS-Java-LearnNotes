1.开发常用的网络知识
	1.网络分层:
		应用层, 运输层, 网络层, 链路层, 物理层, 一般应用层完成的是各种应用的开发和使用, 是上层应用的驰骋之地, 连接需要三次握手, 断开连接需要四次挥手. 
		
		OSI七层协议: 物理层, 数据链路层, 网络层, 运输层, 会话层, 表示层, 应用层
		五层协议: 物理层, 数据链路层, 网络层, 运输层, 应用层
		HTTP四层协议: 网络接口层, 网际层, 运输层, 应用层
		
		OSI7层表示:
		|  层	        作用/功能	                                   数据	                 协议
		|  物理层	    通过媒介传输比特, 确定机械及电气规范. 	       比特(bit)  	         RJ45, CLOCK, IEEE802.3(中继器, 集线器)
		|  数据链路层	将比特封装成帧, 实现点到点的传输. 	           帧(Frame)	         PPP, FR, HDLC, VLAN, MAC(网桥, 交换机)
		|  网络层	    负责数据包从原地址到目的地址的传输和网际互联   包(Packet)            IP,ICMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)
		|  运输层	    提供端到端的可靠报文传递和错误恢复	           段(Segment)	         TCP, UDP, SPX
		|  会话层	    建立管理终止会话	                           会话协议数据单元(SPDU)	NFS, SQL, NETBIOS, RPC
		|  表示层	    对数据进行翻译, 加密, 压缩	                   表示协议数据单元(PPDU)	JPEG, MPEG, ASII
		V  应用层	    网络进程到应用程序, 针对特定应用规定各层协议, 
					    在端系统中用软件实现	                       应用协议数据单元(APDU)	FTP, DNS, Telnet, SMTP, HTTP, WWW, NFS
					
		TCP/IP5层表示:
		|  层	        作用/功能	                                   数据	                 协议
		|  物理层	    通过媒介传输比特, 确定机械及电气规范. 	       比特(bit)  	         RJ45, CLOCK, IEEE802.3(中继器, 集线器)
		|  数据链路层	将比特封装成帧, 实现点到点的传输. 	           帧(Frame)	         PPP, FR, HDLC, VLAN, MAC(网桥, 交换机)
		|  网络层	    负责数据包从原地址到目的地址的传输和网际互联   包(Packet)            IP,ICMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)
		|  运输层	    提供端到端的可靠报文传递和错误恢复	           段(Segment)	         TCP, UDP, SPX
		V  应用层	    网络进程到应用程序, 针对特定应用规定各层协议, 
					    在端系统中用软件实现	                       应用协议数据单元(APDU)	FTP, DNS, Telnet, SMTP, HTTP, WWW, NFS
		
		参考链接:
			1.[IP地址, 子网掩码, 默认网关, DNS服务器是什么意思?](https://www.cnblogs.com/songQQ/archive/2009/05/27/1490612.html)
			2.[网络基础学习篇(一)](https://blog.csdn.net/angelxf520/article/details/82776971)
			3.[TCP/IP入门(一): 网络基础知识汇总](https://blog.csdn.net/endlessseaofcrow/article/details/80306623)
			4.[计算机网络的基础知识](https://www.cnblogs.com/sker/p/5928939.html)
			5.[干货: 计算机网络知识总结](https://blog.csdn.net/qq_34337272/article/details/79778645)
			6.[计算机网络基础知识--面试收藏必备](https://baijiahao.baidu.com/s?id=1620169126251822734&wfr=spider&for=pc)
			7.[linux之网络知识及相关网络命令](https://blog.csdn.net/qq_34150037/article/details/80725268)


	2.IP地址分类: 
		IP地址在网络层将不同的物理网络地址统一到了全球唯一的IP地址上(屏蔽物理网络差异), IPv4有32位, IPv6有128位, v
		4通常用点分十进制表示,v6使用8组16进制数表示
		
		IP地址层次:
			分为网络号和主机号两个层次, 网络号表示主机所属网络, 主机号表示主机本身. 网络号与主机号的位数与IP地址分类有关.
		IP地址分配的基本原则是:
			要为同一网络(子网, 网段)内不同主机分配相同的网络号, 不同的主机号. 

		IP地址分类:
			|名称      |第一字节      |第二字节         |第三字节          |第四字节            |备注                       |
			|A类地址   |网络号========|主机号===================================================|用于有大量主机的网络       |            
			|B类地址   |网络号==========================|主机号=================================|中等规模的网络             |             
			|C类地址   |网络号=============================================|主机号==============|小规模网络                 |
			|D类地址   |未划分网络号与主机号====================================================|特殊网络                   |
			|E类地址   |未划分网络号与主机号====================================================|特殊网络                   |
			
			|类别      |高位字节(类别表示)      |网络号范围                     |默认掩码       |备注                              |
			|A         |0                       |1.0.0.1--->126.0.0.0           |255.0.0.0      |00000001最开始高位到01111110最高位|  
			|B         |10                      |128.0.0.0--->191.255.255.255   |255.255.0.0    |10000000最开始高位到10111110最高位| 
			|C         |110                     |192.0.0.0--->223.255.255.255   |255.255.255.0  |11000000最开始高位到11011110最高位| 
			|D         |1110                    |224.0.0.0--->239.255.255.255   |               |11100000最开始高位到11101110最高位| 
			|E         |11110                   |未分配                         |               |11110000最开始高位到11110110最高位| 
			|全0和全1,有特殊用途,0.0.0.0用于找自己, 1.1.1.1是受限的广播地址                                                        |
		
		A类IP地址:
			一个A类IP地址由1字节的网络地址和3字节主机地址组成, 网络地址的最高位必须是"0",  地址范围从1.0.0.0 到126.0.0.0. 可用的A类网络有126个, 每个网络能容纳1亿多个主机. 

		B类IP地址:
			一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成, 网络地址的最高位必须是"10", 地址范围从128.0.0.0到191.255.255.255. 
			可用的B类网络有16382个, 每个网络能容纳6万多个主机 . 

		C类IP地址: 
			一个C类IP地址由3字节的网络地址和1字节的主机地址组成, 网络地址的最高位必须是"110". 范围从192.0.0.0到223.255.255.255. 	C类网络可达209万余个, 每个网络能容纳254个主机. 

		D类地址
			用于多点广播(Multicast).  D类IP地址第一个字节以"1110"开始, 它是一个专门保留的地址. 它并不指向特定的网络, 	目前这一类地址被用在多点广播(Multicast)中. 多点广播地址用来一次寻址一组计算机, 它标识共享同一协议的一组计算机. 

		E类地址 
			以"llll0"开始, 为将来使用保留. 
		参考链接:
			1.[(Network)计算机网络基础知识总结](https://www.cnblogs.com/maybe2030/p/4781555.html)
			2.[IP地址分类及范围详解:A, B, C, D, E5类是如何划分的?](https://cloud.tencent.com/info/f38b95c8a1edf8acb2f885e68f4b45e4.html)
			3.[IPv4中IP地址分类](https://www.cnblogs.com/qiaoconglovelife/p/5349486.html)
			4.[网络基础知识(一)](https://blog.csdn.net/qq_32563713/article/details/81433176)
			5.[linux之网络知识及相关网络命令](https://blog.csdn.net/qq_34150037/article/details/80725268)
	
	
	3.IP之中各种地址:
		1.网络地址
			IP地址由网络号(包括子网号)和主机号组成, 网络地址的主机号为全0, 网络地址代表着整个网络.
　　	2.广播地址
		　　广播地址通常称为直接广播地址, 是为了区分受限广播地址. 广播地址与网络地址的主机号正好相反, 广播地址中, 主机号为全1. 
			当向某个网络的广播地址发送消息时, 该网络内的所有主机都能收到该广播消息. 
		3.组播地址
			D类地址就是组播地址. 
		　　先回忆下A, B, C, D类地址吧: 
		　　A类地址以0开头, 第一个字节作为网络号, 地址范围为: 0.0.0.0~127.255.255.255;
		　　B类地址以10开头, 前两个字节作为网络号, 地址范围是: 128.0.0.0~191.255.255.255;
		　　C类地址以110开头, 前三个字节作为网络号, 地址范围是: 192.0.0.0~223.255.255.255.
		　　D类地址以1110开头, 地址范围是224.0.0.0~239.255.255.255, D类地址作为组播地址(一对多的通信)；
		　　E类地址以1111开头, 地址范围是240.0.0.0~255.255.255.255, E类地址为保留地址, 供以后使用. 
		　　注: 只有A,B,C有网络号和主机号之分, D类地址和E类地址没有划分网络号和主机号. 
		4.255.255.255.255
			该IP地址指的是受限的广播地址. 受限广播地址与一般广播地址(直接广播地址)的区别在于, 受限广播地址只能用于本地网络, 
			路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播, 也可跨网段广播. 
			例如: 主机192.168.1.1/30上的直接广播数据包后, 另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报, 则不能收到. 
			注: 一般的广播地址(直接广播地址)能够通过某些路由器(当然不是所有的路由器), 而受限的广播地址不能通过路由器. 
		5.0.0.0.0
			常用于寻找自己的IP地址, 例如在我们的RARP, BOOTP和DHCP协议中, 若某个未知IP地址的无盘机想要知道自己的IP地址, 
			它就以255.255.255.255为目的地址, 向本地范围(具体而言是被各个路由器屏蔽的范围内)的服务器发送IP请求分组. 
		6.回环地址
　　		127.0.0.0/8被用作回环地址, 回环地址表示本机的地址, 常用于对本机的测试, 用的最多的是127.0.0.1. 
　　	7.A, B, C类私有地址
		　　私有地址(private address)也叫专用地址, 它们不会在全球使用, 只具有本地意义. 
		　　A类私有地址: 10.0.0.0/8, 范围是: 10.0.0.0~10.255.255.255
		　　B类私有地址: 172.16.0.0/12, 范围是: 172.16.0.0~172.31.255.255
		　　C类私有地址: 192.168.0.0/16, 范围是: 192.168.0.0~192.168.255.255
		参考链接:
			1.[[Network] 计算机网络基础知识总结](https://www.cnblogs.com/maybe2030/p/4781555.html)

		
	4.子网掩码及网络划分:
　　	随着互连网应用的不断扩大, 原先的IPv4的弊端也逐渐暴露出来, 即网络号占位太多, 而主机号位太少, 所以其能提供的主机地址也越来越稀缺, 
		目前除了使用NAT在企业内部利用保留地址自行分配以外, 通常都对一个高类别的IP地址进行再划分, 形成多个子网, 提供给不同规模的用户群使用.
		这里主要是为了在网络分段情况下有效地利用IP地址, 通过对主机号的高位部分取作为子网号, 从通常的网络位界限中扩展或压缩子网掩码, 用来创建某类地址的更多子网. 但创建更多的子网时, 在每个子网上的可用主机地址数目会比原先减少. 

　　	什么是子网掩码?
　　		子网掩码是标志两个IP地址是否同属于一个子网的, 也是32位二进制地址, 其每一个为1代表该位是网络位, 
			为0代表主机位. 它和IP地址一样也是使用点式十进制来表示的. 如果两个IP地址在子网掩码的按位与的计算下所得结果相同, 
			即表明它们共属于同一子网中. 
　　		在计算子网掩码时, 我们要注意IP地址中的保留地址, 即"0"地址和广播地址, 它们是指主机地址或网络地址全为"0"或"1"时的IP地址, 
			它们代表着本网络地址和广播地址, 一般是不能被计算在内的. 

　　	子网掩码的计算: 
			对于无须再划分成子网的IP地址来说, 其子网掩码非常简单, 即按照其定义即可写出: 如某B类IP地址为 10.12.3.0, 无须再分割子网, 则该IP地址的子网掩码255.255.0.0. 如果它是一个C类地址, 则其子网掩码为 255.255.255.0. 其它类推, 不再详述. 下面我们关键要介绍的是一个IP地址, 还需要将其高位主机位再作为划分出的子网网络号, 剩下的是每个子网的主机号, 这时该如何进行每个子网的掩码计算. 

　　		下面总结一下有关子网掩码和网络划分常见的面试考题: 

　　		1.利用子网数来计算
			　　在求子网掩码之前必须先搞清楚要划分的子网数目, 以及每个子网内的所需主机数目. 
			　　(1) 将子网数目转化为二进制来表示;
			　　	如欲将B类IP地址168.195.0.0划分成27个子网: 27=11011；
			　　(2) 取得该二进制的位数, 为N；
			　　	该二进制为五位数, N = 5
			　　(3) 取得该IP地址的类子网掩码, 将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码. 
			　　	将B类地址的子网掩码255.255.0.0的主机地址前5位置 1, 得到 255.255.248.0

		　　2.利用主机数来计算
		　　	如欲将B类IP地址168.195.0.0划分成若干子网, 每个子网内有主机700台: 
			　　(1) 将主机数目转化为二进制来表示；
			　　	700=1010111100；
			　　(2) 如果主机数小于或等于254(注意去掉保留的两个IP地址), 则取得该主机的二进制位数, 为N, 这里肯定 N<8. 
					如果大于254, 则 N>8, 这就是说主机地址将占据不止8位；该二进制为十位数, N=10；
			　　(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1, 然后从后向前的将N位全部置为 0, 即为子网掩码值. 
			　　	将该B类地址的子网掩码255.255.0.0的主机地址全部置1, 得到255.255.255.255, 然后再从后向前将后 							
					10位置0,即为: 11111111.11111111.11111100.00000000, 即255.255.252.0. 
					这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码. 

　　		3.还有一种题型, 要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码. 这也可按上述原则进行计算. 
　　			比如一个子网有10台主机, 那么对于这个子网需要的IP地址是: 
			　　10＋1＋1＋1＝13
			　　注意: 加的第一个1是指这个网络连接时所需的网关地址, 接着的两个1分别是指网络地址和广播地址. 
　　			因为13小于16(16等于2的4次方), 所以主机位为4位. 而256－16＝240, 所以该子网掩码为255.255.255.240. 
　				如果一个子网有14台主机, 不少人常犯的错误是: 依然分配具有16个地址空间的子网, 而忘记了给网关分配地址. 
				这样就错误了, 因为14＋1＋1＋1＝17, 17大于16, 所以我们只能分配具有32个地址(32等于2的5次方)空间的子网. 
				这时子网掩码为: 255.255.255.224. 
		参考链接:
			1.[[Network] 计算机网络基础知识总结](https://www.cnblogs.com/maybe2030/p/4781555.html)


	5.TCP/IP&连接和释放: 
		TCP/IP:
			TCP/IP协议是Internet最基本的协议, Internet国际互联网络的基础, 由网络层的IP协议和传输层的TCP协议组成. 
			通俗而言: TCP负责发现传输的问题, 一有问题就发出信号, 要求重新传输, 直到所有数据安全正确地传输到目的地. 
			而IP是给因特网的每一台联网设备规定一个地址. 
		
		三次握手四次挥手:
			三次握手(A:你好, 我想和你说话? B: 你好, 我在的. A:那我给你发送数据了.[表示A&B同时在线, 这时候, 会话已经是连接上了]);
			四次挥手(A: 我这没事儿了, 你还有事儿吗?(1次挥手)[主要是确认一下],    B: 我也没事儿了, 你确定没事儿了吗?(2次挥手),
					 A: 我这儿没事了, 我要挂电话了.(3次挥手)                     B: 好的, 你挂电话吧.(4次挥手))
		参考链接:
			[TCP/IP_网络基础知识](https://blog.csdn.net/xc13212777631/article/details/80882691)
			https://github.com/jawil/blog/issues/14 , https://blog.csdn.net/qzcsu/article/details/72861891 , 
			https://blog.csdn.net/qq_37939251/article/details/83511451 , https://blog.csdn.net/smileiam/article/details/78226816 , 
			https://www.jianshu.com/p/9968b16b607e , https://www.cnblogs.com/zmlctt/p/3690998.html , 
			https://blog.csdn.net/qq_36783216/article/details/78063280 , https://blog.csdn.net/qq_38775473/article/details/84894126 , 
			https://blog.csdn.net/kingov/article/details/77155671 , http://www.ishenping.com/ArtInfo/162566.html , 
			https://zhuanlan.zhihu.com/p/40667482
	
	
	6.SOCKET:
		Socket是什么
			Socket是应用层与TCP/IP协议族通信的中间软件抽象层, 它是一组接口. 在设计模式中, 
			Socket其实就是一个门面模式, 它把复杂的TCP/IP协议族隐藏在Socket接口后面, 对用户来说, 
			一组简单的接口就是全部, 让Socket去组织数据, 以符合指定的协议. 
			
			客户端和服务器, 都是应用层的"应用", 应用层的数据需要传输, 就需要使用TCP/IP协议, 但是应用无法直接和TCP/IP建立
			连接, 就需要使用到虚拟的Socket层, 他是在应用层和运输层之间, 一个编程的接口层
			
			------------------------------------------------------------------------------------------------------------
			客户端                     服务器                    |    应用层   | 进程1   进程2     进程3     进程4  进程5   
			------------------------------------------------------------------------------------------------------------
		                        socket(建立)                     |             |           |          |       |
									bind(绑定ip&端口)    		 | 			   |           |          |       |  
		                                listen(监听)             |             |   ________V__________V_______V__________
		                                                         |             |  |                                     |
		                                                         |             |  |        Socket抽象层                 |
		    socket(建立)                                         |             |  |_____________________________________|
		       connect(连接到服务器)                             |             |			|               |
		                                 accept(接受请求)        |             |            V               V
		                                                         |    运输层   |          TCP             UDP
		                                                         |             |
		            read/write            read/write             |    网络层   |       ICMP            IP        IGMP
		                                                         |             |
		                                                         |    链路层   |    ARP            RARP  硬件接口
		                                                         |             |
						close                                    |             |
											close                |             |                                        
			
			参考链接:
				1.[Socket通信原理](https://www.cnblogs.com/wangcq/p/3520400.html)
				2.[Socket详解](https://www.cnblogs.com/jiangxiulian/p/7489615.html)
				3.[socket编程入门: 1天玩转socket通信技术(非常详细)](http://c.biancheng.net/socket/)
				4.[Java开发之Socket编程详解](https://www.cnblogs.com/Jepson1218/p/5178792.html)
				5.[{Socket}Java Socket编程基础及深入讲解](https://www.cnblogs.com/yiwangzhibujian/p/7107785.html)
				6.[Socket在Java中的使用](https://blog.csdn.net/Yoryky/article/details/78557801)
				7.[Java socket详解,看这一篇就够了](https://www.jianshu.com/p/cde27461c226)
				
				
	7.HTTP协议:
		超文本传输协议, 目前使用HTTP1.1, HTTP协议通常承载于TCP协议之上, 有时也承载于TLS或SSL协议层之上, 这个时候, 
		就成了我们常说的HTTPS.  默认HTTP的端口号为80, HTTPS的端口号为443. HTTP协议永远都是客户端发起请求, 服务器回送响应. 
        这样就限制了使用HTTP协议, 无法实现在客户端没有发起请求的时候, 服务器将消息推送给客户端. HTTP协议是一个无状态的协议, 
		同一个客户端的这次请求和上次请求是没有对应关系. 
		
		HTTP工作流程:
			一次HTTP操作称为一个事务, 其工作过程可分为四步: 
			1)首先客户机与服务器需要建立连接. 只要单击某个超级链接, HTTP的工作开始. 	2)建立连接后, 客户机发送一个请求给服务器, 请求方式的格式为: 统一资源标识符(URL), 协议版本号, 
		       后边是MIME信息包括请求修饰符, 客户机信息和可能的内容. 
		    3)服务器接到请求后, 给予相应的响应信息, 其格式为一个状态行, 包括信息的协议版本号, 一个成功或错误的代码, 
			   后边是MIME信息包括服务器信息, 实体信息和可能的内容. 
			4)客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上, 然后客户机与服务器断开连接. 			   
			   如果在以上过程中的某一步出现错误, 那么产生错误的信息将返回到客户端, 有显示屏输出. 对于用户来说, 
			   这些过程是由HTTP自己完成的, 用户只要用鼠标点击, 等待信息显示就可以了. 
		参考链接:
			1.[http协议详解(超详细)](https://www.cnblogs.com/wangning528/p/6388464.html)
			2.[http协议原理](https://blog.51cto.com/12805107/2067971)
			3.[HTTP协议详解(真的很经典)](https://www.cnblogs.com/lzq198754/p/5780310.html)
	
	
	8.HTTP请求例子:
		在浏览器中输入 www.baidu.com  后执行的全部过程. 现在假设如果我们在客户端(客户端)浏览器中输入http://www.baidu.com, 
        而baidu.com为要访问的服务器(服务器), 下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作: 
		1)客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48, 通过这个IP地址找到客户端到服务器的路径. 
	       客户端浏览器发起一个HTTP会话到220.161.27.48, 然后通过TCP进行封装数据包, 输入到网络层. 
	    2)在客户端的传输层, 把HTTP会话请求分成报文段, 添加源和目的端口, 如服务器使用80端口监听客户端的请求, 
		   客户端由系统随机选择一个端口如5000, 与服务器进行交换, 服务器把相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.  
		3)客户端的网络层不用关系应用层或者传输层的东西, 主要做的是通过查找路由表确定如何到达服务器, 期间可能经过多个路由器, 
		   这些都是由路由器, 来完成的工作, 不作过多的描述, 无非就是通过查找路由表决定通过那个路径到达服务器. 
		4)客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址, 然后发送ARP请求查找目的地址, 
		   如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了, 然后发送IP数据包到达服务器的地址. 


	9.cookie, session, token: 
        举个简单例子就像人们去超市购物, 去存包, 第一个去的时候(客户第一次发送请求给服务器), 超市会给你一个号码牌
		(此时服务器产生一个唯一的sessionID, 并返回给客户端(通过cookie)),你可以在你自己的柜子里存东西(
		在服务器属于此客户的内存区域存数据),下次你再去的时候,  拿着这个号码牌(请求request中携带cookie),
		超市就知道哪些东西是你的, 然后给你取出来, 如果你几天都没去取( session失效了, 在服务器端配置),你再去的时候东西
		就拿不到了. 如果你把这个号码牌丢了(刚才的cookie失效了, 比如你重启电脑,  刚才存于内存中sessionID也就丢了), 
		再去拿东西, 当然无法定位了, 也就拿不到东西了. 如果是新打开一个浏览器的情况, 那就像是又一个人去超市存东西一样, 
		你的东西跟他的东西是两码事, 互不影响, 他有他自己的sessionID, 你有你自己的. 
		
		存放情况:
			1.session存储于服务器, 可以理解为一个状态列表, 拥有一个唯一识别符号sessionId, 通常存放于cookie中. 
			  服务器收到cookie后解析出sessionId, 再去session列表中查找, 才能找到相应session. 依赖cookie而使用.
			2.cookie类似一个令牌, 装有sessionId, 存储在客户端, 浏览器通常会自动添加. 
			3.token也类似一个令牌, 无状态, 用户信息都被加密到token中, 服务器收到token后解密就可知道是哪个用户. 需要开发者手动添加. 
		
		参考链接:
				http://bubkoo.com/2014/04/21/http-cookies-explained/ , https://segmentfault.com/a/1190000017831088 , 
				https://www.cnblogs.com/wxinyu/p/9154178.html , https://blog.csdn.net/ToBeTheEnder/article/details/52485948 , 
				https://blog.csdn.net/jikeehuang/article/details/51488020 , http://www.cnblogs.com/moyand/p/9047978.html , 
				https://segmentfault.com/q/1010000012984880/a-1020000012987025.


	10.Cross-site request forgery: 
		跨站请求伪造, 是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作(如发邮件, 发消息, 
		甚至财产操作如转账和购买商品). 由于浏览器曾经认证过, 所以被访问的网站会认为是真正的用户操作而去运行. 
		这利用了web中用户身份验证的一个漏洞: 简单的身份验证只能保证请求发自某个用户的浏览器, 却不能保证请求本身是用户自愿发出的. 
		Cross-site scripting: 跨站脚本攻击, 是恶意攻击者往Web页面里插入恶意代码(java, javascript, vbscript等), 当用户浏览该页之时, 
		嵌入其中Web页面里面的代码会被执行, 从而达到恶意用户的特殊目的. 
		
		参考链接:
			https://www.cnblogs.com/dolphinX/p/3391351.html , https://thief.one/2017/05/31/1/ ,
			https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0



2.HTTP错误码
    HTTP请求, 返回了什么错误码, 就要根据错误码去分析, 前端的, 后端的, 根据各自的错误情况, 着手去分析, 这样才能分析到问题的原因

    1xx: 信息提示
    这些状态码表示临时的响应, 客户端在收到常规响应之前, 应准备接收一个或多个 1xx 响应. 
        100: Continue, 继续, 初始的请求已经接受, 客户应当继续发送请求的其余部分. 
        101: Switching Protocols, 切换协议, 服务器将遵从客户的请求转换到另外一种协议. 

    2xx: 成功
    这类状态代码表明服务器成功地接受了客户端请求. 
        200: OK, 请求成功. 
        201: Created, 服务器已经创建了文档, Location头给出了它的URL. 
        202: Accepted, 服务器已接受请求, 但尚未处理. 正如它可能被拒绝一样, 最终该请求可能会也可能不会被执行. 返回202状态码的响应的目的是允许服务器接受其他过程的请求, 而不必让客户端一直保持与服务器的连接直到批处理操作全部完成. 
        203:  Non-Authoritative Information, 文档已经正常地返回, 但一些应答头可能不正确, 因为使用的是文档的拷贝(返回的实体头部元信息不是在原始服务器上有效的确定集合, 而是来自本地或者第三方的拷贝, 非权威性信息. 

    3xx: 重定向
    这类状态码代表需要客户端采取进一步的操作才能完成请求. 通常, 这些状态码用来重定向, 后续的请求地址重定向目标在本次响应的 Location 域中指明. 
        300:  Multiple Choices, 多路选择, 客户请求的文档可以在多个位置找到, 这些位置已经在返回的文档内列出. 用户或浏览器能够自行选择一个首选的地址进行重定向. 
        301:  Moved Permanently, 永久转移, 客户请求的文档在其他地方, 新的URL在Location头中给出, 浏览器应该自动地访问新的URL. 
        302:  Found, 暂时转移, 类似于301, 但新的URL应该被视为临时性的替代, 而不是永久性的. 

    4xx: 客户端
    这类的状态码代表了客户端看起来可能发生了错误, 妨碍了服务器的处理. 
        400: Bad Request, 错误请求. 1语义有误, 当前请求无法被服务器理解. 除非进行修改, 否则客户端不应该重复提交这个请求. 2请求参数有误. 
        401: Unauthorized, 未授权, 访问被拒绝. 
        402: Payment Required, 需要付费. 
        403: Forbidden, 禁止, 服务器已经理解请求, 但是拒绝执行它. 
        404: Not Found, 未找到, 服务器找不到指定的资源, 文档不存在. 
        405: Method Not Allowed, 方法不允许, 请求方法GET, POST, HEAD, Delete, PUT, TRACE等对指定的资源不适用, 用来访问本页面的 HTTP 谓词不被允许方法不被允许. 
        406: Not Acceptable, 不接受, 请求的资源的内容特性无法满足请求头中的条件, 因而无法生成响应实体. 
        407: Proxy Authentication Required, 需要代理认证, 与401响应类似, 只不过客户端必须在代理服务器上进行身份验证. 代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问. 
        408: Request Timeout, 请求超时, 客户端没有在服务器预备等待的时间内完成一个请求的发送. 客户端可以随时再次提交这一请求而无需进行任何更改. 
        409: Conflict, 冲突, 通常和PUT请求有关. 由于请求和资源的当前状态相冲突, 因此请求不能成功. 
        410: Gone, 失败, 被请求的资源在服务器上已经不再可用, 而且没有任何已知的转发地址. 这样的状况应当被认为是永久性的. 
        411: Length Required, 需要长度, 服务器拒绝在没有定义 Content-Length 头的情况下接受请求. 
        412: Precondition Failed, 前提条件失败, 服务器在验证在请求的头字段中给出先决条件时, 没能满足其中的一个或多个. 
        413: Request Entity Too Large, 请求实体太长, 服务器拒绝处理当前请求, 因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围. 
        414: Request-URI Too Long, 请求URI太长, 请求的URI 长度超过了服务器能够解释的长度. 

    5xx: 服务器错误
    这类状态码代表服务器遇到了意料不到的情况, 不能完成客户的请求. 
        500: Internal Server Error, 服务器内部错误. 
        501: Not Implemented, 页眉指定了未实现的配置, 服务器不支持当前请求所需要的某个功能. 
        502: Bad Gateway, 网关失败, 作为网关或者代理工作的服务器尝试执行请求时, 从上游服务器接收到无效的响应. 
        503: Service Unavailable, 服务不可用, 服务器由于维护或者负载过重未能应答. 
        504: Gateway Timeout, 网关超时, 作为网关或者代理工作的服务器尝试执行请求时, 未能及时从上游服务器或者辅助服务器收到响应. 
        505: HTTP Version Not Supported, 服务器不支持请求中所指明的HTTP版本. 

    参考链接:
        https://blog.csdn.net/qq_38820315/article/details/81512056
        https://blog.csdn.net/qiutiandepaomo/article/details/81984830
		
		

3.常用的Linux命令
	1.学习链接: 
		http://man.linuxde.net/linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86
        http://man.linuxde.net/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E9%8C%84%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4


	2.常用: 
		1.history
			history命令就是历史记录. 它显示了在终端中所执行过的所有命令的历史. 
			参考链接: https://www.cnblogs.com/Blog-Yang/p/3247292.html
		2.grep
			管道, 过滤, 作为linux中最为常用的三大文本(awk, sed, grep)处理工具之一, grep命令的常用格式为: grep [选项] "模式" [文件]
			grep家族总共有三个: grep, egrep, fgrep, 一般常用grep.　　
				-E : 开启扩展Extend的正则表达式. 
				-i : 忽略大小写ignore case. 
　　			-n : 显示行号
　　			-w : 被匹配的文本只能是单词, 而不能是单词中的某一部分, 如文本中有liker, 而我搜寻的只是like, 就可以使用-w选项来避免匹配liker
　　            --color :将匹配到的内容以颜色高亮显示. 
			参考链接: https://www.cnblogs.com/flyor/p/6411140.html
			2.1
				awk: https://www.cnblogs.com/jiqianqian/p/7944013.html
			2.2
				sed:https://www.cnblogs.com/wangqiguo/p/6718512.html
		3.xxx --help(man xxx)
			xxx --help, 是对xxx命令的常用选项和用法格式的一个介绍,  man xxx也是介绍,  man的内容比较复杂是详细介绍, xxx --help比较简洁, 简单介绍
		4.pwd 当前路径(dirs)
		5.l(ls) 显示给出路径之中的文档列表 
			Usage: ls [OPTION]... [FILE]...
			参数: 
				-a:                          do not ignore entries starting with .
				-A:                          do not list implied . and ..
				-s, --size                   print the allocated size of each file, in blocks
				-l:                          use a long listing format
				-t:                          sort by modification time
				-h, --human-readable         with -l, print sizes in human readable format (e.g., 1K 234M 2G)
				-d, --directory              list directory entries instead of contents, and do not dereference symbolic links
				-R, --recursive              list subdirectories recursively(列出子文件夹之中的文件)
			例子: 
				ls -lh      //可以将文件的大小从字节, 转换成为KB,MB,GB等常见熟悉的情况类型
			参考链接: 
				https://www.cnblogs.com/xqzt/p/5380627.html , https://www.cnblogs.com/aijianshi/p/5756346.html
		6.ifconfig 查看当前的ip信息
			add del netmask
			例子:
				ifconfig eth0 192.168.1.1 netmask 255.255.255.0   临时配置ip
				ifconfig eth1 down    停止网卡
				ifconfig eth1 up      启动网卡
			参考链接:
				1.[linux下配置临时IP](https://blog.csdn.net/lv302677589/article/details/79087893)
			
		7.ip 查看ip的信息
			参数:
				link          网络设备
				address       设备上的协议(IP或IPv6)地址
				addrlabel     协议地址选择的标签配置
				neighbour     ARP或NDISC缓存条目
				route         路由表条目
				rule          路由策略数据库中的规则
				maddress      组播地址
			
			例子:
				ip a/addr/address add 192.168.78.130/24 dev eth1          增加ip
				ip a/addr/address del/delete 192.168.78.130/24 dev eth1   删除ip
			参考链接:
				1.[Linux命令之ip](https://www.cnblogs.com/diantong/p/9511072.html)
				2.[linux ip命令和ifconfig命令](https://blog.csdn.net/freeking101/article/details/68939059)


	3.系统:
        命令检查, 设置服务
            1.chkconfig
                命令检查, 设置系统的各种服务, 常用的有如下的几种, 增加一个服务的时候, 脚本必须在/etc/init.d/的目录下
                    chkconfig --list             #列出所有的系统服务.
                    chkconfig --add httpd        #增加httpd服务.
                    chkconfig --del httpd        #删除httpd服务.

                参考链接:
                    http://man.linuxde.net/chkconfig
			2.uname
				查看系统信息 uname -a, 等价的有: lsb_release -a, cat /etc/issue, cat /proc/version
				有如下的信息: 
				Linux version 3.0.76-0.11-default (geeko@buildhost) (gcc version 4.3.4 [gcc-4_3-branch revision 152973] (SUSE Linux) ) #1 SMP Fri Jun 14 08:21:43 UTC 2013 (ccab990)
				Welcome to SUSE Linux Enterprise Server 11 SP3  (x86_64) - Kernel \r (\l).
			3.远程登录 ssh
				ssh开启root登录: 
				修改/etc/ssh/sshd_config文件, PermitRootLogin yes, PasswordAuthentication yes, 重启ssh服务 /etc/init.d/ssh start,  查看状态/etc/init.d/ssh status
				参考链接: 
					https://blog.csdn.net/u010953692/article/details/80312751
				例子:ssh DRManager@100.133.187.169
				参考链接: 
					https://www.cnblogs.com/joshua317/articles/4740881.html , https://blog.csdn.net/li528405176/article/details/82810342
			4.who:  who 命令显示关于当前在本地系统上的所有用户的信息
				a  处理 /etc/utmp 文件或有全部信息的指定文件. 等同于指定 -bdlprtTu 标志. 
				-b 指出最近系统启动的时间和日期. 
				-l 列出任何登录进程. 
				-m 仅显示关于当前终端的信息. who -m 命令等同于 who am i 和 who am I 命令. 
				-q 打印一份在本地系统上的用户和用户数的快速清单. 
				https://www.cnblogs.com/ftl1012/p/who.html
			5.whoami: 显示当前登陆的用户名
			6.which:  查看可执行文件的位置,从全局环境变量PATH里面查找对应的路径,默认是找 bash内所规范的目录. 
				如which cp, 返回cp命令的位置. /bin/cp
				https://www.cnblogs.com/ftl1012/p/which.html
			7.whereis: whereis命令只能用于搜索程序名在什么地方, 配合-b,只搜索二进制, -m搜索在manual之中的位置
				如: xww:~/Desktop/rrr # whereis cp
					cp: /bin/cp /usr/share/man/man1p/cp.1p.gz /usr/share/man/man1/cp.1.gz
				如: xww:~/Desktop/rrr # whereis -b cp
					cp: /bin/cp

			8.reboot : 重启系统
			9.poweroff: 关机且断电
			10.shutdown: 关机(halt)
			11.ctrlaltdel: 设置组合键Ctrl+Alt+Del的功能
			12.type : type命令用来区分某个命令到底是由shell自带的, 还是由shell外部的独立二进制文件提供的.   	
				如果一个命令是外部命令, 那么使用-p参数, 会显示该命令的路径, 相当于which命令. 
				https://www.cnblogs.com/jycjy/p/6940544.html
			13.free:
				free (free) 命令可以显示Linux系统中空闲的, 已用的物理内存及swap内存, 及被内核使用的buffer. 
				用法: free [-b | -k | -m | -g | -h] [-o] [-s delay ] [-c count ] [-a] [-t] [-l] [-V]
				参数: 
					-b 　以Byte为单位显示内存使用情况.  
					-k 　以KB为单位显示内存使用情况.  
					-m 　以MB为单位显示内存使用情况. 
					-g   以GB为单位显示内存使用情况.  
					-h   以human readable方式输出(有的可能不支持)
					-o 　不显示缓冲区调节列.  
					-s<间隔秒数> 　持续观察内存使用状况.  
					-t 　显示内存总和列.  RAM+SWAP
					-V 　显示版本信息. 
				https://www.cnblogs.com/xqzt/p/5448916.html
			14.df:
				df (disk free) 其功能显示每个文件所在的文件系统的信息, 默认是显示所有文件系统. 
				-a: 显示所有的磁盘使用情况
				-h: 以人性化的方式显示磁盘使用情况, GB, MB, KB这些单位,  常用df -a -h或者缩写 df -ah, 
					所有的-x都可以缩写,  所有的--x也可以缩写在一起
				https://www.cnblogs.com/xqzt/p/5436967.html
			15.du:
				du (Disk usage) 用来计算每个文件的磁盘用量, 目录则取总用量. 默认是当前的目录, 也可以在du 后面指定目录, 显示文件的大小
				-a: 相应文件夹下所有的文件的大小
				-h: 以人性化的方式显示磁盘使用情况, GB, MB, KB这些单位,  常用du -a -h或者缩写 du -ah
				-s: 求和, 默认是当前文件夹下面的所有的大小 du -sh,  du -sh name.py
				https://www.cnblogs.com/xqzt/p/5436970.html
			16.vmstat
				vmstat(Virtual Memory Statistics 虚拟内存统计) 命令用来显示Linux系统虚拟内存状态, 也可以报告关于进程, 内存, I/O等系统整体运行状态. 
				-a: 显示活跃和非活跃内存
				-f: 显示从系统启动至今的fork数量 . 
				-S: 使用指定单位显示. 参数有 k , K , m , M , 分别代表1000, 1024, 1000000, 1048576字节byte. 默认单位为K1024 bytes
				-V: 显示vmstat版本信息. 
				https://www.cnblogs.com/xqzt/p/5448983.html
			17.iostat
				iostat(I/O statistics 输入/输出统计) 命令对系统的磁盘操作活动进行监视. 它的特点是汇报磁盘活动统计情况, 同时也会汇报出CPU使用情况
				-c: 仅显示CPU使用情况； 
				-d: 仅显示设备利用率；一般不和-c一起使用 
				-k: 显示状态以千字节每秒为单位, 而不使用块每秒； 
				-m: 显示状态以兆字节每秒为单位；
				-N 显示磁盘阵列(LVM) 信息
				-n 显示NFS 使用情况
				-p: 仅显示块设备和所有被使用的其他分区的状态； 
				-t: 显示每个报告产生时的时间； 
				-V: 显示版号并退出； 
				-x: 显示扩展状态. 
				例子: 
					iostat -d -k 2 3:  每2秒钟检查一次, 一共检查3次
					iostat -d -k    :  查看磁盘读写速度, 以k为单位
				https://www.cnblogs.com/xqzt/p/5449034.html


    4.文件:
        复制:cp,  例子: cp /home/xxx.txt /opt/mg/123.txt 复制
        移动:mv,  可以直接移动文件夹,  可以重命名文件
        删除:rm -rf  rm -rf /home/zgy,  递归删除/home/zgy文件夹,  -r, -R参数是递归的意思 
		创建文件夹: mkdir, mkdir xxx,  在当前目录下创建了xxx文件夹
		删除文件夹: rmdir, rmdir xxx,  删除当前目录下的xxx文件夹
		创建文件: touch(当文件不存在的时候创建文件), 更新文件的访问和修改时间,  touch命令将每个文件的访问时间和修改时间改为当前时间. 
			参数选项: 
				-a              只更改访问时间
				-t STAMP        使用[[CC]YY]MMDDhhmm[.ss] 格式的时间而非当前时间
			例子: 
				touch a.log                             更新a.log的修改时间为当前时间,   没有a.log则创建
				touch -r a.log   b.log                  更新log1.log的时间和log2.log时间戳相同
				touch -t 201601011200.50 log.log        设定文件的时间戳
			参考链接: 
				https://www.cnblogs.com/xqzt/p/5399407.html
		安全复制: scp
			格式: 
			usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
			[-l limit] [-o ssh_option] [-P port] [-S program]
			[[user@]host1:]file1 ... [[user@]host2:]file2

			scp: ssl+cp, 安全的复制, 可以从本机--->远程,  也可以从远程--->本机, 或者从远程主机1--->远程主机2
			例子: 
				scp etc/fgg.tar DRManager@100.133.187.169:/home/DRManager/ff 把etc下面的fgg.tar文件复制到远程主机的相应文件夹之中
				scp DRManager@100.133.187.169:/home/DRManager/ff/etc.tar ./  把远程主机的文件复制到本主机上
			参考链接:
				https://www.cnblogs.com/webnote/p/5877920.html , https://www.cnblogs.com/z977690557/p/6826495.html,
				https://blog.csdn.net/cyl101816/article/details/81170732
		tar:打包和解包[不是压缩]
			例子: 
				tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar. 创建archive.tar,  把foo, bar文件或者文件夹打包到其中. 
				tar -tvf archive.tar         # List all files in archive.tar verbosely.   列出archive.tar文件之中的文件列表. 
				tar -xf archive.tar          # Extract all files from archive.tar.       
			名词: 
				打包: 将一大堆文件或目录变成一个总的文件【tar命令】
				压缩: 将一个大的文件通过一些压缩算法变成一个小文件【gzip, bzip2等】
			Linux中很多压缩程序只能针对一个文件进行压缩, 这样当你想要压缩一大堆文件时, 你得将这一大堆文件先打成一个包tar命令, 然后再用压缩程序进行压缩gzip bzip2命令. 

			tar语法: 
				语法: tar [主选项+辅选项] 文件或目录
				使用该命令时, 主选项必须有, 它告诉tar要做什么事情, 辅选项是辅助使用的, 可以选用. 
				
				主选项: 【一条命令以下5个参数只能有一个】
				-c: --create 新建一个压缩文档, 即打包
				-x: --extract,--get解压文件
				-t: --list,查看压缩文档里的所有内容
				-r:--append 向压缩文档里追加文件
				-u:--update 更新原压缩包中的文件

				辅助选项: 
				-z:是否同时具有gzip的属性?即是否需要用gzip压缩或解压?一般格式为xxx.tar.gz或xx.tgz
				-j:是否同时具有bzip2的属性?即是否需要用bzip2压缩或解压?一般格式为xx.tar.bz2
				-v:显示操作过程！这个参数很常用
				-f:使用文档名, 注意, 在f之后要立即接文档名, 不要再加其他参数！
				-C:切换到指定目录
				--exclude FILE:在压缩过程中, 不要将FILE打包
				
			参考链接: 
				https://www.cnblogs.com/starof/p/4229017.html ,  https://www.cnblogs.com/GyForever1004/p/8491071.html , https://www.cnblogs.com/newcaoguo/p/5896975.html,  https://www.cnblogs.com/wuxiang/p/4799959.html


	5.日志查看: 
		1.cat
			功能和例子
				cat命令是linux下的一个文本输出命令, 通常是用于观看某个文件的内容的；cat主要有三大功能: 
				1.一次显示整个文件. cat filename
				2.从键盘创建一个文件.  cat  >  filename,   写完内容后,  Control-D结束写入
				只能创建新文件,不能编辑已有文件.
				3.将几个文件合并为一个文件.  cat   file1   file2  > file
			说明: 
				tac是从最后一行输出全部的内容,  和cat的功能类似, 只是相反的方向. 
			参数说明: 
				cat具体命令格式为 : cat [-AbeEnstTuv] [--help] [--version] fileName
				-n 从1开始对于所有的输出行数编号
			参考链接: 
				https://www.cnblogs.com/zhangchenliang/p/7717602.html,  https://blog.csdn.net/songlang90/article/details/46397679,  
				https://blog.csdn.net/u010003835/article/details/53331385,  https://www.cnblogs.com/xqzt/p/5410283.html
		2.less
			less 工具也是对文件或其它输出进行分页显示的工具, 是linux正统查看文件内容的工具, 功能极其强大. 比起 more 更加的有弹性.  
			
			less(less)  命令可以对文件或其它输出进行分页显示, 与moe命令相似, 但是比more命令要强大许多. 应该说是linux正统查看文件内容的工具. 
			less的功能和more相似, 但是使用more无法向前翻页, 只能向后翻, 而less可以任意切换, 下面就着重介绍下less命令的具体用法: 
			命令格式: 
				less  [选项]... [文件]...
			参数: 
				-g 只标志最后搜索的关键词
				-i 忽略搜索时的大小写
				-m 显示类似more命令的百分比
				-N 显示每行的行号
				
				内部的命令: 
					ctrl + F - 向前移动一屏ctrl-f作用和ctrl-F正好相反,  下面的几个也都是一样, 大写和小写是相反的作用
					ctrl + B - 向后移动一屏
					ctrl + D - 向前移动半屏
					ctrl + U - 向后移动半屏
					/字符串: 向下搜索"字符串"的功能
					?字符串: 向上搜索"字符串"的功能
					n:       重复前一个搜索与 / 或 ? 有关
					N:       反向重复前一个搜索与 / 或 ? 有关
					space:   空格表示向后移动一屏
					enter:   回车表示向下移动一行
					j:       向前移动一行
					k:       向后移动一行
					g:       移动到最开始一行
					G:       移动到最后一行
					q:       退出
					:e       在看本文件的时候, 去打开另一个文件看[相当牛逼的功能]
				
				其他: less 版 tail -f
					在 Linux 动态查看日志文件常用的命令非 tail -f 莫属, 其实 less 也能完成这项工作, 使用 F 命令. 
					使用 less file-name 打开日志文件, 执行命令 F, 可以实现类似 tail -f 的效果. 多个文件的显示效果一般, 一个文件效果和tailf相同,  非常不错的功能

				
			例子: 
				ps -ef|less -N                             //显示行数, 分页显示所有的进程
				less test2.log test.log                    //同时查看多个日志  
				less -N fcd.txt, 进入后 :e msg.txt         //在查看fcd.txt的同时间, 然后 去查看msg.txt, 使用q退出
				less fcd.log 进入后按F                     //实时显示fcd.log的内容
				history | less                             //执行命令的历史记录分页查看

			参考链接: 
				https://www.cnblogs.com/luxiaojun/p/6439663.html ,  https://www.cnblogs.com/GNblog/p/6932252.html
				https://www.cnblogs.com/GNblog/p/6932252.html , http://man.linuxde.net/less
				https://www.cnblogs.com/xqzt/p/5424866.html,  https://blog.csdn.net/daidaineteasy/article/details/51017270
				https://www.cnblogs.com/molao-doing/articles/6541455.html https://www.cnblogs.com/joechu/p/8947411.html
				https://www.cnblogs.com/xqzt/category/813892.html
				
			
				
			
		3.more
			less的功能和more相似, 但是使用more无法向前翻页, 只能向后翻, 而less可以任意切换. 
			more命令, 类似cat, 该命令一次显示一屏文本, 满屏后停下来, 并且在屏幕的底部出现一个提示信息, 给出至今己显示的该文件的百分比,
			方便逐页阅读(file perusal filter for crt viewing) . more名单中内置了若干快捷键, 按空白键space就往下一页显示, 按 b 键就会往回back一页显示, 而且还有搜寻字串的功能与 vi 相似, 使用中按h可以查看说明文件 . 
			命令格式: 	
				more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]
			参数: 
				ctrl-b向前翻一页(back
				ctrl-f向后翻一页
				space空格 向后翻一页
				enter回车 向下一行
				-num 一次显示的行数 
				-d 提示使用者, 在画面下方显示 [Press space to continue, 'q' to quit.] 如果按错键, 则会显示 [Press 'h' for instructions.] 而不是 '哔' 声 
				-l 取消遇见特殊字元 ^L送纸字元时会暂停的功能 忽略Ctrl+l换页字符 
				-f 计算行数时, 以实际上的行数, 而非自动换行过后的行数有些单行字数太长的会被扩展为两行或两行以上 
				+/ 在每个档案显示前搜寻该字串pattern, 然后从该字串之后开始显示 
				+num 从第 num 行开始显示 
				fileNames 欲显示内容的档案, 可为复数个数
			例子: 
				more 001.txt kkk.txt //首先显示 001.txt的内容,  完后显示kkk.txt的内容, 
				more -10 001.txt     //显示20行
			参考链接: 
				https://www.cnblogs.com/xqzt/p/5414814.html ,  https://www.cnblogs.com/luxiaojun/p/6439663.html
				https://www.cnblogs.com/cocoajin/p/3741016.html
		
		4.tail
			查看后面几行的代码,  一般配合grep使用, 通过grep实现过滤, tail -100 xxx.log|grep java 查看xxx.log之中后100行关于Java的部分
			参数含义: 
				-n 行数, -10表示查看10行
				-f 连续滚动输出,  后续的输出当做流,  继续输出,  也就是可以实时持续输出,  可以简写为tailf
			
			说明: 
				使用的时候,  可以同时显示多个文件
			例子: 
				tail -n 10 xxx.log|grep java = 	 tail -10 xxx.log|grep java
				tail -f startLog.log|grep ERROR
				tail -n 5 legoStart.log  commandrun.log 这个可以同时显示多个文件的内容,  此时用-10, 就失效了,  需要用-n 10来表示行数
				
				展示情况: 
					root:/opt/FC/Runtime/logs # tail -n 5 legoStart.log  commandrun.log 
					==> legoStart.log <==
					[2019/05/25 19:12:47.775][INFO][getStartStatus start...][LEGO_START][getStartStatus,299][main]
					[2019/05/25 19:12:47.776][ERROR][flagFile is not exist][LEGO_START][getStartStatus,307][main]
					[2019/05/25 19:12:47.776][INFO][startup status is null!][LEGO_START][main,90][main]
					[2019/05/25 19:12:47.776][ERROR][Test failed, retry after sleep five seconds .][LEGO_START][main,97][main]
					[2019/05/25 19:12:57.776][ERROR][Server Start failed!][LEGO_START][main,106][main]

					==> commandrun.log <==
					user: [ICUser] time: [2019/05/23 00:58:29:320439192] command:[run.sh]
					user: [ICUser] time: [2019/05/23 01:06:47:279925537] command:[run.sh]
					user: [ICUser] time: [2019/05/23 01:23:17:127594376] command:[run.sh]
					user: [ICUser] time: [2019/05/25 18:43:55:706642386] command:[run.sh]
					root:/opt/FC/Runtime/logs # 
			参考链接: 
				https://www.cnblogs.com/xqzt/p/5425331.html
				
		5.head
			head用来显示档案的开头至标准输出中, 一般配合grep使用, 通过grep实现过滤, head -100 xxx.log|grep java 查看xxx.log之中开头100行关于java 的部分
			参数含义: 
				-n 行数, -10表示查看10行,  一个文件的时候写成 -10,  多个文件操作需要写成 -n 10
			
			说明: 
				使用的时候,  可以同时显示多个文件
			例子: 
				head -n 5 log.txt = head -5 log.txt
				head -n 10 log.txt fc.txt
			参考链接: 
				https://www.cnblogs.com/xqzt/p/5425287.html
		
		6.od
			od命令用于输出文件的八进制, 十六进制或其它格式编码的字节, 通常用于显示或查看文件中不能直接显示在终端的字符. 
			常见的文件为文本文件和二进制文件. 此命令主要用来查看保存在二进制文件中的值. 
			d 十进制 
			o 八进制系统默认值 
			x 十六进制 
			-c     same as -t c,  select ASCII characters or backslash escapes 按照ascii的方式显示

			https://www.cnblogs.com/hdk1993/p/4395574.html ,  https://www.cnblogs.com/kex1n/p/6101626.html
			https://blog.csdn.net/youmatterhsp/article/details/80298470 ,  https://blog.csdn.net/yaoshenjie/article/details/77494171
			https://www.cnblogs.com/hdk1993/p/4395574.html
				
		7.find
			格式: find [查找目录] [查找规则] [查找完后的操作] find pathname -option [-print -exec -ok …]
			参数: 
				查找规则: 
					-name:  按照文件名搜索；(?表示  通配任意的单个字符, *表示任意个字符)
					-iname: 按照文件名搜索, 不区分文件名大小；
					-user:  根据属主Owner来查找文件, 也有-uid, 是用户编号
					-group: 根据属组group来查找文件, 也有-gid, 是属组编号
					-atime: 根据文件时间戳的相关属性来查找文件, *time的单位是天,  *min的单位是分钟
							-atime, -ctime, -mtime,  a访问,  m修改内容, c修改属性
							-amin, -cmin, -mmin
					-type:  按照文件类型来查找文件, f 普通文件, d 目录文件, l 链接文件,  p 管道文件,  s socket文件  -type f
					-size:  按照大小来查找文件, +大于, -小于, 无等于 +2M, 表示大于2M
					-perm:  按照文件权限查找文件, 777,222等
				查找完后的操作: 
					-print                 //默认情况下的动作
					-ls                    //查找到后用ls 显示出来
					-ok  [commend]         //查找后执行命令的时候询问用户是否要执行
					-exec [commend]        //查找后执行命令的时候不询问用户, 直接执行
			例子: 
				find /root /etc /tmp -iname hello.txt  //在这三个目录下面查找hello.txt文件, 不区分大小写
				find /root /etc /tmp -iname avr?.txt   //在这三个目录下面查找hello.txt文件, 不区分大小写
				find  /tmp  -size  +2M                 //查找在/tmp 目录下大于2M的文件
				find  /tmp  -perm  +222                //表示只要有一类用户属主, 属组, 其他的匹配写权限就行
				find  /tmp  -uid  500                  //查找uid是500 的文件
				find  /tmp  -name hello.txt -ls        //查找在/tmp目录下名字是hello.txt的文档, 并且输出详细情况
				
			参考链接: 
					http://blog.chinaunix.net/uid-24648486-id-2998767 , https://blog.csdn.net/m0_38121874/article/details/77019127
					http://c.biancheng.net/view/779.html , https://www.oschina.net/translate/15-practical-linux-find-command-examples
		8.cut:
			cut根据指定的定界符, 切分文件, 并将选中的列输出到标准输出. 
			格式:cut [选项]... [文件]...
			参数: 
				-b: 仅显示行中指定直接范围的内容；
				-c: 仅显示行中指定范围的字符；
				-d: 指定字段的分隔符, 默认的字段分隔符为"TAB"；
				-f: 显示指定字段的内容；
				-n: 与"-b"选项连用, 不分割多字节字符；
				--complement: 补足被选择的字节, 字符或字段；
				--out-delimiter=<字段分隔符>: 指定输出内容是的字段分割符；
			例子: 
				cat /etc/passwd | cut -b1-3　#取每行的第1-3字字节
				cut -f2,3 test.txt           显示每行2-3内容
				tail -n 5 /etc/passwd |cut -d ":" -f 3,4          -f n-m打印第n-m个字段,  分隔符换成了:
			参考链接: 
				https://www.cnblogs.com/xqzt/p/5858309.html,  https://www.cnblogs.com/siqi/p/3608893.html,  
			    https://www.cnblogs.com/Spiro-K/p/6361646.html
			
	
    6.网络:
        监听状态, 端口监听, 端口操作:
            1.netstat
                netstat命令用于显示与IP, TCP, UDP和ICMP协议相关的统计数据, 一般用于检验本机各端口的网络连接情况. netstat是在内核中访问网络及相关信息的程序,
                它能提供TCP连接, TCP和UDP监听, 进程内存管理的相关报告.
                常用参数:
                    -a或–all: 显示所有连线中的Socket;
                    -c或–continuous: 持续列出网络状态; 
                    -l或–listening: 显示监控中的服务器的Socket;
                    -n或–numeric: 直接使用ip地址, 而不通过域名服务器;
                    -p或–programs: 显示正在使用Socket的程序识别码和程序名称; 
                    -t或–tcp: 显示TCP传输协议的连线状况;
                    -u或–udp: 显示UDP传输协议的连线状况;
                    -o或者--timers: 显示计时器

                常用命令:
                    netstat -ano
                    netstat -anpo
                    netstat -lntup
                    netstat -r :显示路由信息

                常见网络连接状态:
                    LISTEN: 侦听来自远方的TCP端口的连接请求
                    SYN-SENT: 再发送连接请求后等待匹配的连接请求如果有大量这样的状态包, 检查是否中招了
                    SYN-RECEIVED: 再收到和发送一个连接请求后等待对方对连接请求的确认如有大量此状态, 估计被flood攻击了
                    ESTABLISHED: 代表一个打开的连接
                    FIN-WAIT-1: 等待远程TCP连接中断请求, 或先前的连接中断请求的确认
                    FIN-WAIT-2: 从远程TCP等待连接中断请求
                    CLOSE-WAIT: 等待从本地用户发来的连接中断请求
                    CLOSING: 等待远程TCP对连接中断的确认
                    LAST-ACK: 等待原来的发向远程TCP的连接中断请求的确认不是什么好东西, 此项出现, 检查是否被攻击
                    TIME-WAIT: 等待足够的时间以确保远程TCP接收到连接中断请求的确认
                    CLOSED: 没有任何连接状态

                zuiguangyin:~ # netstat -an
                Active Internet connections (servers and established)
                Proto Recv-Q Send-Q Local Address           Foreign Address         State      
                tcp        0      0 127.0.0.1:61806         0.0.0.0:*               LISTEN      
                tcp        0      0 127.0.0.1:6432          0.0.0.0:*               LISTEN      
                tcp        0    624 100.133.175.197:22      8.46.214.227:61370      ESTABLISHED 
                tcp        0      0 :::111                  :::*                    LISTEN      
                tcp        0      0 :::22                   :::*                    LISTEN      
                tcp        0      0 ::1:631                 :::*                    LISTEN      
                tcp        0      0 ::1:25                  :::*                    LISTEN      
                tcp        0      0 127.0.0.1:25410         :::*                    LISTEN      
                tcp        0      0 100.133.175.197:25411   :::*                    LISTEN      
                udp        0      0 0.0.0.0:631             0.0.0.0:*                           
                udp        0      0 0.0.0.0:784             0.0.0.0:*                           

                参考链接:
                    https://www.cnblogs.com/ftl1012/p/netstat.html
                    http://man.linuxde.net/netstat
                    https://blog.csdn.net/freeking101/article/details/53520974
                    https://blog.csdn.net/u010739551/article/details/80736032
                    https://www.cnblogs.com/liuzhengliang/p/4609632.html
                    https://www.cnblogs.com/chenweichu/articles/6441710.html
            
            2.telnet
                远程登录
                    通常可以判断端口是不是通了, 默认23端口, 比如telnet 100.133.138.67 8239, 测试100.133.138.67的8239端口是否是通的,比如
                    telnet 14.29.122.153 80 连接失败, 就表示是80端口不通

                参考链接:
                    https://www.cnblogs.com/walter371/p/3973579.html
                    https://www.cnblogs.com/ylcms/p/7250129.html
                    https://www.cnblogs.com/linuxprobe/p/5381554.html
                    https://blog.csdn.net/weixin_33716154/article/details/86018627
                    https://www.cnblogs.com/ylcms/p/7250129.html
                    https://www.cnblogs.com/linuxprobe/p/5381554.html
                    https://blog.csdn.net/doubleqinyan/article/details/80492421
                    https://blog.csdn.net/weixin_33716154/article/details/86018627
                    https://zhidao.baidu.com/question/130016945.html
					https://blog.csdn.net/junmail/article/details/5429458
					https://www.cnblogs.com/duyy/archive/2014/04/01/3637782.html

            3.lsof
                lsof命令用于查看你进程开打的文件, 打开文件的进程, 进程打开的端口(TCP, UDP). 找回/恢复删除的文件.
                是十分方便的系统监视工具, 因为lsof命令需要访问核心内存和各种文件, 所以需要root用户执行.

                常用命令:
                    lsof 文件名 :查看谁正在使用某个文件lsof 文件名
                    lsof -i 22 :查看端口22现在的运行情况
                    lsof -p 12 :列出进程号为12的进程打开了哪些文件
                    lsof -a -u root -d txt :查看所属root用户进程所打开的文件类型为txt的文件

                zuiguangyin:~ # lsof |grep sshd
                sshd       7481       root  cwd       DIR                8,2     4096          2 /
                sshd       7481       root  rtd       DIR                8,2     4096          2 /
                sshd       7481       root  txt       REG                8,2   571568    3023009 /usr/sbin/sshd
                sshd       7481       root  mem       REG                8,2   135124    2261027 /lib64/libpthread-2.11.3.so
                sshd       7481       root  mem       REG                8,2    35800    2834502 /usr/lib64/libkrb5support.so.0.1
                sshd       7481       root  mem       REG                8,2   351360     642021 /usr/lib64/libssl.so.0.9.8
                sshd       7481       root  mem       REG                8,2   110440    2834532 /usr/lib64/libsasl2.so.2.0.22

                参数含义:
                    COMMAND: 进程的名称
                    PID: 进程标识符
                    PPID: 父进程标识符(需要指定-R参数)
                    USER: 进程所有者
                    PGID: 进程所属组
                    FD: 文件描述符, 应用程序通过文件描述符识别该文件.

                参考链接:
                    https://blog.csdn.net/yr137157/article/details/87112312
                    https://blog.csdn.net/lemontree1945/article/details/80742522
                    https://www.cnblogs.com/sparkbj/p/7161669.html
               
    7.权限:
        rwx: r=4, w=2, x=1
        group:
            chgrp Tomcat xxx.txt
        owner:
            chown ICUser xxx.txt; chown ICUser abc*; 改变xxx.txt文件的所有者为ICUser,
        right:
            chmod 777 XXX
	
    8.进程:
        查看进程:
            1.ps(program status) 
                ps是显示瞬间进程的状态, 将某个进程显示出来, 并不动态连续; 如果想对进程进行实时监控应该用top命令.
                grep是查找, "|"是管道命令, 让ps与grep同时执行, grep命令是查找, 是一种强大的文本搜索工具, 
                它能使用正则表达式搜索文本, 并把匹配的行打印出来. grep表示全局正则表达式, 它的使用权限是所有用户.
                
                以下这条命令是检查java 进程是否存在: ps -ef |grep java
                字段含义如下: 
                UID           PID       PPID        C     STIME      TTY         TIME         CMD
                zzw           14124     13991       0     00:38      pts/0       00:00:00     grep --color=auto dae
                UID是执行者, PID是进程号, PPID:其上级父程序的ID, C是cpu占用资源, TTY是登入者的终端机位置, TIME是使用掉的CPU时间, CMD是下达的指令名称   
                
                常用参数:
                    -A: 所有的进程均显示出来, 与 -e 具有同样的效用;
                    -a: 显示现行终端机下的所有进程, 包括其他用户的进程;
                    -u: 以用户为主的进程状态; 
                     x: 通常与 a 这个参数一起使用, 可列出较完整信息. 
                输出格式规划:  
                    l: 较长, 较详细的将该 PID 的的信息列出;
                    j: 工作的格式(jobs format)
                    -f: 做一个更为完整的输出.

                常用命令:
                    ps -ef |grep java 检查java进程
                    ps aux 列出所有正在内存中的程序
                    ps aux |grep java

                参考链接:
                    https://www.cnblogs.com/freinds/p/8074651.html
                    https://blog.csdn.net/u011641865/article/details/71435510
                    https://www.cnblogs.com/liuzhengliang/p/4609632.html

            2.top
                Linux系统可以通过top命令查看系统的CPU, 内存, 运行时间, 交换分区, 执行的线程等信息. 通过top命令可以有效的发现系统的
                缺陷出在哪里, 是内存不够, CPU处理能力不够, IO读写过高等,

                zuiguangyin:~ # top
                top - 00:12:54 up 22 days,  5:22,  1 user,  load average: 0.01, 0.04, 0.31
                Tasks: 149 total,   1 running, 148 sleeping,   0 stopped,   0 zombie
                Cpu(s): 24.5%us, 17.3%sy,  0.0%ni, 58.2%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
                Mem:   8062708k total,  3135080k used,  4927628k free,   238292k buffers
                Swap:  8394744k total,        0k used,  8394744k free,  2398544k cached

                PID          USER      PR  NI  VIRT  RES  SHR S   %CPU %MEM    TIME+  COMMAND                                                                                       
                18327        root      20   0 3544m  59m  13m S     54  0.8   0:01.13 java                                                                                           
                17670        gaussdb   20   0 12944 3012 1296 S      2  0.0   0:00.05 gaussdb.sh                                                                                     
                4462         root      20   0  8364 4584  320 S      0  0.1  40:00.14 haveged                                                                                        
                6736         gdm       20   0  261m  36m  12m S      0  0.5  45:29.09 gdm-simple-gree                                                                                                                                                              
                    3        root      20   0     0    0    0 S      0  0.0   5:59.61 ksoftirqd/0                     


                参数说明:
                前5行为系统总体资源统计情况
                    top - 　　　　　　   系统当前时间
                    up     　　　　　    系统已开机多长时间
                    user       　　　　  当前用户数
                    load average        cpu平均负载, 三个数值分别为, 1分钟, 5分钟, 15分钟
                    Tasks         　　  系统当前进程数, total: 总进程数, running: 正在运行的进程数, sleeping: 睡眠的进程数, stopped: 停止的进程数, zombie: 僵尸进程数
                    %Cpu(s)             cpu使用率, us: 用户使用cpu百分百, sy: 系统内核使用cpu百分百, id: 剩余的cpu百分百
                    Mem           　　　 内存使用信息, total: 总内存大小, free: 空闲的内存, used: 已使用的内存, buff/cache: 缓存的内存大小
                    Swap         　　    虚拟内存信息
                    
                    PID　　　　         进程id
                    USER　　　　        进程所有者
                    PR　　　　　　      优先级
                    NI　　　　　　　    nice值, 负值表示高优先级, 正值表示低优先级
                    VIRT 　　　　　     进程使用的虚拟内存总量
                    RES 　　　　　      进程使用的物理内存大小
                    SHR 　　　　　      共享内存大小
                    S 　　　　　　      进程状态, D: 不可中断的睡眠状态, R: 运行, S: 睡眠, T: 跟踪/停止, Z: 僵尸进程
                    %CPU 　　　　       进程使用的CPU占用百分比
                    %MEM 　　　　       进程使用的物理内存百分比
                    TIME+ 　　　　      进程使用的CPU时间总计
                    COMMAND　　        命令名
                
                参考链接:
                    https://blog.csdn.net/csdn066/article/details/77171018
                    https://www.cnblogs.com/ftl1012/p/top.html
                    https://www.cnblogs.com/yhongji/p/9355290.html

        杀死进程:
            1.kill
                一般而言, 杀掉进程之前, 需要查找进程, 就需要使用ps -ef |grep java, ps -ef|grep tomcat等命令, 找到了之后杀掉. 
                语法如下:
                    kill: usage: kill [-s 信号声明 | -n 信号编号 | -信号声明] 进程号 | 任务声明 ... or kill -l [信号声明]
                通过kill -l我们可以找到相应的信号, 然后用相应的数字, 比如常用的kill -9 pid, 9表示立即强制杀死. 比如 kill -9 1234.

                参考链接:
                    https://www.cnblogs.com/xiaojinniu425/p/9429716.html
                    https://www.cnblogs.com/liuhouhou/p/5400540.html
					
					

4.vim基本技能
	必备: 
		写模式: i,a,o
		退出写模式: ecs
		Ctrl+u: 向文件首翻半屏；
		Ctrl+d: 向文件尾翻半屏；
		Ctrl+f: 向文件尾翻一屏；
		Ctrl+b: 向文件首翻一屏；
		dd: 删除本行
		yy: 复制本行到剪切板
		p： 在当前位置后粘贴
		P：在当前位置前粘贴
		G: 到文件尾
		gg: 到文件第一行
		$: 跳到行尾
		^: 跳到行首
		:行号: 光标跳转到指定行的行首；
		/字符串: 文本查找操作, 用于从当前光标所在位置开始向文件尾部查找指定字符串的内容, 查找的字符串会被加亮显示；
		?字符串: 文本查找操作, 用于从当前光标所在位置开始向文件头部查找指定字符串的内容, 查找的字符串会被加亮显示；
		a, bs/F/T: 替换文本操作, 用于在第a行到第b行之间, 将F字符串换成T字符串. 其中, "s/"表示进行替换操作；
		:set number: 在命令模式下, 用于在最左端显示行号；
	常用: 
		ZZ: 命令模式下保存当前文件所做的修改后退出vi；
		:$: 光标跳转到最后一行的行首；
		x或X: 删除一个字符, x删除光标后的, 而X删除光标前的；
		D: 删除从当前光标到光标所在行尾的全部字符；
		dd: 删除光标行正行内容；
		p: 粘贴文本操作, 用于将缓存区的内容粘贴到当前光标所在位置的下方；
		P: 粘贴文本操作, 用于将缓存区的内容粘贴到当前光标所在位置的上方；
		o: 在当前行后面插入一空行；
		O: 在当前行前面插入一空行；
		:set nonumber: 在命令模式下, 用于在最左端不显示行号；

	参考链接: 
		http://man.linuxde.net/vi  https://www.cnblogs.com/orez88/articles/1867879.html
		https://www.cnblogs.com/prayjourney/p/10949972.html



5.正则表达式
	基本语法
		一般字符       匹配自身
		.             除了换行符之外的任意一个字符
		\             转意字符
		^             取反, 在方括号之中使用, 如[^\d], 表示非数字 
		[...]         方括号之中的范围, 如[a-z], 表示从a-z的一个字符, 也可以是数字
		\d            数字
		\D            非数字
		\s            空白字符
		\S            非空白字符
		\w            单词字符,[A-Za-z0-9]
		\W            非单词字符[^\w]
		*             匹配0个或者无限个字符
		+             匹配1个或者无限个字符
		?             匹配0个或者1个字符
		{m}           匹配1个字符m次
		{m, n}        匹配1个字符m次至n次, 如果n省略, 则从m次到无限次
		^             匹配字符串开头, 多行则每一行都匹配
		$             匹配字符串末尾, 多行则每一行都匹配
		|             匹配|号左右的任意一个

	参考链接:
	1.[Python爬虫入门七之正则表达式](https://cuiqingcai.com/977.html), 2.[Python re模块和正则表达式](https://segmentfault.com/a/1190000004706952),
	3.[爬虫初级操作二](https://segmentfault.com/a/1190000015643064), 4.[Python下正则表达式学习笔记](https://segmentfault.com/a/1190000005123798),
	5.[Python 正则表达式 re 模块简明笔记](https://segmentfault.com/a/1190000007929344), 6.[Python中的正则表达式](https://segmentfault.com/a/1190000015123481)



6.shell
	shell编写
	参考链接：
		1.https://blog.csdn.net/shuaiby/article/details/46776033 , 
		2.[Linux Makefile](https://blog.csdn.net/qq769651718/article/category/7467398) , 
		3.[Linux shell脚本 （一）编写运行第一个脚本](https://blog.csdn.net/qq769651718/article/details/79375526) , 
		4.[Linux shell脚本学习系列](https://blog.csdn.net/qq769651718/article/category/7467504)



7.其他
	1.log4j
		Log4j根据日志信息的重要程度, 分为**OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE, ALL**, Log4j官方建议实际使用之中, Log4j建议只使用四个级别, 优先级从高到低分别是 ***ERROR, WARN, INFO, DEBUG*** . 有如下配置的例子: `log4j.rootLogger=INFO, stdout, logfile`, 例子之中表示: **INFO后debug级别的就不再输出了**,  只有INFO, WARN, ERROR这些比INFO高级别或者相等的才会输出, 其他等级的日志就不会输出. 如果为: `log4j.rootLogger=ERROR, stdout, logfile`,  则表示INFO就不会输出了. 后面的stdout和logfile表示输出的地方, 这个输出的地方可以有多个, stdout表示标准输出, logfile表示文件输出, 这些名字其实都是自己配置的, 没有太大的关系.
		参考链接: 
			1.[spring配置日志](https://www.cnblogs.com/chen-lhx/p/6170298.html),    
			2.[Log4j教程](https://www.yiibai.com/log4j),    
			3.[springmvc+log4j操作日志记录,详细配置](https://www.cnblogs.com/v-weiwang/p/4814050.html),    
			4.[spring 中log4j日志的配置](https://blog.csdn.net/t2080305/article/details/80560188),    
			5.[Log4j rootLogger根配置以及4种日志级别](https://www.cnblogs.com/mengxinrenyu/p/7636400.html),   
			6.[Log4j的配置](https://blog.csdn.net/mgl934973491/article/details/55096870),   
			7.[log4j的使用--IDEA创建maven项目](https://blog.csdn.net/mgl934973491/article/details/55096966),   
			8.[log4j.rootLogger](https://blog.csdn.net/zhanghaipeng1989/article/details/44453473)

	2.log4j, logback,  log4j2
		1.[看完这个不会配置 logback , 请你吃瓜！](https://juejin.im/post/5b51f85c5188251af91a7525),  
		2.[LogBack入门实践](https://segmentfault.com/a/1190000004693427),   
		3.[Java日志框架: logback详解](https://www.cnblogs.com/xrq730/p/8628945.html),  
		4.[logback, log4j, log4j2三种日志框架性能检测——为什么用log4j2.](https://blog.csdn.net/qq_32250495/article/details/82382052),   
		5.[Spring Boot十Logback和Log4j2集成与日志发展史](https://blog.51cto.com/2188001/2310874),   
		6.[web项目中如何选择日志组件SLF4J, Log4J2, logback](https://cloud.tencent.com/developer/article/1383510),   
		7.[Log4j,Log4j2,logback,slf4j日志学习](https://www.cnblogs.com/williamjie/p/9197714.html),   
		8.[slf4j的简单用法以及与log4j的区别](https://www.cnblogs.com/qlqwjy/p/9275415.html),  
		9.[为什么使用 SLF4J 而不是 Log4J 来做 Java 日志 ](https://www.oschina.net/translate/why-use-sl4j-over-log4j-for-logging),   
		10.[SLF4J和log4j的使用](https://www.cnblogs.com/haoqipeng/p/5300376.html),   
		11.[log4j2单独的配置与使用&log4j2+slf4j的结合的配置与使用](https://www.cnblogs.com/ShawnYang/p/7488333.html),   
		12.[java的日志到底是怎么一回事](https://segmentfault.com/q/1010000004402813/a-1020000004403222),   
		13.[]log4j2单独的配置与使用&log4j2+slf4j的结合的配置与使用](https://blog.csdn.net/capmiachael/article/details/77096930)

	3.python2--->python3
		1.https://blog.csdn.net/shuihupo/article/details/79734462 ,
		2.https://blog.csdn.net/qq_36275540/article/details/80389941 ,
		3.https://docs.python.org/3.0/library/2to3.html ,
		4.https://blog.csdn.net/admans/article/details/79655733 ,
		5.https://www.cnblogs.com/hanggegege/p/5840005.html
	
	4.chrome清理浏览器缓存, ctrl+shift+del, 设置->更多工具--->清除浏览器缓存
	
	5.make和MakeFile
		在Linux环境下使用GNU的make工具能够比较容易的构建一个自己的工程, 整个工程的编译只需要一个命令就可以完成编译, 
		连接以至于最后的执行. makeFile就是我们自己编写的make编译工程所写的编译规则文件.
		1.https://www.cnblogs.com/qiaopei/p/5550168.html , 
		2.[Linux之make 、makefile的使用方法](https://www.cnblogs.com/qiaopei/p/5550168.html)