### 后端框架学习笔记

***

1 : 运行过程

WishList(Domain)-->WishListMapper(DAO)-->WishListService(Service)-->WishListController(Controller)
以上是从原型定义到mybatis的Mapper文件定义，再到提供服务，然后提供接口和结果的过程。

2 : @Param参数

在定义mybatis的mapper文件或者定义基于注解的sql语句时候，使用@Param注解，如下 : 
```java
@Select("SELECT id, user_id, item_id, add_price, add_time, created, updated FROM" +"user_collection_info WHERE user_id= #{userId} AND item_id= #{itemId, jdbcType=BIGINT}")
List<WishList> getWishListItemByItemId(@Param("userId") long userId, @Param("itemId") long itemId);
```
@Param后的字段和#{}之中的内容对应，select选择的是数据库之中的字段，后面的#{itemId}可以自由命名，只要在@Param之中对应起来就行. **如果只有一个参数, 那么可以省略@Param, 如果有多个参数, 那么必须标明@Param**. 

3 : IDEA的几个缩写

**psvm**=`补全main函数`
**fori**   =`for循环`
**sout**  =`System.out.println();`

4 : 接口，参数，请求等之间的关系

**接口的请求** : 接口分为一般接口和分布式接口（如Dubbo接口），一般的随便调用，Dubbo接口主要是为了在分布式环境下提供服务，可以在不同的机器之间调用(RPC)；**返回的数据格式** : 调用了接口之后，返回的数据一般是json格式的，但是其中的具体内容，还需要和前端商讨，返回的数据到底是什么格式；**参数的传递** : 在*Http的**Get**请求*下，所需要的数据可以通过URL上通过`http://localhost:8080/wishlist/getMarkList?userId=2&pageSize=10&pageStart=0 `  `?参数1=值1&参数2=值2&...`这种方式为参数赋值，我们可以通过url给controller中调用的方法的参数赋值，**此时controller方法参数的名字和url之中的参数的名字要相同，否则取不到值**。而对于*Http的**Post**请求*，我们是没法看到对应的页面的，传递参数的方式是一样的，需要借助工具实现，如postman来发送post请求。一个“悖论”是，我们需要的参数通过url传递，*但是应该也有其他方式传递*，比如我提交了注册按钮，然后，一般而言不会跳转到一个新的页面，应该是直接取到后台返回的结果，然后在本页刷新即可，也就是说，*url在取得参数数据之后*（**这种情况是Post请求的情况，而Get请求是相对应起来的**），这种情况是针对于Post请求的，可以把Post请求理解为在后端进行，不需要对应的页面即可。**字段的对应关系** : 还有在contorller, service, mapper, url和数据库之中字段的对应关系，mappr和数据库对应，url和controller对应，其他地方没有明确的要求，定义统一和方便自己查找即可，*对于时间的处理，一般不写在函数的参数请求之中，而直接在SQL中操作*。

5 : 微服务

不能我去查找别人的，我没有权限的数据库字段，不是我的模块，对我而言，我是看不到的，我需要的数据我无法直接获取的时候，我需要调用别人提供给我的接口，一般而言，我只需要在这些数据之中找到我要的部分，然后将其组装，就可以了。简言之 : **不是我的，我无法直接操作底层（数据库），只能通过调用别人的提供的接口，来获取我需要的内容**。

6 : 几个常见的术语

| 关键词  | 名称                              | 术语         |
| ------- | --------------------------------- | ------------ |
| api接口 | Service接口                       | service      |
|         | Model  接口                       | model        |
| 实现类  | Mapper 接口                       | dao          |
|         | Model POJO类                      | domain/model |
|         | Service/Serviceimpl Service实现类 | service      |
|         | Controller 调用类                 | controller   |

7 : 异常处理和日志

异常处理一般在service层处理，需要处理的时候处理，返回相应的result(一般是Json格式)，日志的话一般是使用logback，常量常数的话一般不是直接使用1,0这种表示，而是将其定义为常量，这样更有含义，明确。

8 : 数据来源

我自己管理的数据库表，只有一部分我需要的数据，但是其他的部分在别人的数据库表之中，我怎么拿到全部我想要的数据呢？一般的思路是这样的 : 在*分布式的系统和微服务的架构下*，~~我无法直接操作别人的数据库，无法直接通过操作别人数据库的方式来获得数据~~，所以**只能通过别人提供的服务接口来获得数据，然后通过和我自己的一部分数据，通过一定的条件查询，拼装组合出我想要的数据**。一般而言，在mybatis之中，需要定义好一个组装成的数据的Model，然后直接将数据填充到Model的对象之中去。

9 : IDEA调试快捷键

| 键                | 模式           | 作用                                 |
| ----------------- | -------------- | ------------------------------------ |
| **F7**            | Debug          | **进入断点方法之中**                 |
| **F8**            | Debug          | **不进入断点，越过断点直接给出结果** |
| **F9**            | Debug          | **恢复程序运行**                     |
| **Alt + F8**      | Debug          | **弹出可输入表达式的计算框**         |
| Ctrl + F8         | Debug / Common | 设置/清除断点                        |
| Shift + F7        | Debug          | 智能步入，会让你选择一个进入的方法   |
| Shift + F8        | Debug          | 跳出，恢复程序运行，=F9              |
| Ctrl + Shift + F8 | Debug          | 设置断点的进入条件                   |
| Alt + Shift + F7  | Debug          | 进入嵌套的方法之中                   |

10 : IDEA的Debug使用

① 如下图 Gif 所示，查看所选对象的方法常用有三种方式 : 
  - 选中对象后，使用快捷键 `Alt + F8`。

  - 选中对象后，拖动对象到 `Watches`。

  - 选中对象后，鼠标悬停在对象上 2 秒左右。

  - 想看对象的具体内容，选中之中，使用`Ctrl + F1`，查看对象具体内容。

  - **想要设置条件断点** : `Ctrl + Shift + F8`，在断点处按快捷键，跳出来如下图片![](../../../images/conditiondebug.png)

![img1](https://raw.githubusercontent.com/prayjourney/_mypictures/master/dev/bebug1.gif)

![img6](https://raw.githubusercontent.com/prayjourney/_mypictures/master/dev/debug6.gif)

② 如下图 Gif 所示，在弹出表达式输入框中 IntelliJ IDEA 也是能帮我们智能提示。
![img2](https://raw.githubusercontent.com/prayjourney/_mypictures/master/dev/bebug2.gif)

③ 如下图 Gif 所示，当我们需要过掉后面的所有断点的时候，我们不需要去掉这些断点，只需要点击左下角那个小圆点，点击小圆点之后，所有断点变成灰色，然后我们再在按快捷键 F9 即可过掉当前和后面所有的断点。
![img3](https://raw.githubusercontent.com/prayjourney/_mypictures/master/dev/bebug3.gif)

④ 如下图 Gif 所示，我们可以给断点设置进入的条件，因为变量 temp3 不等于 200 所以该断点没有被进入直接跳过。
![img4](https://raw.githubusercontent.com/prayjourney/_mypictures/master/dev/bebug4.gif)

⑤ 如 下图Gif 演示，有时候当我们步入方法体之后，还想回退到方法体外，断点进入 addNum 方法后，点击 Drop Frame 按钮之后，断点重新回到方法体之外。
![img5](https://raw.githubusercontent.com/prayjourney/_mypictures/master/dev/bebug5.gif)

11 : mybatis 到底要不要写一对多、一对一关联?

- 方法1
  - Dao 层有一对多、一对一关联
  - Service 层写业务逻辑

- 方法2
    - Dao 层不写一对多、一对一关联，只提供基本的增删查改
    - Service 层完成关联查询等以及写业务逻辑

方法1在效率上貌似有优势，但写 resultMap 和语句真是不开心
方法2对程序员比较友好，但效率不如方法一，而且 service 层会比较臃肿

12 : 日志的配置，以及其含义

1.[Log4j的配置](https://blog.csdn.net/mgl934973491/article/details/55096870),   2.[log4j的使用--IDEA创建maven项目](https://blog.csdn.net/mgl934973491/article/details/55096966)

13 : gitflow简单的操作

![gitflow简单的操作](https://raw.githubusercontent.com/prayjourney/_mypictures/master/blog/gitflow%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F.png)



14 : Spring MVC之中出现:No mapping found for HTTP request with URI

A:[关于No mapping found for HTTP request with URI...](http://www.cnblogs.com/of-course/p/6055311.html),   [DID NOT FIND HANDLER METHOD FOR SPRINGMVC资源文件扫描不到---关于SPRING的那些坑](http://www.cnblogs.com/ning-blogs/p/5244419.html)



15 : springmvc可以对前台返回json数据,也可以从**前台获取JSON格式的数据**, 当然,JSON格式只是最常用的一种格式,还有很多其他的格式,后台给前端返回json数据相对简单,而前台给后台发送JSON格式数据的时候,就需要注意,我们要使用AJAX来帮助(jquey的ajax)即可.此时,一定要搞清楚方向的问题,是**前端发送json数据到后台**,所以这个发送时从前端发给后台,就是从前端浏览器之中发起请求,在web服务器如tomcat运行的时候,后台会接收到这个请求,获得参数,然后才去相应的措施.
1.[springmvc 接收json对象的两种方式 ](https://blog.csdn.net/u012099869/article/details/50273507),  2.[Java运用JSON实现后台与前端分工合作（代码实例） ](https://blog.csdn.net/zhangliangzi/article/details/50197835), 3. [SpringMVC——对Ajax的处理（包含 JSON 类型）](http://www.cnblogs.com/solverpeng/p/5821726.html),  4.[SpringMVC @RequestBody 处理ajax请求](http://www.xuebuyuan.com/2040729.html), 5. [ajax请求，fastjson报出错误 : syntax error, expect {, actual error, pos 0](https://www.jianshu.com/p/1c40a32b5866),  6.[springmvc与fastjson的整合，注解@RequestBody的使用](http://www.cnblogs.com/boywwj/p/7441642.html)



16 : 表单form简介

**基本语法**

```html
<FORM ACTION="URL" METHOD="GET|POST" ENCTYPE="MIME" TARGET="...">
... ... 
</FORM> 
```

**基本功能**
**表单在网页中主要负责的是数据采集功能**，一个表单基本由三部分组成

- **表单标签** : 这里面包含了处理表单数据所用 CGI （Common Gateway Interface，通用网关接口）程序的 URL （Uniform Resource Location，统一资源定位符）以及数据提交到服务器的方法.
- **表单域** : 包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。
- **表单按钮** : 包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作.

**两个参数**

- method:  **post和get均可, 都可以作为提交数据的方法**, 但是一般post是推送消息给服务器, get是从服务器获取数据, 这是约定形成的, 当没有明确指定method的时候, **默认的method是get**.
- action: **action是提交给处理的url**, 意思是把表单提交到这个url处理, 没有action, action="" 或者action="?", 都是**将表单数据提交到本页的意思**.
  1.[HTML <form> 标签的 method 属性](http://www.w3school.com.cn/tags/att_form_method.asp),   2.[HTML 表单（form） 使用详解](https://blog.csdn.net/bobozhanghb/article/details/46285085),   3.[HTML里面form表单name,action,method,target,enctype等属性用法](http://www.cnblogs.com/yj716716yj/p/6189722.html),   4.[ HTML 表单 (form) 的作用解释 ](https://blog.csdn.net/ajianyingxiaoqinghan/article/details/77678772),   5.[SpringMVC表单标签简介](http://elim.iteye.com/blog/1807330)



17 : 前端和后端的感悟

A : form之中的action,对应的**不是**一个获取到的地址, 而是将数据传送, 然后让其处理问题的地址, 即**push**! form之中的表单信息提交给Spring MVC之中RequestMapping之中的url进行处理,是的! **但是,为什么此处没有获得那边传过来的数据呢???  **其实,意思就是,**应该是后端的数据绑定到了前端, 还是说前端的数据传递到了后端**?---> 我想,肯定是~~前端的数据,传到了后端,而传值得方式,是通过前端和后端都有,但是在后端定义的数据模型,id,来完成的~~. 就是说,在**后端定义了一个模型, key在后端定义好了, 但是value需要前端传过来, 给后端, 经过后端处理, 然后显示出来**.



18 : 关于form标签的path和commandName

A : form标签之中的path，commandName(modelAttribute)的来源，path就是我需要的一个值的对应的Domain(Model,POJO)类之中的相应的字段，commandName(modelAttribute)就是在Controller之中定义的Model(ModelMap, ModelAndView)对应的Model的key。此处需要理清楚数据绑定的对象，数据绑定的方向。



19 : Spring MVC前后端数据交互

A : 1.[Spring MVC前后端数据交互总结](http://www.cnblogs.com/chentingk/p/6073963.html),   2.[Spring MVC 后端获取前端提交的json格式字符串并直接转换成control方法对应的参数对象](http://www.cnblogs.com/dimmacro/p/4863420.html),   3.[Spring MVC 传值方式总结](http://blog.51cto.com/cnn237111/1894506),   4.[SpringMVC前端传值到Controller与Controller中传值到View解析](https://blog.csdn.net/mexican_jacky/article/details/50194667),   5.[Spring 向页面传值以及接受页面传过来的参数的方式](http://www.cnblogs.com/liuhongfeng/p/4802013.html)




20 : JSP页面使用a href来跳转到另一个jsp页面

A : Spring MVC貌似不支持从一个jsp页面通过\<a href="sss.jsp"\>的方式跳转，都要通过controller的方式访问页面



21 : 视图配置的时候，可以设置多个文件夹吗？可以配置多种视图后缀吗？

A : ViewResolver可以设置多个，不同的ViewResolver类型，需要设置不同的ViewResolver，比如jspViewResolver，htmlViewResolver等。至于某一种视图的多个文件夹，可以在/WEB-INF/views/之中设置，可以设置到不同级别的文件夹之中，但是这样不灵活，一般都是返回的时候，返回其父级别的文件夹名，比如之前的为/WEB-INF/views/，返回的时候使用的是return "login"，比如修改为/WEB-INF/views/user之后，那就需要使用user/login来返回，写全就是 : return "user/login"，如果要访问其他的，新的网页，则可以使用“user/XXX”，那么就是同一视图的多个文件夹的访问方式，而不同的ViewResolver，一般时将其页面放在不同的页面之下。1. [springmvc如何设置多视图器，springmvc 多个 ViewResolver ](https://blog.csdn.net/cai_chinasoft/article/details/51611596),  2.[SpringMVC同时支持多视图(JSP,Velocity,Freemarker等)的一种思路实现](https://blog.csdn.net/z69183787/article/details/40426603)



22 : Spring MVC之中form标签，jstl标签，sf标签，el表达式，各自使用在什么地方并且有什么区别？

A : **JSTL的全名为:Java Server Pages Standard Tag Library**。JSP标准标签库，由四个定制标记库（core、format、xml 和sql）和一对通用标记库验证器（ScriptFreeTLV 和 PermittedTaglibsTLV）组成。它实现了迭代和条件判断、数据管理格式化、XML操作以及数据库访问的功能。*有了jstl标签库和el表达式，我们的 jsp中不需要<%%>的java代码，提高了程序的可读性和可维护性*。

**EL（Expression Language）表达式 : 目的是为了使JSP写起来更加简单**。语法结构 : **${expression};** 对象 : pageScope、requestScope、sessionScope、applicationScope（访问顺序 : page—request—session——application）

**form标签是SpringMVC的核心标签**，如下的表达式中，tablib是我们给此标签库设置的名字，可以为任意不重复的名字，当然决定此标签库的还是URI，URI唯一决定此标签库，所以如下的标签库可以叫sf，也可以叫form

`<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>`

除了Spring标签，JSTL标签，还有Strutsde 标签等等。而EL表达式只是为了方便使用而存在的

**区别还没有写**



23 : Spring MVC的模板技术有哪些？

A : 模板技术有JSP, Velocity, freemarker和Thymeleaf模板，JSP开发对于MVC是破坏的，而后面三种是MVC模式的，不会在视图之中直接写java代码，而jsp会写java代码，然后编译成servlet，占用JVM的堆大小，会有GC的产生。Velocity, freemarker和Thymeleaf支持MVC开发模式，前后端分离，之间的差别不是非常大，**Spring官方推荐的是Thymeleaf模板**。[浅谈jsp、freemarker、velocity区别 ](https://blog.csdn.net/tjcyjd/article/details/16803877)



24 : Spring MVC后端传给前端值，怎么传，有哪些方法？

A : 



25 : Spring MVC前端传给后端值，怎么传，有哪些方法？

A : 



26 : spring的jsp类库有哪些？\<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>的含义和说明

A : taglib之中的prefix是一个必要的参数，这个是自己定义的，**可以是任何和已有的标签缩写不重复的标签前缀**，但是重点在于后面的URI，这是唯一定位一个标签库的方式。 **Spring的标签，有form部分和其他部分，这个form是为了数据绑定而设置的，Spring的标签，主要是使用form，其他的标签在tags下面，用的不是很多**。 



27 : spring的jsp类库有哪些？

A : Spring提供了两个JSP标签库**，用来帮助定义SpringMVC Web的视图。**其中一个标签库会用来渲染HTML表单标签，是from标签，这些标签可以绑定model中的某个属性**。另外一个标签库包含了一些**工具类标签，我们随时都可以非常便利地使用它们**。在这两个标签库汇中，表单绑定的标签库更加有用。我们更多使用的是表单标签，表单标签所在的位置为 : 
`<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%> `，而工具类标签为
`<%@taglib uri="http://www.springframework.org/tags" prefix="sf"%>`。1.[SpringMVC入门之七 : 使用JSP作为视图](https://blog.csdn.net/zhoucheng05_13/article/details/56669118),   2.[Spring MVC 页面渲染( render view )](https://blog.csdn.net/suifeng3051/article/details/51648360),   3.[SpringMVC入门之五 : 渲染Web视图概述](https://blog.csdn.net/zhoucheng05_13/article/details/56012033)**。



28 : spring form之中的标签，可以卸载spring:form之外吗？也就是说，能在form之外单独应用吗？

A : 是不能的，spring jsp的表单form标签之中的子元素，如`<form:input>`,`<form:checkouboxs>`等，都是需要在form标签之下才能起作用的，所以**spring jsp的表单form标签之中的子元素必须要包含在form打的标签之中，在标签之外就会报错**。



29 : Spring MVC的默认视图解析器是什么？

A : 当视图为jsp的时候，默认的视图解析器为**InternalResourceViewResolver**，默认的viewClass为**JstlView**，一般的配置为 : 
```jsp
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" >
    <property name="prefix" value="/WEB-INF/views/" />
    <property name="suffix" value=".jsp" />
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView />
</bean>
```



30 : 为什么通过mybatis执行sql语句，一开始可以成功，但是后续执行返回结果为0？

A : 这主要是因为数据太小，而查询的时候无法直接显示出来数据的原因，比如，删除的时候使用id和item_id，在一开始的时候都是1,2,3这种数据，但是购物车id主键和商品的id的增长是不同步的，所以就会产生数据不同步的原因，此时的表现是，sql语句可以执行，但是返回受影响的行数结果为0。这类问题大多是由于**粗心大意，把字段搞错了**！解决这些问题的方法如下 : 

- 查看sql日志
  - 调到debug状态![img](https://raw.githubusercontent.com/prayjourney/_mypictures/master/blog/%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E8%AE%BE%E7%BD%AE.png)
  - 查看参数![img](https://raw.githubusercontent.com/prayjourney/_mypictures/master/blog/sql%E7%9A%84%E6%97%A5%E5%BF%97.png)
- sql参数检查
  ![img](https://raw.githubusercontent.com/prayjourney/_mypictures/master/blog/sql%E7%9A%84%E6%97%A5%E5%BF%972.png)
- Rap2接口声明查看
- mybatis语法测试



31 : IDEA突然标红，怎么处理？

A : 一般是由于**缓存**导致的，表现为各个类都无法识别，但是仍然可以运行，此时只需要清理缓存即可。![img](https://raw.githubusercontent.com/prayjourney/_mypictures/master/blog/idea%E6%A0%87%E7%BA%A2.png)



32 : mybatis之中动态SQL的作用?
A : 当我们使用mybatis对一张表进行的CRUD操作，如果业务简单，那么SQL语句都比较简单，如果有比较复杂的业务，我们需要写复杂的SQL语句，往往需要拼接，而**拼接 SQL**，稍微不注意，由于引号，空格等缺失可能都会导致错误。
那么怎么去解决这个问题呢？就需要使用mybatis的动态SQL，通过if, choose, when, otherwise, trim, where, set, foreach等标签，可**组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率**。

但是另外需要注意, *如果简单的, 不需要对字段进行有无判断的,最好不要使用动态SQL, 虽然可以多种情况的匹配, 但是, 增加了运算成本, 不太好*.



33 : @Results,@Result的作用是什么？
A : @Results, 对应\<resultMap>表示的是结果映射的列表，包含了一个特别结果列如何被映射到属性或字段的详情。属性为value,@Result是@Results注解的结果数组之中的一条结果，@Results注解产生一个对应的结果数组。



34 : 嵌入在mybatis动态SQL语句之中的\<script>,\<CDATA>等标签的作用?
A : 用script标签包围，然后像xml语法一样书写,很明显，在java中写xml可读性和维护性太差，尤其当SQL很长时，这样写是很痛苦的。 \<script>,\<CDATA>这些标签是xml之中的标签，我们一般写sql的时候不用这么写，需要注意标点，连接符等即可。**写简单的SQL，结果拼接，而不是拼接SQL**。
```java
    @Select("<script>" +
            "SELECT id,sn,user_id,wechat_id,alipay_id,item_id,item_value,mobile," +
            "oilcard_num,oilcard_name,recharge_value,bean_award_value,payment_value,status," +
            "payment_time,order_time,created,updated " +
            " FROM oilcard_recharge_record "+
            "<where>" +
            "<if test=\"status !=null \"> and status = #{status}</if>" +
            "<if test=\"createdStart !=null \"> and created <![CDATA[ > ]]> #{createdStart}</if>" +
            "<if test=\"createdEnd !=null \"> and created <![CDATA[ < ]]> #{createdEnd}</if>" +
            "</where>" +
            "order by order_time desc " +
            "</script>")
    List<OilCardRechargeRecord> listByStatus(@Param("status") Integer status,
                                             @Param("createdStart") Long createdStart,
                                             @Param("createdEnd") Long createdEnd);
```
sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，\<CDATA>能避免被转义[mybatis 详解（五）------动态SQL](https://www.cnblogs.com/ysocean/p/7289529.html)，[XML CDATA](http://www.w3school.com.cn/xml/xml_cdata.asp)，"![CDATA[","\<script>"这些字符在动态sql的语句之中的作用是 : **防止sql里面出现诸如"<"、"&"这种XML非法字符的情况 **，[MyBatis动态SQL实现ORDER BY和LIMIT的控制？](https://segmentfault.com/q/1010000008631382)。

**注意** : 

有时候，只使用单纯的sql语句，在使用动态语句的时候，就会出现无法正确解析SQL的情况，比如说，使用\<if>语句的时候，在`"<if test=\"topic.status != null\" >status = #{topic.status},</if>"`这种情况的时候就会出现问题，所以最外层需要使用`<script>`包起来。另外`status = #{topic.status}`这句，**不能将#和{}分开**，比如status = # {topic.status}，这种就会出现错误。当if的条件只有一句的时候，后面不能加**","**。比如有

```sql lite
	// 只有一个参数的时候，不能加逗号","---><if test=\"status !=null\"> status = #{status},</if>
	@Select("<script>"
	        + "SELECT "
            + "id, topic_name, topic_introduce "
            + "FROM  article_topic"
            + "<where>"
			+ "<if test=\"status !=null\"> status = #{status}</if>"
            + "</where>"
            + "</script>")
	List<ArticleTopic> getTopicNumber(@Param("status") int status);
```

在插入语句之中，也可以使用动态条件，如下 : 

```sql lite
	// 需要添加<script>，否则无法正确解析<if...>的内容，在insert的时候也可以使用<if...>
	@Insert("<script>"
            + "INSERT INTO "
            + "article_topic (id, topic_name, topic_introduce, sort,"
			+ "<if test=\"topicImg !=null \"> topic_img,</if> "
			+ "<if test=\"topicThumbnail !=null \"> topic_thumbnail,</if> "
            + "status,  created,  updated)"
			+ "VALUES"
            + "(#{id}, #{topicName}, #{topicIntroduce}, #{sort}, "
			+ "<if test=\"topicImg !=null \"> #{topicImg},</if> "
			+ "<if test=\"topicThumbnail !=null \"> #{topicThumbnail},</if> "
            + "#{status}, #{created}, #{updated})"
			+ "</script>")
	@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
	long addTopic(ArticleTopic topic);
```

一般情况下，更新，插入的时候，需要使用到对象，在此时，我们的字段就需要带对象的名称，但是**在占位符之中，不需要设置对象名**，如下 : 

```sql
	@Update("<script>"
	        + "UPDATE article_topic"
			+ "<set>"
			+ "<if test=\"topic.status !=null\"> status = #{topic.status},</if>"
			+ "<if test=\"topic.updated !=null\"> updated = #{topic.updated},</if>"
			+ "</set>"
			+ "<where>"
			+ "id = #{id}"
			+ "</where>"
	        + "</script>")
	long stickyTopic(@Param("topic") ArticleTopic topic, @Param("id") long id);
```



35 : 注解，providersql，mapper.xml等方式的异同?
A : 注解，providersql，mapper.xml三种方式都是要产生对应的查询结果，**注解方式更加集中**，把DAO方法，SQL语句，集中在了一个Java接口之中，方便，但是每次有改动，必须要完整的改动这个接口文件。
providersql和mapper.xml方式比较相似，**providersql方式，将sql语句与DAO方法的接口文件分离**，使用反射，提供了sql语句的调用，DAO方法和SQL语句是分离的。
mapper.xml方式同样是分离的，但是**在mapper.xml之中，我们可以定义各种resultMap，可以重复利用**，利用效率比较高，但是写起来比较麻烦。



36 : 动态sql标签
A : **MyBatis的动态SQL是基于OGNL表达式的**，它可以帮助我们方便的在**SQL语句中实现某些逻辑**。MyBatis中用于实现动态SQL的元素主要有 : if, where, set, choose(when，otherwise), trim, foreach. 我们在一般是在**可能产生不确定条件的地方使用动态SQL的标签**，如在where, update的set之中使用动态标签。

if是一个基本的标签，
```xml
<if test="条件"> id=#{id} </if>
```
也可以if+where组合, 
```xml
<where>
    <if test="条件1"> id=#{id} </if> 
    <if test="条件2"> name=#{name}</if>
</where>
```
update的\<set> 标签,
```xml
<set>
    <if test="条件1">  id=#{id} </if> 
    <if test="条件2">  name=#{name}</if>
</set>
```
有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 \<choose> 标签可以解决此类问题，类似于Java的switch语句
```xml
<where> 
    <choose> 
        <when test="条件1">  id=#{id}  </when> 
        <when test="条件2">  name=#{name}  </when> 
        <otherwise> and age=#{sex}  </otherwise>
    </choose> 
</where>
```
trim标记是一个格式化的标记，可以完成set或者是where标记的功能，在sql其中，添加了一些如分隔符，前缀后缀等的信息。可以对应更多的情况，而foreach更多的是sql之中的in情况，例如id in(id的一个查询得到的结果集合)
```xml
<select id="selectUserByListId" parameterType="com.ys.vo.UserVo" resultType="com.ys.po.User">
    select * from user
    <where>
        <!--
            collection:指定输入对象中的集合属性
            item:每次遍历生成的对象
            open:开始遍历时的拼接字符串
            close:结束时拼接的字符串
            separator:遍历对象之间需要拼接的字符串
            select * from user where 1=1 and (id=1 or id=2 or id=3)
          -->
        <foreach collection="ids" item="id" open="and (" close=")" separator="or">
            id=#{id}
        </foreach>
    </where>
</select>
```



37 : Mybatis的Insert Update和Select Delete语句的注意点

A : 当我们使用SQL进行**insert和update**的时候，在Mybatis之中，使用的是对象，而非一个一个的单独的参数，在Mapper之中，**对应的参数为id和对应的对象**，而delete和select的时候大多数使用的是id或者其他合适的条件。[Mybatis纯注解方式](http://solverpeng.com/2016/06/14/Mybatis%E7%BA%AF%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/)
```xml
@Update("<script>"
        + "UPDATE "
        + "sp_red_pack_record "
        + "<set> "
        + "<if test = \" create_date !=null \"> create_date =#{createDate} ,</if>"
        + "<if test = \" modify_date !=null \"> modify_date =#{modifyDate} ,</if>"
        + "<if test = \" act_name !=null \"> act_name =#{actName} ,</if>"
        + "<if test = \" amount !=null \"> amount =#{amount} ,</if>"
        + "<if test = \" client_ip !=null \"> client_ip =#{clientIp} ,</if>"
        + "<if test = \" daily_hb_date !=null \"> daily_hb_date =#{dailyHbDate} ,</if>"
        + "<if test = \" remark !=null \"> remark =#{remark} ,</if>"
        + "<if test = \" scene_id !=null \"> scene_id =#{sceneId} ,</if>"
        + "<if test = \" send_name !=null \"> send_name =#{sendName} ,</if>"
        + "<if test = \" sn !=null \"> sn =#{sn} ,</if>"
        + "<if test = \" status !=null \"> status =#{status} ,</if>"
        + "<if test = \" wishing !=null \"> wishing =#{wishing} ,</if>"
        + "<if test = \" wx_result !=null \"> wx_result =#{wxResult} ,</if>"
        + "<if test = \" member !=null \"> member =#{member} ,</if>"
        + "<if test = \" wx_orderno !=null \"> wx_orderno =#{wxOrderno} ,</if>"
        + "<if test = \" yjf_orderno !=null \"> yjf_orderno =#{yjfOrderno} </if>"
        + "</set> "
        + "<where> "
        + "id =#{id} "
        + "</where> "
        + "</script>")
long updateRedPacketRecord(RedPacketRecord redPacketRecord, @Param("id") long id);


@Insert("<script>"
        + "INSERT INTO "
        + "article_topic (id, topic_name, topic_introduce, sort,"
        + "<if test=\"topicImg !=null \"> topic_img,</if> "
        + "<if test=\"topicThumbnail !=null \"> topic_thumbnail,</if> "
        + "status,  created,  updated)"
        + "VALUES"
        + "(#{id}, #{topicName}, #{topicIntroduce}, #{sort}, "
        + "<if test=\"topicImg !=null \"> #{topicImg},</if> "
        + "<if test=\"topicThumbnail !=null \"> #{topicThumbnail},</if> "
        + "#{status}, #{created}, #{updated})"
        + "</script>")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
long addTopic(ArticleTopic topic);
```

上面是Insert语句的情况，在addTopic方法之中，参数是**ArticleTopic**的对象**topic**，Update的情况和Insert相同，另外当我们使用SqlProvider的时候，**Insert和Update的参数都写在对应的Values和Set的String参数之中，参数和占位符相对应**。如下的示例，分别对应为Mapper文件和SqlProvider文件
```java
@InsertProvider(type = ArticleCommentReviewSqlProvider.class, method = "reviewComment")
long reviewComment(@Param("commentReview") ArticleCommentReview commentReview, @Param("id") long id);

@UpdateProvider(type = ArticleCommentReviewSqlProvider.class, method = "reviewCommentAgain")
long reviewCommentAgain(@Param("commentReview") ArticleCommentReview commentReview, @Param("id") long id);
```

```java
public String reviewComment(@Param("commentReview") ArticleCommentReview commentReview, @Param("id") long id) {
	//insert时，cloumn和对应的参数都写在sql.VALUES()之中，参数和占位符一一对应
    SQL sql = new SQL();
    sql.INSERT_INTO("article_comment_review");
    sql.VALUES(
			"comment_id, article_id, reviewer_id, review_detail, review_time,"
                    + " review_result, created, updated",
			"#{commentId}, #{articleId}, #{reviewerId}, #{reviewDetail}，#{reviewTime}, "
				   + "#{reviewResult}, #{created}, #{updated}");
	return sql.toString();
}

public String reviewCommentAgain(@Param("commentReview") ArticleCommentReview commentReview, @Param("id") long id) {
	//update时，column和对应的参数都写在sql.SET之中，参数和占位符一一对应
	SQL sql = new SQL();
	sql.UPDATE("article_comment_review");
	sql.SET("review_detail, review_result", "#{reviewDetail}, #{reviewResult}");
	sql.WHERE("id= #{id}");
	return sql.toString();
}
```
**以上这是在Mapper(DAO层)之中的定义，而在Service层和Controller层，我们还是需要整个完整的参数**。



38 : SQL分页的问题
A : SQL的分页，我们可以使用**limit**关键字或者**limit**&**offset**两个关键字组合来完成分页的实现，但是使用这两个关键字的时候是有区别的。示例如下 : 

:one: . 仅使用**limit**关键字，*limit N* : **只返回符合条件的前N条**

```sql
###### sql的数据计算是从0开始的，第1条的下标为0) #####
SELECT * FROM article_topic LIMIT 10; # 符合条件的前10条
SELECT * FROM article_topic WHERE id<100 LIMIT 10; # 符合条件的前10条,这句和上面一句的含义相同
```

:two: . 使用**limit**关键字，*limit  M , N* : **跳过M条，返回N条，从第M条开始读取**

```sql
SELECT * FROM article_topic LIMIT 2,1; # 跳过2条取出1条数据，LIMIT后面是从第2条开始读，读取1条信息，即读取第2条数据，也就是第三条
SELECT * FROM article_topic LIMIT 8,5; # 跳过8条，取出5条，从第8条开始读取
SELECT * FROM article_topic WHERE id<100 LIMIT 8,5;
```

:three: . 使用**limit**&**offset**关键字，*limit M offset N* : **跳过N条，返回M条，从第N条开始计算**

```sql
SELECT * FROM article_topic LIMIT 2 OFFSET 1; # 返回2条数据，从第1条开始计算，LIMIT后面跟的是2条数据，OFFSET后面是从第1条开始读取，即读取第2,3条
SELECT * FROM article_topic LIMIT 10 OFFSET 5; # 返回10条数据，从第5条开始计算
```
其中第:two:种和第:three:种之间的关系是相反的，最好统一使用第三种: *limit M offset N*, 返回M条（跳过N条），从第N条开始计算。[ sql 中 limit 与 limit，offset连用的区别 ](https://blog.csdn.net/AinUser/article/details/72803175),   [SQL 语句的LIMIT的用法](https://www.cnblogs.com/wangxingliu/p/3512188.html)



39 : sql语句定义和查询时候的一些问题

A : :one: . 所有的字段最好不要设置成NULL，可以设置为NOT NULL,为其设置一个默认值，通过`DEFAULT xxx`
      :two: . 将字段定义为BIGINT,INT等数字的时候，如果其大于0，那么可以加一个UNSIGNED来修饰，这样就不会有小于0的情况，**表示无符号，只有我们认为的大于0的情况存在，没有负数的存在了**
      :three: . 给字段和表添加注释是一个好习惯`COMMENT '创建时间',`
      :four: . 在创建数据库的语句之前，最好加上`DROP TABLE IF EXISTS xxx表;`
      :five: . **在创建SQL的语句之中，所使用的引号都是单引号---''，而不是双引号**
      :six: . 为了区别SQL语句和我们创建或者查询的字段，可以把**SQL保留字，全部大写，自定义的表明，数据等小写**
一个创建表的例子
```sql
# article_info
DROP TABLE IF EXISTS article_info;
CREATE TABLE article_info (
  id  BIGINT(20) UNSIGNED NOT NULL  AUTO_INCREMENT  COMMENT '主键',
  topic_id  BIGINT(20) UNSIGNED NOT NULL  COMMENT '专题id',
  user_id  BIGINT(20) UNSIGNED NOT NULL  COMMENT '编辑人id',
  title  VARCHAR(64)  NOT NULL  COMMENT '标题',
  introduce_detail VARCHAR(64)  NOT NULL  DEFAULT ''  COMMENT '推荐词',
  author  VARCHAR(64)  NOT NULL  COMMENT '作者',
  content  TEXT  NOT NULL  COMMENT '文章内容',
  main_img  VARCHAR(300)  NOT NULL  DEFAULT '' COMMENT '主图 url',
  thumbnail_img  VARCHAR(300)  NOT NULL  DEFAULT '' COMMENT '缩略图url',
  status  TINYINT(4)  NOT NULL  DEFAULT 0 COMMENT '状态（待审核，通过，不通过，发表，下架）',
  release_time  BIGINT(11)  UNSIGNED NOT NULL  DEFAULT 0 COMMENT '发表时间',
  off_time   BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0  COMMENT '下架时间',
  sort  int UNSIGNED NOT NULL  DEFAULT 0 COMMENT '排序',
  created  BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0  COMMENT '创建时间',
  updated  BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0  COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX idx_article_info_topic_id  (topic_id),
  INDEX idx_article_info_user_id  (user_id)
)DEFAULT CHARSET = utf8  COMMENT = '文章表';


# article_collect
DROP TABLE IF EXISTS article_collect;
CREATE TABLE article_collect (
  id  BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT  COMMENT ' 主键',
  user_id  BIGINT(20) UNSIGNED NOT NULL  COMMENT '用户id',
  article_id BIGINT(20) UNSIGNED NOT NULL  COMMENT '文章id',
  created  BIGINT(20) UNSIGNED NOT NULL DEFAULT 0  COMMENT '创建时间',
  updated  BIGINT(20) UNSIGNED NOT NULL DEFAULT 0  COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX idx_article_collect_user_id(user_id),
  INDEX idx_article_collect_article_id(article_id),
  UNIQUE idx_union_unique(user_id,article_id)
)DEFAULT CHARSET = utf8  COMMENT = '文章收藏表';


# article_thumb
DROP TABLE IF EXISTS article_thumb;
CREATE TABLE article_thumb(
  id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  user_id BIGINT(20) UNSIGNED NOT NULL COMMENT '用户id',
  article_id BIGINT(20) UNSIGNED NOT NULL COMMENT '文章id',
  created BIGINT(11) UNSIGNED DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX  idx_article_thumb_user_id(user_id),
  INDEX  idx_article_thumb_article_id(article_id)
) DEFAULT CHARSET =utf8 COMMENT = '文章点赞表';


# article_area
DROP TABLE  IF EXISTS article_area;
CREATE TABLE article_area (
  id BIGINT(20) UNSIGNED NOT NULL  AUTO_INCREMENT COMMENT '主键',
  area_id BIGINT(20)  UNSIGNED NOT NULL  COMMENT '地区id',
  article_id BIGINT(20) UNSIGNED NOT NULL  COMMENT '文章id',
  created BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX  idx_article_area_article_id(article_id),
  INDEX  idx_article_area_area_id(area_id)
)DEFAULT CHARSET =utf8 COMMENT ='文章地区表';


# article_review
DROP TABLE IF EXISTS article_review;
CREATE TABLE article_review(
  id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  article_id BIGINT(20) UNSIGNED  NOT NULL COMMENT '文章id',
  reviewer_id BIGINT(20) UNSIGNED NOT NULL COMMENT '审核人id',
  review_detail VARCHAR(200) NOT NULL  DEFAULT '' COMMENT '审核说明',
  review_time BIGINT(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '审核时间',
  review_result TINYINT(4) UNSIGNED NOT NULL  COMMENT '审核结果',
  created BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX  idx_article_area_article_id(article_id)
)DEFAULT  CHARSET =utf8 COMMENT ='文章审核表';


# article_topic
DROP  TABLE IF EXISTS article_topic;
CREATE  TABLE  article_topic(
  id BIGINT(20) UNSIGNED NOT NULL  AUTO_INCREMENT COMMENT '主键',
  topic_name VARCHAR(50) NOT NULL  COMMENT '专题名',
  topic_introduce VARCHAR(200) NOT NULL  DEFAULT '' COMMENT '专题简介',
  sort int UNSIGNED NOT NULL DEFAULT 0  COMMENT '专题排序',
  topic_img VARCHAR(300) NOT NULL  DEFAULT '' COMMENT '专题主图片',
  topic_thumbnail VARCHAR(300) NOT NULL  DEFAULT '' COMMENT '专题缩略图',
  status TINYINT(4) NOT NULL COMMENT '专题状态',
  created BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id)
)DEFAULT  CHARSET =utf8 COMMENT ='文章主题表';


# article_comment
DROP TABLE  IF EXISTS article_comment;
CREATE TABLE article_comment(
  id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  article_id BIGINT(20) UNSIGNED NOT NULL  COMMENT '文章id',
  user_id BIGINT(20) UNSIGNED NOT NULL  COMMENT '用户id',
  comment_content VARCHAR(140) NOT NULL COMMENT '评论内容',
  sort int NOT NULL DEFAULT 0  COMMENT '排序',
  status TINYINT(4) NOT NULL COMMENT '状态（提交，审核通过，不通过',
  created BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX  idx_article_comment_article_id(article_id),
  INDEX  idx_article_comment_user_id(user_id)
)DEFAULT  CHARSET =utf8 COMMENT ='文章评论表';


# article_comment_thumb
DROP TABLE IF EXISTS article_comment_thumb;
CREATE  TABLE article_comment_thumb(
  id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  comment_id BIGINT(20)  UNSIGNED NOT NULL COMMENT '评论id',
  user_id BIGINT(20) UNSIGNED NOT NULL COMMENT '用户id',
  created BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX idx_article_comment_thumb_user_id(user_id),
  INDEX idx_article_comment_thumb_comment_id(comment_id)
)DEFAULT  CHARSET =utf8 COMMENT ='文章评论点赞表';


# article_comment_review
DROP TABLE IF EXISTS article_comment_review;
CREATE TABLE article_comment_review(
  id BIGINT(20) UNSIGNED NOT NULL  AUTO_INCREMENT COMMENT '主键',
  comment_id BIGINT(20) UNSIGNED NOT NULL  COMMENT '评论id',
  article_id BIGINT(20) UNSIGNED NOT NULL  COMMENT '文章id',
  reviewer_id BIGINT(20) UNSIGNED NOT NULL COMMENT  '审核人id',
  review_detail VARCHAR(200) NOT NULL  DEFAULT ''  COMMENT '审核说明',
  review_time BIGINT(11) NOT NULL  DEFAULT 0 COMMENT '审核时间',
  review_result TINYINT(4) NOT NULL COMMENT '审核结果',
  created BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '创建时间',
  updated BIGINT(11) UNSIGNED NOT NULL  DEFAULT 0 COMMENT '更新时间',
  PRIMARY KEY (id),
  INDEX idx_article_comment_review_reviewer_id(reviewer_id)
)DEFAULT  CHARSET =utf8 COMMENT ='文章评论审核表';
```



39 : MySQL字段的疑惑

A : mysql之中的**bigint长度为8个字节**，**int为4个字节**，tinyint为1个字节，不同类型的int决定了存储的占用的字节数量，而经常使用的tinyint(M) : M默认为4，SMALLINT(M) : M默认为6，MEDIUMINT(M) : M默认为9，INT(M) : M默认为11，BIGINT(M) : M默认为20。**M表示最大显示宽度，建表若设置了zerofill(0填充)，会在数字前面补充0 **。

他山之石 : 
> *不是我们有这种限制，所有的建表都要加上这个限制 这个含义和入参检查是一样的，不是可以保存多大的值就保存多大的值，要从逻辑入手，性别就1位，身份证就17位，手机号就11位*。



40 : MVC模式在何处进行数据校验

A : 一般java web的项目分为domain, dao, service, controller等层，数据的校验和参数传递集中在controller和service两个地方，具有较大的可选性，有两种方式，:one:一种是在service之中获取基本数据，取得需要的基本数据，在controller层之中进行数据合法性的校验，然后在此处，将所有的数据统一处理，打包成需要的格式，传送给前端；:two:第二种是在service层之中将所有的数据都验证，整合，将其传送给controller层，controller只是做一个url转发的层。这两种方式在实际上都是可以的，但是由于第:two:种方式要讲数据多传送一次，而在service层之中整个合法性校验，数据的整合，然后又传送给controller层，这样操作比较浪费，所以第:one:种方式好，**service层提供基本的数据，在controller层之中校验，组装数据，转发请求等**。



41 : Java EE需要掌握的技术

- [ ] Spring(core/ mvc/boot)
- [ ] mybatis(hibernate)
- [ ] nosql(redis/mongodb)
- [ ] RabbitMQ
- [ ] RPC(Dubbo)
- [ ] Zookeeper
- [ ] 配置工具(maven/Apollo)
- [ ] linux(命令行操作)



42 : intellij idea 运行 tomcat，无法进入断点的问题解决方法

A : 这是因为JMX port被占用而出现的问题，解决方法，:one: : 重启机器，:two: : 使用`netstat -aon|findstr 1099 `找出来1099端口占用的进程，然后通过`taskkill -f -pid 3756 `杀掉进程，重新运行，即可。其实和无法启动tomcat服务器的原因是一样的。[启动tomcat时jmx port被占用](https://www.cnblogs.com/LeoBoy/p/5798947.html)，[intellij idea 运行 tomcat，无法进入断点的问题解决方法](https://blog.csdn.net/qq_24082175/article/details/78541767)
![img](../../../images/tomcatnotrun.png)



43 : RPC与RMI的介绍

A : RPC(Remote Procedure Call Protocol)远程过程调用协议，通过网络从远程计算机上请求调用某种服务。RMI是远程方法调用(Remote Method Invocation)。能够让在客户端**Java**虚拟机上的对象像调用本地对象一样调用服务端java 虚拟机中的对象上的方法。  **RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用**。**每个远程方法都具有方法签名**。如果一个方法在服务器上执行，但是**没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用**。 **RPC中是通过网络服务协议向远程主机发送请求**，请求包含了一个参数集和一个文本值，通常形成“classname.methodname(参数集)”的形式。RPC远程主机就去搜索与之相匹配的类和方法，找到后就执行方法并把结果编码，通过网络协议发回。  **RMI只用于Java；RPC是网络服务协议，与操作系统和语言无关**。



44 : Spring配置多个数据源，如何使用？

A : Spring配置多个数据源的时候，**启用需要使用包扫描，意思就是在特定的包下面使用某一个特定的数据源，在这个包下的操作，就是用这些对应的数据源**，如果新的包建立在默认的包之下，会出现覆盖的情况。注意 : **需要单独把相关的dao创建一个包，放在原先的dao下面会被覆盖，从而导致无法取到数据源的连接**。另外，需要在工程的配置文件之中添加上多个数据源的连接基本信息，方可操作。

```java
@Configuration
@ConfigurationProperties(prefix = "redpacket.datasource")
@MapperScan(basePackages = "com.yjf.redpacketdao", sqlSessionFactoryRef = "redpacketSession")
@EnableTransactionManagement
public class RedPacketDataConfiguration {

	//单独把相关的dao创建一个包，放在原先的dao下面会被覆盖，原先的包为com.yjf.dao
	private static final String DATA_SOURCE = "redpacket_ds";

	@Value("${redpacket.datasource.mapUnderscoreToCamelCase}")
	private Boolean mapUnderscoreToCamelCase;

	@Bean("redpacketSession")
	public SqlSessionFactory getSqlSessionFactory(@Qualifier(DATA_SOURCE) DataSource ds) throws Exception {
		SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
		bean.setDataSource(ds);
		org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
		configuration.setMapUnderscoreToCamelCase(mapUnderscoreToCamelCase);
		bean.setConfiguration(configuration);
		return bean.getObject();
	}

	@Bean(name = DATA_SOURCE)
	@ConfigurationProperties(prefix = "redpacket.datasource")
	public DataSource dataSourceRedpacket() {
		return DruidDataSourceBuilder.create().build();
	}

	@Bean
	public DataSourceTransactionManager redPacketTransactionManager(@Qualifier(DATA_SOURCE) DataSource ds) {
		return new DataSourceTransactionManager(ds);
	}
}
```



45 : 把sql的嵌套查询拆开，应该怎么做？

A : 在开发之中，SQL层(Mapper层的查询)，可能经常会遇到多个sql嵌套查询的情况，这样的时候，很容易出现Mapper层的耦合，处理这些耦合，就需要**把复杂嵌套的sql语句拆分成单独的简单的sql，然后在service层之中处理等否，关联等关系**，这样可以有效减少SQL语句的耦合，让复杂的SQL变得清晰简单。



46 : 写Mybatis的Mapper文件时候，sql的注意问题？

A : 有时候，写Mapper文件的时候，有时候会有把sql语句都写在一起，在写\<script>包裹起来的语句，在每一行的sql语句后面，**最好后面留一个空格，防止SQL语句拼接连在一起，出现问题**。

```sql
	@Select("<script>"
            + "SELECT "
		   + "id, create_date, ali_user_id, balance, identity_number, is_enabled, is_locked, mobile, name, "
			+ "phone, wx_open_id, member_rank, sinopec_station, real_name, area, "
            + "FROM  member "
			+ "WHERE is_enabled = 1 and is_locked = 0 "
            + "</script>")
	List<Member> getMemberList();

	@Select("<script>"
            + "SELECT "
			+ "id, create_date, ali_user_id, balance, identity_number, is_enabled, is_locked, mobile, name, "
			+ "phone, wx_open_id, member_rank, sinopec_station, real_name, area, "
            + "FROM  member "
            + "WHERE id= #{id}"
			+ "</script>")
	Member getUserById(@Param("id") Long id);
```



47 : **需要的数据是从多个表之中获取，该如何处理**？

A : 首先我们通过查询语句，将需要的信息，提取出来，此时我们得到了多种信息，然后接下来，我们可以**创建一个新的domain**，里面的字段刚好是所需信息的全部字段，然后使用Mapper查询出来我们要的信息后，在Service层将信息组合，整合出来我们想要的信息，比如，Student表和Book表，student(id, name, age, gender, grade, class, school)，book(id, book_name, book_price, book_author, book_detail, book_time, book_type)。如果我们想知道学生喜欢的书籍的类型和出版时间，那么可以新建新的domain，**student_book(id, name, age, gender,  book_name, book_detail, book_time, book_type)**，将其组合成一个新的domain, 这样处理将会方便很多。



48 : 调试时候如何查看MyBatis中数据连接的信息？

A : 在调试的时候，进入service，**调用mapper的时候，查看变量，然后进入sqlSession->exceptionTranslator**，之中就会看到Mybatis连接的数据库信息，配合多数据源查看，口味更佳。*但是如果想要查看sql语句，貌似只能通过打印日志的方法了*。

![img](../../../images/mybatis-debug.png)



49 : 类型检查在数字类型，String类型和空之间如何处理？

A : int, float等基本类型的参数，必须要求有一个参数，给方法传入，数字和String之间的转化，就是用他们之间的api。对于int, float等基本类型的参数，我们**确信**，此时传入的数据是不为空的，而且我们最好是用基本类型的，这样就可以避免NULL空指针异常，当是用基本类型的时候，会有一个默认的值来填充参数，我们的参数检查，就不必检查null这种问题了。如果是真的没有参数传入，需要统一使用拦截器，来处理这种情况。**就是说，能确定类型的时候，我们最好是用基本类型**，不去考虑空指针异常，而且**确信，参数是必有的**。如果我们必须要兼容或者有空的情况，那么就可以使用包装类型。



50 : 我们如何确定哪些接口需要设置成Dubbo类型的接口，或者说，什么情况下设置成为Dubbo类型的？

A : 首先，Dubbo类型的接口是为了给别人调用。当我们的系统可以拆分为很多小的系统或者模块的时候，我们可能将其发布在不同的服务器上，此时我们就需要将某些要**提供给别人调用的接口**设计成为Dubbo类型的接口，一般情况下，这些接口都是比较活跃的，很容易被人调用或者对外提供服务。



51 : 如何确定，在何时使用Redis？

A : **常用而不太常变动的内容**，我们可以将其保存到Redis数据库中，当做缓存，这样可以缓解服务器查询的压力。



52 : 为何给前端返回的数据，最好不要使用Map结构拼装？

A : Map拼装的Key和Value，众多信息是平行的，没有对象和属性的层级关系，不明确不优雅，容易遗忘丢失一些字段和数据，所以我们最好使用对象，借助Spring的封装，自动转化成Json字符串就可以了。



53 : **一些写代码的小小小经验，了解一下**

A : 回答如下

:one: . if语句使用的时候，使用`!=`，可以**减少一层嵌套**

```java
++BAD!!!++
if(a==5){
    wxResult=100;
    try{
        //dosomthing...
    }catch(Exception e){
        log.e("exception is {}",e);
    }
}else{
    System.out.println("hello world！")；
}

++GOOD++
if(a!=5){
    System.out.println("hello world！")；
}
wxResult=100;
try{
    //dosomthing...
}catch(Exception e){
    log.e("exception is {}",e);
}
```

:two: . 尽量使用简介的，考虑全面的API，`org.springframework.util.CollectionUtils`, `org.apache.commons.commons-lang3`, `org.apache.commons.commons-collections4`，`java.lang.util`都是需要考虑的对象。

:three: . 稍微可以复用的内容，都要提取出来，形成一个方法，这样在有问题修改的时候，方便修改，可以只改一处，多处适用，解决问题的效率较高。

:four: . 开发的时候, 每个新的分支, 都是从develop分支拉取出来的, 所以我们的分支, 一般是和4个分支有关系, 比如分支A, 和它有关系的就是 origin/develop(从此处pull), develop(本地develop, 分支的合并, 然后push到origin/develop), origin/A(远程仓库上面的A), A(本地的A分支). 只有上述4个分支在我们开发一个功能时候的交互之中, 其他的分支, 不管我们的功能有多相似, 都是不能混淆的, 不然会引起开发的混乱, 仓库代码的污染, 也就是说: **两个没有直接关联的分支, 不能相互合并 ! **比如, A分支借鉴了B分支的代码, 可以先把B分支上我们需要的代码拷贝出来, 然后再粘贴到A分支上去, 但是不能直接把B分支合并到A分支上去. 



54 : throw thorws和自定义的异常

A : **throw是抛出一个异常对象, throws后面是异常类**. 详细如下: 
:one: . 写法上 : throw 在方法体内使用，throws 函数名后或者参数列表后方法体前 
:two: . 意义 : throw 强调动作，而throws 表示一种倾向、可能但不一定实际发生 
:three: . throws 后面跟的是异常类，可以一个，可以多个，多个用逗号隔开。**throw 后跟的是异常对象，或者异常对象的引用**. 
:four: . throws 用户抛出异常，当在当前方法中抛出异常后，当前方法执行结束(**throws 后，如果有finally语句的话，会执行到finally语句后再结束**). 可以理解成return一样.

如下是新建自定义异常类的例子
```java
public class CustomException extends Exception {
    public CustomException(){
        super();
    }

    public CustomException(String message){
        super(message);
    }
}
```



55 : java的date和sql中的datetime的转换与SQL存储日期无时间的问题解决

A : domain定义成`java.util.Date`类型的，在处理的时候，将其格式化成`DateTime`类型

```java
public class MyEntity {
    ...
    @Temporal(TemporalType.TIMESTAMP)
    private java.util.Date myDate;
    ...
}
```

```java
java.util.Date dt = new java.util.Date();

java.text.SimpleDateFormat sdf = 
     new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

String currentTime = sdf.format(dt);
```

上面是String类型的时间日期字符串和Date类型的日期相转换,还有如下的格式化

```java
SimpleDateFormat timeStr = new SimpleDateFormat("yyyyMMddHHmmss");
SimpleDateFormat fmtDate = new SimpleDateFormat("yyyyMMdd");
SimpleDateFormat fmtDateTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
```

可以把日期转化成字符串. 但是当我们把日期时间存储到数据库之中的时候, 出现的结果是只有日期,没有时间,不管是使用`java.util.Date`或`java.sql.Date`, 都没有时间只有日期, 这是因为为了合乎国际标准把时间去掉了,需要注意的是**`java.util.Date`是`java.sql.Date`和后续提到的`java.sql.Timestamp`包装父类**, 显示如下:

![img1](../../../images/datestamp1.png)

如何解决上述的问题, 就需要使用`java.sql.Timestamp`, 使用如下的代码即可转换成可以存储在sql中的时间戳, 然后在存储的代码处,将`java.util.Date`转化成`java.sql.Timestamp`, 就可以达到如下的显示效果.

```java
Timestamp sqlDateAndTimeStamp = new Timestamp(new java.util.Date().getTime());//sql时间戳
```

![img2](../../../images/datestamp2.png)



56 : IDEA之中, 不同的代码版本使用不同的配置文件, 如何切换?

A : 如图, 在运行配置处配置,就可以选择不同的环境和配置文件了. 1. [spring boot 入门 spring.profiles.active来分区配置](http://www.leftso.com/blog/111.html) ,   2.[spring.profiles.active配置多种spring启动环境](https://blog.csdn.net/figo0423/article/details/54925993),   3.[通过 spring 容器内建的 profile 功能实现开发环境、测试环境、生产环境配置自动切换](https://blog.csdn.net/xvshu/article/details/51133786),   4.[Spring Boot Profile使用](https://blog.csdn.net/he90227/article/details/52981747)![code-env](../../../images/code-env.png)



57 : 如何查看服务器端的日志

A  : 查看日志. 日志有两种, 一种是访问的日志, 一种是业务日志, 访问日志是记录在nginx产生的日志之中, 而业务日志产生在tomcat的日志之中.

##### nginx日志

首先进入nginx日志目录, 然后使用`tail -f xxx.log|grep 关键字` 就可以循环监控访问的字段, 如下是实际的日志, 下图是日志所在的目录, 首先进入日志的目录, 然后使用`tail`访问日志![](F:/CodeBank/MyGit/SummaryOfProgramming/images/Nginx%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95.png)

实时监控过滤某关键字,并且查看日志, 此处的关键字为`delMarks`![](F:/CodeBank/MyGit/SummaryOfProgramming/images/%E6%9F%A5%E7%9C%8BNginx%E7%9A%84%E6%97%A5%E5%BF%97.png)



##### tomcat日志

tomcat日志是我们需要主要查看的日志, 而nginx大多数用来负载平衡, 用来查看访问的记录. 和nginx日志一样, 查看之前我们需要进入日志所在的目录, 然后通过`tail`命令来查看日志. 下图是进入Tomcat日志的目录![](F:/CodeBank/MyGit/SummaryOfProgramming/images/Tomcat%E6%97%A5%E5%BF%97.png)

以下两图是查看生产环境的日志, 生产环境和测试环境其实就是访问地址, 配置环境, 数据库等不同, 其他的差别不大,查看日志的方式和上述的查看nginx日志的方式类似, 以下分别是**连接不同的环境**和**查看各自环境下的日志**![](F:\CodeBank\MyGit\SummaryOfProgramming\images\生产环境Tomcat日志目录.png)

![](F:\CodeBank\MyGit\SummaryOfProgramming\images\线上查看Tomcat日志.png)

其中的命令和之前使用的差不多, 关键问题是找准**日志的位置**所在, 这样才能比较快的找到日志, 定位和分析问题.



58 : 常用的日志命令

A  : 查看日志的命令如下

> linux查看日志的命令有多种: tail、cat、tac、head、echo等命令

1.查看日志方式

```powershell
命令格式: tail [必要参数] [选择参数] [文件]
```

**tail**(最常用的一种查看方式 )

```powershell
-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c<数目> 显示的字节数
-n<行数> 显示行数
-q, --quiet, --silent 从不输出给出文件名的首部 
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒

tail  -n  10   test.log   查询日志尾部最后10行的日志;
tail  -n +10   test.log   查询10行之后的所有日志;
tail  -fn 10   test.log   循环实时查看最后1000行记录(最常用的)

//一般还会配合着grep用, 例如 :  tail -fn 1000 test.log | grep '关键字'
//如果一次性查询的数据量太大,可以进行翻页查看,
例如:tail -n 4700  aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)
```

**head**

```powershell
head -n  10  test.log   //查询日志文件中的头10行日志;
head -n -10  test.log   //查询日志文件除了最后10行的其他所有日志;
```

head其他参数与tail 类似

**cat** 
cat 是由第一行到最后一行连续显示在屏幕上

```powershell
一次显示整个文件 : $ cat filename
从键盘创建一个文件 : $ cat > filename  
将几个文件合并为一个文件： $cat file1 file2 > file //只能创建新文件,不能编辑已有文件.
将一个日志文件的内容追加到另外一个 : $cat -n textfile1 > textfile2
清空一个日志文件 $cat : >textfile2
```

**注意: >意思是创建, >>是追加. 千万不要弄混了.** cat其他参数与tail 类似

**tac** 
tac 则是由最后一行到第一行反向在萤幕上显示出来

**sed**

这个命令可以查找日志文件特定的一段 , 也可以根据时间的一个范围查询

```powershell
//按照行号
sed -n '5,10p' filename //这样你就可以只查看文件的第5行到第10行。
//按照时间段
sed -n '/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p'  test.log1234
```

**less**

```powershell
less log.log 
shift + G 命令到文件尾部  然后输入 ？加上你要搜索的关键字例如 ？1213
shift+n  关键字之间进行切换12345
```



2.其他会应用到的命令

```powershell
history // 所有的历史记录
history | grep XXX  // 历史记录中包含某些指令的记录
history | more // 分页查看记录
history -c // 清空所有的历史记录
!! 重复执行上一个命令
查询出来记录后选中:　!323
```

> linux日志文件说明
> /var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 
> /var/log/secure 与安全相关的日志信息 
> /var/log/maillog 与邮件相关的日志信息 
> /var/log/cron 与定时任务相关的日志信息 
> /var/log/spooler 与UUCP和news设备相关的日志信息 
> /var/log/boot.log 守护进程启动和停止相关的日志消息 
> /var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件



59 : 如何发布项目到服务器

A  : 对于java web的项目, 项目的发布就意味着将项目从开发环境之中打包, 然后放到web容器之中, 如tomcat, 打包现在一般都是使用maven作为包管理工具, 并且将其打包, 我们可以使用单独的语句, 在pom.xml文件所在的目录下面自行打包, 使用如下的命令语句即可生成war包, 然后将其放入web容器即可.

```shell
mvn clean package -Dmaven.test.skip=true
```

下图是发布项目的例子, 问题也是在于找到项目war包存放的地址, 将其覆盖即可. 一般项目放在tomcat的webapps文件夹之下, 我们其实找到tomcat的目录就行了. 发布的时候, 如果修改的较多,可以直接替换war包. 如果修改较少的话, 可以在**在对应的class文件目录下修改对应的class文件,修改增量即可**, 这样做是因为全量替换可能比较慢, 所以只替换增量可以节约时间.

![](F:/CodeBank/MyGit/SummaryOfProgramming/images/%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0.png)

查看日志的时候, 使用的是如xshell, secure crt类似的**终端模拟软件**, 而发布包, 需要使用的是如secure FX, FlashFXP类似的FTP软件, 将其上传到服务器tomcat的webapps目录下, 就可以了.至于具体如何发布可以参考如下的链接.



60 : 数据库之中某张表有较多数据时查询操作的技巧

A : 当我们需要操作数据库, 尤其是查询的时候, 如果数据多的话, 一次性查询出来所有的结果, 会给服务器内存造成很大的压力, 所以我们可以**一次查出一部分, 然后多次查出来**, 如何操作呢? **一次查询在SQL语句之中提现, 而多次查询在程序之中提现**, 可以通过如下代码习得

```java
/**
 * 查询符合条件的加油工(使用balance>0的条件, 过滤人员, 每次取300条, 减轻内存压力)
 */
@Select("<script>"
			+ "SELECT "
			+ "id, create_date, ali_user_id, balance, identity_number, is_enabled, is_locked, mobile, name, "
			+ "phone, wx_open_id, member_rank, sinopec_station, real_name, area "
			+ "FROM  member "
			+ "WHERE is_enabled =#{isEnabled} and is_locked = #{isLocked} and balance >0 limit 300"
			+ "</script>")
List<OilMember> getMemberList(@Param("isEnabled") boolean isEnabled, @Param("isLocked") boolean isLocked);
```

以上是mybatis的mapper文件, 用来操作数据库, 每次只提供300条数据, 默认是只执行一次的, 通过多次查询得出所有的数据通过下面的代码体现, 关键在于**for (; ; ) **, 最后当没有数据了, 再跳出这个死循环即可, 表示完成了查询.

```java
for (; ; ) {
    List<OilMember> memberList = memberMapper.getMemberList(ISENABLED, ISLOCKED);
    if (CollectionUtils.isEmpty(memberList)) {
        log.info("没有需要处理的数据");
        break;
    }

    log.info("即将为符合条件的加油工发红包...");
    for (OilMember member : memberList) {
        nextId = member.getId();
        try {
            int result = sendOneRedPacketService.sendOneRedPacket(member, date);
            if (result == SendOneRedPacketService.SENDOK) {
                success.incrementAndGet();
            } else {
                fail.incrementAndGet();
            }
        } catch (Exception e) {
            log.error("用户:{}, id:{}, 在 {} 发红包失败!", member.getRealName(), member.getId(), dateSend, e);
            fail.incrementAndGet();
        }
    }

    if(memberList.size() < limits){
        log.info("处理完毕，最后一批处理数据记录数:{}", memberList.size());
        break;
    }
}
```



61 : @Value注解的使用方法

A : SpringMVC中有两个xml配置文件:

1. applicationContext.xml, 这个是Spring的主配置文件, 包括dao层service层的bean定义或扫描, 数据源, 事务等的配置信息.
2. xxx-servlet.xml, 这个是mvc的配置文件, 包括controller层的bean定义或扫描, 静态资源访问以及view配置properties配置文件中的信息定义在applicationContext.xml中, 那么在service层使用@Value注解即可访问到, 但在Controller层使用@Value注解却不能访问到.若要在Controller层也使用@Value访问properties配置的话，需要在xxx-servlet.xml中也定义properties配置文件。

为了简化读取properties文件中的配置值，spring支持@value注解的方式来获取，这种方式大大简化了项目配置，提高业务中的灵活性. 有如下2种配置方法: 

```java
@Value("#{configProperties['key']}")
1. 配置方法1：  
2. <bean id="configProperties"class="org.springframework.beans.factory.config.PropertiesFactoryBean">  
3.     <property name="locations">  
4.         <list>  
5.             <value>classpath:value.properties</value>  
6.         </list>  
7.     </property>  
8. </bean>  

@Value("${key}")
1.配置方法2： 
2.<util:properties id="configProperties" location="classpath:value.properties"></util:properties> 
```
注: 配置1和配置2等价, 这种方法需要util标签, 要引入util的xsd: http://www.springframework.org/schema/util, 
http://www.springframework.org/schema/util/spring-util-3.0.xsd

对应的2种使用方法如下:

@Value("#{configProperties['key']}")

value.properties
```xml
1. key=1 
```
ValueDemo.java
```java
1. @Component  
2. public class ValueDemo {  
3.     @Value("#{configProperties['key']}")  
4.     private String value;  
5.   
6.     public String getValue() {  
7.         return value;  
8.     }  
9. }  
```

@Value("${key}")使用

配置文件

在2.1.1的配置文件基础上增加:

```xml
<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">  
    <property name="properties" ref="configProperties"/>  
</bean>
```

直接指定配置文件, 完整的配置:

```xml
<bean id="appProperty"  
          class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
    <property name="locations">  
        <array>  
            <value>classpath:value.properties</value>  
        </array>  
    </property>  
</bean>  
```

ValueDemo.java
```java
1. @Component  
2. public class ValueDemo {  
3.     @Value("${key}")  
4.     private String value;  
5.  
6.     public String getValue() {  
7.         return value;  
8.     }  
9. }  
```


62 : Apollo配置的使用文档

A : [Apollo Quick Start](https://github.com/ctripcorp/apollo/wiki/Quick-Start),   [Apollo配置中心介绍](https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D),   [Apollo使用指南](https://github.com/ctripcorp/apollo/wiki/Apollo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97),   [Java客户端使用指南](https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97)



63 : jar包和war包的介绍与区别

A : 在学习maven的过程中接触到了jar包和war包。之前在写小项目的时候真的遇到过war包，当时为了找到jar包，把war包的后缀名改成了.rar的压缩文件，在里面提取出来jar包来用。其实jar包和war包都可以看成压缩文件，用解压软件都可以打开，jar包和war包所存在的原因是，为了项目的部署和发布，通常把项目打包，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件，就是我们说的jar包和war包。但是这个“压缩包”可以被编译器直接使用，把war包放在tomcat目录的webapp下，tomcat服务器在启动的时候可以直接使用这个war包。通常tomcat的做法是解压，编译里面的代码，所以当文件很多的时候，tomcat的启动会很慢。

说了这么多，还是没有讲jar包和war包的区别。**jar包是java打的包，war包可以理解为javaweb打的包，这样会比较好记。jar包中只是用java来写的项目打包来的，里面只有编译后的class和一些部署文件。而war包里面的东西就全了，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西**。

什么时候使用jar包或war包？当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包吧，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。





ref : 

1.[IDEA 图标介绍。 缓存和索引介绍、清理方法和Debug使用](http://www.cnblogs.com/wangmingshun/p/6416397.html),   2.[使用 mybatis 到底要不要写一对多、一对一关联](https://www.v2ex.com/t/231189),   3.[Log4j的配置](https://blog.csdn.net/mgl934973491/article/details/55096870),   4.[log4j的使用--IDEA创建maven项目](https://blog.csdn.net/mgl934973491/article/details/55096966),   5.[mybatis 详解（五）------动态SQL](https://www.cnblogs.com/ysocean/p/7289529.html),   6.[MyBatis——动态SQL讲解](https://blog.csdn.net/bear_wr/article/details/52397679),   7.[MyBatis注解Annotation介绍及Demo](http://blog.51cto.com/computerdragon/1399742),   8.[spring boot(8)-mybatis三种动态sql](https://blog.csdn.net/wangb_java/article/details/73657958),   9.[mybatis @Select注解中如何拼写动态sql](https://blog.csdn.net/qq_32786873/article/details/78297551),   10.[MySQL bigint(20)是什么意思？](https://blog.csdn.net/hongchangfirst/article/details/50707415),   11.[详解mysql int类型的长度值问题](https://www.cnblogs.com/echo-something/archive/2012/08/26/mysql_int.html),   12.[Java RMI与RPC的区别](https://www.cnblogs.com/ygj0930/p/6542811.html),   13.[Mybatis纯注解方式](http://solverpeng.com/2016/06/14/Mybatis%E7%BA%AF%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/),   14.[ sql 中 limit 与 limit，offset连用的区别 ](https://blog.csdn.net/AinUser/article/details/72803175),   15.[SQL 语句的LIMIT的用法](https://www.cnblogs.com/wangxingliu/p/3512188.html),   16.[Intellij IDEA 2017 debug断点调试技巧与总结详解篇](https://blog.csdn.net/qq_27093465/article/details/64124330),   17.[Idea的一些调试技巧](https://www.cnblogs.com/softidea/p/7245884.html),   18.[Java 如何抛出异常、自定义异常](https://blog.csdn.net/qq_18505715/article/details/73196421),  19.[Java 向数据库中输入 datetime类型数据](https://blog.csdn.net/jcq521045349/article/details/53574177),   20.[linux 查看日志的几种基本操作](https://blog.csdn.net/xinzhifu1/article/details/59109792),   21.[linux查看日志文件内容命令tail、cat、tac、head、echo](https://www.cnblogs.com/zdz8207/p/linux-log-tail-cat-tac.html),   22.[Java笔记---部署 JavaWeb 项目到云服务器](https://blog.csdn.net/gulu_gulu_jp/article/details/50994003),   23.[javaweb部署服务器 详细版](https://blog.csdn.net/sinat_33388558/article/details/53991954),   24.[在云服务器上部署项目（上）](https://blog.csdn.net/gfd54gd5f46/article/details/54331207),   25.[在云服务器上部署项目（下）](https://blog.csdn.net/gfd54gd5f46/article/details/54358384),   26.[web项目部署服务器上线](https://blog.csdn.net/sinat_33388558/article/details/53536600),   27.[java项目部署到远程服务器上](https://blog.csdn.net/u013215018/article/details/70160737),   28.[实现自动构建编译javaweb项目并发布到N台服务器](https://www.cnblogs.com/linkstar/p/6530451.html), 29.[SpringMVC通过注解@Value获取properties配置](https://blog.csdn.net/z100871519/article/details/51393612),   30.[Spring-@value用法详解](https://blog.csdn.net/u010832551/article/details/73826914),   31.[spring boot 入门 spring.profiles.active来分区配置](http://www.leftso.com/blog/111.html) ,   32.[spring.profiles.active配置多种spring启动环境](https://blog.csdn.net/figo0423/article/details/54925993),   33.[通过 spring 容器内建的 profile 功能实现开发环境、测试环境、生产环境配置自动切换](https://blog.csdn.net/xvshu/article/details/51133786),   34.[Spring Boot Profile使用](https://blog.csdn.net/he90227/article/details/52981747),   35.[Apollo Quick Start](https://github.com/ctripcorp/apollo/wiki/Quick-Start),   36.[Apollo配置中心介绍](https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D),   37.[Apollo使用指南](https://github.com/ctripcorp/apollo/wiki/Apollo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97),   38.[携程Apollo---Java客户端使用指南](https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97),   39.[jar包和war包的介绍与区别](https://blog.csdn.net/qq_38663729/article/details/78275209)