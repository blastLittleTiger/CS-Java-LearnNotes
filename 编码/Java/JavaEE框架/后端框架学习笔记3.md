### 后端框架学习笔记3

***

[TOC]



##### 78 : mysql中decimal,numeric,double,float的区别
A : 区别如下
###### 显著区别
decimal,numeric属于**标准数据**类型, 指定精度和刻度；decimal的存储大小不确定, numeric的存储大小默认8个字节. 
double,float属于**非标准**数据类型, 在DB中保存的是近似值, **Decimal则以字符串的形式保存数值**. 


###### 比较
浮点数有个坏处, 当你给定的数据是整数的时候, 那么它就以整数给你处理. 这样我们在存取货币值的时候自然遇到问题, 我的default值为：0.00而实际存储是0, 同样我存取货币为12.00, 实际存储是12. 丢失了精度,变成了一个近似值.
Float数值类型用于表示单精度浮点数值, 而Double数值类型用于表示双精度浮点数值, Float和Double都是浮点型, 而Decimal是定点型；MySQL 浮点型和定点型可以用类型名称后加（M, D）来表示, M表示该值的总共长度, D表示小数点后面的长度, M和D又称为精度和标度, 
如float(7,4)的 可显示为-999.9999, MySQL保存值时进行四舍五入, 如果插入999.00009, 则结果为999.0001. 
Float和Double在不指 定精度时, 默认会按照实际的精度来显示, 而Decimal在不指定精度时, 默认整数为10, 小数为0. 同时, 对数据求SUM()时会出现不同的结果, Float和Double求SUM都会出现很多小数点, 而Decimal求SUM得到的是精准数值. decimal 和 numeric 是同义, 都是用于精确存储数值 . 

###### 使用小结
Mysql存储小数的时候, 大多数和金额有关系. 可以直接转换成分,以其作为整数形式来统计,最好别用浮点数,如果要用就要注意精度问题.
Float和Double存在精度的问题, 所以首选还是要用 Decimal和Numeric, 就我个人而Numeric用的比较多



##### 79: mysql中int, bigint, smallint和tinyint的区别与长度的含义
A : **之间的差别在于可以表示的范围(存储空间), 不同表示范围肯定占用不同长度的存储空间**
**bigint** : 从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）. **存储大小为 8 个字节**.
**int** : 从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）. **存储大小为 4 个字节**. int 的 SQL-92 同义字为 integer. 
**smallint** : 从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据. **存储大小为 2 个字节**. 
**tinyint** : 从 0 到 255 的整型数据. **存储大小为 1 字节**. 
int(M) 在 integer 数据类型中, M 表示最大显示宽度. 在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系. 和数字位数也无关系 int(3), int(4), int(8) 在磁盘上都是占用 4 btyes 的存储空间. 在mysql建表中的length, 只是用于显示的位数.



##### 80 : mybatis中的CURD操作方式和命名方式
A : 主要集中在两点上面, 一个在insert, **insert的时候要构造一个对象, Update的时候不要构造对象**,使用常规的参数即可. 关于函数的命名方式, insert, updateById, selectById, selectByName, deleteById, deleteByMobile这种, **将操作和字段使用By连接起来**, 也就是采用**操作-By-字段**的方式命名, 然后首字母大写即可.
:one: : **insert**语句, insert语句最好使用对象的方式来插入, 而不是使用一个一个单独的参数去完成一条记录的插入
```java
//DAO层的Mapper接口之中insert的写法
@Insert("INSERT INTO recommend_mobile(user_id, customer_name, mobile, mobile_type, status,                + amount,  reward_time, created, updated)"
		+ " VALUES (#{userId}, #{customerName}, #{mobile} #{mobileType},#{status},#{amount}, "
         + " #{rewardTime}, #{created}, #{updated})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
long insert(RecommendMobile recommendMobile);//对象
```
```java
//Service层之中insert的写法
public long insert(long userId, String customerName, String mobile) {
	RecommendMobile mobileRecord = recommendMobileMapper.getByMobile(mobile);
	if (mobileRecord != null) {
		return HAVE_EXIST;
	}
	long time = TimeUtils.now();
	RecommendMobile recommendMobile = new RecommendMobile();/使用相关的参数,构造一个对象
	recommendMobile.setUserId(userId);
	recommendMobile.setCustomerName(customerName);
	recommendMobile.setMobile(mobile);
	recommendMobile.setMobileType(RecommendMobileTypeEnum.MOBILE_NO_STATUS.getCode());
	recommendMobile.setStatus(RecommendMobileRewardTypeEnum.NOT_REWARD.getCode());
	recommendMobile.setAmount(REWARD_AMOUNT);
	recommendMobile.setRewardTime(DEFAULT_REWARD_TIME);
	recommendMobile.setCreated(time);
	recommendMobile.setUpdated(time);
	recommendMobileMapper.insert(recommendMobile);
	long result = recommendMobile.getId();
	return result;
}
```
:two: : **delete**语句, delete语句是用来删除, 删除所依据的字段需要唯一, 命名采用deleteById, deleteByMobile即可, 在**Mapper层和Service层以及Controller层的调用方式是一致的**.
:three: : **update**语句, update语句用来更新一条记录, 命名方式采用updateById, updateByMobile即可, update使用的时候, 不必构造对象, 因为我们更新的时候, 大多数时候不会全字段更新,*如果构造对象的话, 就会导致有很多的字段是null值*, 所以我们**直接使用传入的基本参数即可, 而不必构造对象更新**.
```java
//DAO层的Mapper接口之中update的写法
@Update("UPDATE recommend_mobile_reward_rule SET amount = #{amount}, updated = #{updated} WHERE id = #{id}")
int updateById(@Param("amount") int amount, @Param("updated") long updated, @Param("id") int id);
```
```java
//Service层之中update的写法
public int updateById(int amount, int id) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);// 不使用mobileType
	if (tempRule == null) return NOT_EXIST;// 没有对应的奖励规则
	long time = TimeUtils.now();// 只能修改某种套餐的amount,不可修改套餐的种类
	int result = recommendMobileRewardRuleMapper.updateById(amount, time, id);/* rule的字段有的是null, 应该是字段设置呢还是对象设置? */
	return result;
}
```
:four: : **select**语句, select语句是我们使用最多的语句, 有大量的查询, 我们得到的数据, 通常需**要使用对象,或者对象的列表来承接**,如`Hello`, `List<Hello>`, 在Mapper层之中需要注意一下, 在service层和controller层之中的调用, 和在Mapper之中的返回值保持一致即可. 命名方面一般使用selectById, selectByMobile等即可.
```java
//DAO层的Mapper接口,查询一条,使用对象来承接
@Select("<script>"
       + " SELECT id, mobile_type, amount, created, updated  FROM recommend_mobile_reward_rule "
       + " <where>"
       + " <if test=\" id !=null \"> and id = #{id} </if>"
       + " <if test=\" mobileType !=null \"> and mobile_type = #{mobileType} </if>"
       + " </where>"
       + "</script>")
RecommendMobileRewardRule getByIdOrTypeId(@Param("id") Integer id, @Param("mobileType") Integer        mobileType);
```
```java
//DAO层的Mapper接口,查询多条,使用对象列表来承接
@Select("<script>"
        + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
        + " FROM recommend_mobile "
        + " <where>"
        + " <if test=\" userId !=null \"> and user_id = #{userId} </if>"
        + " <if test=\" status !=null \"> and status = #{status} </if>"
        + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
        + " ORDER BY id DESC LIMIT #{pageSize} "
        + " </where>"
        + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int           status,@Param("id") Long id, @Param("pageSize") int pageSize);
```



##### 81 : 项目的打包和发布
A : 说明, 之前有介绍到maven的一些操作, maven是一个构建工具, 比如同事写了一些代码ap,为我们开发提供支持, 此时我们就可以其源代码拉取下来,然后编译,发布安装到本地的maven仓库之中, 然后我们就可以使用其提供的功能了,此时需要用到的命令是
```shell
mvn clean install -Dmaven.test.skip=true
```
当我们完成了一个功能, 需要从本地环境发布到线上测试环境或者线上生产环境的时候, 我们需要将新的war包发布到tomcat的webapps之中, 此时我们需要用到的是**打包命令**, 如下

```shell
mvn clean package -Dmaven.test.skip=true
```

![](../../../images/fabu1.png)
上图是打包前, 经过打包之后, 在target就会生成我们需要的war包, targe也可能因为之前打包过而存在(无关紧要)
![](../../../images/fabu2.png)
然后我们再通过FTP软件, 将我们的包上传到tomcat的webapps下面就好了.其中的oil-shop文件夹可以和旧的war包一起删除, 这是等运行起来后自动生成的class文件,当我们上传了新的war包之后, 就会有新的oil-shop文件夹生成
![](../../../images/fabu3.png)

相关参考见`77 : 项目的编译, Maven编译jar包用来引用`



##### 82 : 项目的分支问题
A : 如果采用了git-flow的开发模式, master是稳定生产模式, develop是所有的开发基础, feture是特性分支, 我们所有的新的功能都在feture分支上, **当我们需要发布项目到测试环境的时候, 我们就需要将代码经过本地的环境测试没有问题了之后, 合并到develop分支, 然后打包develop分支的代码, 将其发布到tomcat;** 如果发布到正式环境, 那么久需要在确认develop分支的代码没有问题之后, 将其合并到master分支, 然后将master分支的代码打包发布到tomcat之中.



##### 83 : mybatis动态语句if的test问题
A : 如下
```java
//如下的第一个test, xxx,yyy应该是userId还是user_id?
@Select("<script>"
        + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
        + " FROM recommend_mobile "
        + " <where>"
        + " <if test=\" xxx !=null \"> and yyy = #{userId} </if>"
        + " <if test=\" status !=null \"> and status = #{status} </if>"
        + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
        + " ORDER BY id DESC LIMIT #{pageSize} "
        + " </where>"
        + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int           status,@Param("id") Long id, @Param("pageSize") int pageSize);
```

动态sql语句是为了可以灵活处理sql字段而有的一种解决方式. 我们可以从上面的注释看到问题, 其实下面已经给出了答案, 应该是userId, **因为我们所采取的的test测试, 都是针对domain类的, 所以也就是class之中的文件, 因此应该在test的条件中填写userId, 而在真正的sql语句之中, 应该是sql数据库之中的字段**. 因此, yyy处应该是user_id, 完整的语句如下

```java
" <if test=\" userId !=null \"> and user_id = #{userId} </if>"
```

上述的第3个测试语句之中的`and id <![CDATA[ < ]]> #{id}`的`<![CDATA[ < ]]> `是一个转义字符, 其中转义的是`<`小于号, 如果没有此`<![CDATA[  ]]>`, mybatis的mapper接口执行的时候就会导致参数无法正常对应绑定, 所以需要注意一下.



##### 84 : mybatis动态语句if参数调用的问题
A : 动态sql就是为了处理多种组合条件下的sql的一种方式, 比如,一个查询, 可能需要按照id, 可能需要按照typeId, 也可能有同时按照id和typeId查询的情况, 这时候如果三种情况都写, 就要三个语句, 那样很麻烦, 所以我们可以使用动态语句, test之中是测试条件, 由于测试的是参数的有无, 所以用是否为null, 如`id!=null`来判断, **由于基本类型, 如int, double等在初始化的时候jvm会给其一个默认的初始值, 所以永远不会为`null`, 所以如果有~~null需求~~的字段和测试的时候, 需要使用包装类型的定义, 如Long, Integer等**

```java
//DAO层的Mapper接口,动态查询,那么如何在servicec层和controller层调用呢?
@Select("<script>"
       + " SELECT id, mobile_type, amount, created, updated  FROM recommend_mobile_reward_rule "
       + " <where>"
       + " <if test=\" id !=null \"> and id = #{id} </if>"
       + " <if test=\" mobileType !=null \"> and mobile_type = #{mobileType} </if>"
       + " </where>"
       + "</script>")
RecommendMobileRewardRule getByIdOrTypeId(@Param("id") Integer id, @Param("mobileType") Integer mobileType);
```

```java
//service层调用动态语句
public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
	    RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.
            getByIdOrTypeId(id, mobileType);
		return rule;
}
```

由此可以看出, service层的调用其实没有什么特殊的作为, 就是按照其方法调用, 那么controller层呢?

```java
//controller层调用动态语句
@RequestMapping(value = "/getByIdOrTypeId", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByIdOrTypeId(Integer id, Integer mobileType) {
	// 参数检查
	if (id == null && mobileType == null) {
		return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
            message(ResultCode.PARAMS_ERROR.msg()).build();
		}
	RecommendMobileRewardRule rewardRule = ruleService.getByIdOrTypeId(id, mobileType);
	if (rewardRule == null) {
		log.info("电话卡类型的奖励规则已经存在! id:{}, mobileType:{}", id, mobileType);
        return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).result(ruleService.NOT_EXIST).build();
		}
        return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(rewardRule).build();
	}
```

由controller可以看出也是一样的, 其决定于如何传入的参数, 如果传入id为null那么久按照mobileType查询, 反之同理, **这是正常调用走mapper-->service-->controller的路径, 所有的调用参数都按照正常的方式调用, 采用什么参数, 由前端传入的参数自动决定**, 但是, 但是, 但是,有一种情况, 就是**可能这个使用动态语句的service方法只是为其他的方法提供支持的, 那么我们就需要在service层让别人调用, 由此可得, 当只是进行某些特殊的操作时候, 我们可以将不需要的字段设置为null 或者是test测试条件失效的条件即可**, 其实同url前端传入的方式是同理的, 只不过一个是手动, 一个是自动的, 例子如下

```java
//service层的特定调用
//插入使用mobileType, 不需要id
public int insert(int mobileType, int amount) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);//insert使用mobileType, 不需要id, 所以设置id=null
	if (tempRule != null) {
		return HAVE_EXIST;// mobileType已经存在
	}
	RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
	long time = TimeUtils.now();
	rule.setMobileType(mobileType);
	rule.setAmount(amount);
	rule.setCreated(time);
	rule.setUpdated(time);
	recommendMobileRewardRuleMapper.insert(rule);
	int result = rule.getId();
	return result;
}

// 删除使用使用id, 不需要mobileType
public int deleteById(int id) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);//delete使用id, 不需要mobileType,所以设置mobileType=null
	if (tempRule == null) return NOT_EXIST;
	int result = recommendMobileRewardRuleMapper.deleteById(id);
	return result;
}

//查询一条奖励规则使用id或者mobileType
public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
	RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.getByIdOrTypeId(id, mobileType);
	return rule;
}
```

其实说白了, **动态sql的调用,就是把需要的参数设置为正常的, 把不需要的参数设置为null**.



##### 84 : mybatis的mapper语句的@param注解使用
A : 当只有一个参数的时候可以省略@Param注解, 也可以写上,都是可以的,但是而如果有多个的参数的时候, 不能省略, 必须全部都写上,否则就会报错
```java
//无
Insert("INSERT INTO recommend_mobile_reward_rule (mobile_type, amount, created, updated )"
			+ " VALUES(#{mobileType}, #{amount}, #{created}, #{updated})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
int insert(RecommendMobileRewardRule recommendMobileRewardRule);

//有
@Delete("DELETE FROM recommend_mobile_reward_rule WHERE id = #{id}")
int deleteById(@Param("id") int id);

//有
@Update("UPDATE recommend_mobile_reward_rule SET amount = #{amount}, updated = #{updated} WHERE id = #{id}")
int updateById(@Param("amount") int amount, @Param("updated") long updated, @Param("id") int id);
```



##### 85 : 再谈mybatis的分页
A : 分页很重要, 我们都知道, 分页一般都是在select的操作之中, 分页有真分页和假分页两种, 真分页使用sql语句, 假分页采用前端控制, 真分页也有一次性取出来和多次取出来的区别
SQL的分页，我们可以使用**limit**关键字或者**limit**&**offset**两个关键字组合来完成分页的实现，但是使用这两个关键字的时候是有区别的。示例如下 : 

:one: . 仅使用**limit**关键字，*limit N* : **只返回符合条件的前N条**

```sql
###### sql的数据计算是从0开始的，第1条的下标为0) #####
SELECT * FROM article_topic LIMIT 10; # 符合条件的前10条
SELECT * FROM article_topic WHERE id<100 LIMIT 10; # 符合条件的前10条,这句和上面一句的含义相同
```

:two: . 使用**limit**关键字，*limit  M , N* : **跳过M条，返回N条，从第M条开始读取**

```sql
SELECT * FROM article_topic LIMIT 2,1; # 跳过2条取出1条数据，LIMIT后面是从第2条开始读，读取1条信息，即读取第2条数据，也就是第三条
SELECT * FROM article_topic LIMIT 8,5; # 跳过8条，取出5条，从第8条开始读取
SELECT * FROM article_topic WHERE id<100 LIMIT 8,5;
```

:three: . 使用**limit**&**offset**关键字，*limit M offset N* : **跳过N条，返回M条，从第N条开始计算**

```sql
SELECT * FROM article_topic LIMIT 2 OFFSET 1; # 返回2条数据，从第1条开始计算，LIMIT后面跟的是2条数据，OFFSET后面是从第1条开始读取，即读取第2,3条
SELECT * FROM article_topic LIMIT 10 OFFSET 5; # 返回10条数据，从第5条开始计算
```
其中第:two:种和第:three:种之间的关系是相反的，最好统一使用第三种: *limit M offset N*, 返回M条（跳过N条），从第N条开始计算。[ sql 中 limit 与 limit，offset连用的区别 ](https://blog.csdn.net/AinUser/article/details/72803175),   [SQL 语句的LIMIT的用法](https://www.cnblogs.com/wangxingliu/p/3512188.html)

这是sql之中的情况, 实际情况中, **我们分页都需要order排序, 根据id或者created**, 一般情况下, 我们总是需要让最近的情况显示在我们的查询结果之中, 没有太多人对于一年之前的订单感兴趣太大的兴趣, 所以通常使用`order by created desc`, *由于id通常也是增大的*, 所以也可以使用`order by id desc`, 但是这样通常都是取得的全部的查询数据, 然后再从其中查找, 对于机器的压力比较大, 如下:

```java
@Select("SElECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
			+ " FROM recommend_mobile "
			+ " WHERE user_id= #{userId} and status= #{status} ORDER BY id DESC LIMIT #{pageSize} OFFSET #{pageStart}")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int status,@Param("pageSize") int pageSize, @Param("pageStart") int pageStart);
```

所以我们需要按需索取, 通过id大小来控制, 如取id=10到20的10条, 那么就设置id<20, pageSize=10即可, 如下:

```java
@Select("SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
              + " FROM recommend_mobile "
              + " WHERE user_id= #{userId} and status= #{status} and id < #{id} ORDER BY id DESC LIMIT #{pageSize} ")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int status, @Param("id") long id, @Param("pageSize") int pageSize);
```

但是如上, **要求我们每次都要从前端获取id的大小值, 第一次前端无法获取id的大小, 所以必须允许其为空,** 因此, 我们需要设置动态sql语句来完成, 由于id可以为null, 所以其类型由基本类型设置为包装类型, `long-->Long`, 如下:

```java
@Select("<script>"
            + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
			+ " FROM recommend_mobile "
			+ " <where>"
            + " <if test=\" userId !=null \"> and user_id = #{userId} </if>"
            + " <if test=\" status !=null \"> and status = #{status} </if>"
            + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
            + " ORDER BY id DESC LIMIT #{pageSize} "
            + " </where>"
            + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int status, @Param("id") Long id, @Param("pageSize") int pageSize);//第一次id为空,也可以查询
```

这是mapper文件中的操作,  在service层正常调用即可, 如下:

```java
public List<RecommendMobile> getByUserIdAndStatus(long userId, int status, Long id, int pageSize) {
		return recommendMobileMapper.getByUserIdAndStatus(userId, status, id, pageSize);
}//只需要每页的大小pageSize, 不需要所有的都出现, 也就不需要使用offset
```

第二个关键在于controller层, 我们第一次不需要id值, 后面每次需要获取前一次的id, 作为`id < #{id}`的判断条件, 而且可以返回是否是分页的最后一次了, id通过`list.get(list.size()-1).getId()`l就可以得到, 然后就可以使用list的大小和pageSize来判断, 如果`list.size()< pageSize`那么就是最后的分页, 至于相等的情况, 可能需要多一次的获取和判断, 这个问题不大. 如下:

```java
@RequestMapping(value = "/getByUserStatus", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByUserIdAndStatus(int status, Long id, int pageSize) {
	long userId = SessionContextHolder.getUserId();
	if (userId < 0 || pageSize <= 0 || (id != null && id <= 0)) {
			log.warn("参数不符合要求! userId:{}, status:{}, id:{} ,pageSize:{}", userId, status, id, pageSize);
			return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
                message(ResultCode.PARAMS_ERROR.msg())
					.build();
	}
	List<RecommendMobile> mobileList = recommendMobileService.getByUserIdAndStatus(userId, status, id, pageSize);
		HashMap<String, Object> jsonMap = new HashMap<>();
		jsonMap.put("record", mobileList);
		jsonMap.put("lastId", mobileList.get(mobileList.size() - 1).getId());// 获取最后一个的Id
		boolean end = false;
		if (mobileList.size() < pageSize) {
		end = true;
		}
		jsonMap.put("end", end);// 是否还需要分页,使用当前页的数量和pageSize来分区
		JSONObject json = new JSONObject(jsonMap);
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(json).build();
	}
```

上面是不使用分页辅助类的的情况, 如下是使用辅助类的情况

```java
@RequestMapping(value = "/getByUserStatus", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByUserIdAndStatus(int status, Long id, int pageSize) {
	long userId = SessionContextHolder.getUserId();
	if (userId < 0 || pageSize <= 0 || (id != null && id <= 0)) {
			log.warn("参数不符合要求! userId:{}, status:{}, id:{} ,pageSize:{}", userId, status, id, pageSize);
			return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
                message(ResultCode.PARAMS_ERROR.msg())
					.build();
	}
	List<RecommendMobile> mobileList = recommendMobileService.getByUserIdAndStatus(userId, status, id, pageSize);
	Mbook<RecommendMobile> mobileMbook;
	if (lastId == 0) {
		mobileMbook = Mbook.result(null, "", true);
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(mobileMbook).build();
		}
	mobileMbook = Mbook.result(mobileList, String.valueOf(mobileList.get(lastId - 1).getId()), pageSize);
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(mobileMbook).build();
}
```

如下是`MBook`辅助类:

```java
//MBook.java
package com.yjf.domain;

import lombok.Data;
import lombok.ToString;
import org.apache.commons.collections4.CollectionUtils;

import java.util.Collections;
import java.util.List;

/**
 * Created by xushengchao 5/3.
 */
@Data
@ToString
public class Mbook<T> {
    /**
     * 记录列表
     */
    private List<T> records;
    /**
     * 分页截止ID（根据实际含义赋值，updated时间戳、价格等)
     */
    private String lastId;
    /**
     * 是否最后一页
     */
    private boolean isEnd = false;

    /**
     * 组装返回分页列表
     *
     * @param records
     * @param lastId
     * @param isEnd
     * @param <T>
     * @return
     */
    public static <T> Mbook<T> result(List<T> records, String lastId, boolean isEnd) {
        Mbook<T> mbook = new Mbook<>();
        mbook.setRecords(records);
        mbook.setLastId(lastId);
        mbook.setEnd(isEnd);
        return mbook;
    }

    /**
     * 根据返回列表参数和页码判断是否最后一个并组装参数
     *
     * @param records
     * @param lastId
     * @param pageSize
     * @param <T>
     * @return
     */
    public static <T> Mbook<T> result(List<T> records, String lastId, Integer pageSize) {
        Mbook<T> mbook = new Mbook<>();
        mbook.setRecords(records);
        mbook.setLastId(lastId);
        mbook.setEnd(CollectionUtils.isEmpty(records) || records.size() < pageSize);
        return mbook;
    }

    /**
     * 封装mbook基础信息到已有的mbook
     *
     * @param mbook
     * @param pageSize
     * @param <T>
     */
    public static <T> void handleResult(Mbook<T> mbook, List<T> records, String lastId, Integer pageSize) {
        if (mbook != null) {
            mbook.setRecords(records);
            mbook.setLastId(lastId);
            mbook.setEnd(CollectionUtils.isEmpty(records) || records.size() < pageSize);
        }
    }

    /**
     * 默认列表
     *
     * @param <T>
     * @return
     */
    public static <T> Mbook<T> getDefault() {
        Mbook<T> mbook = new Mbook<>();
        mbook.setEnd(true);
        mbook.setRecords(Collections.emptyList());
        return mbook;
    }
}
```



##### 86 : @Transactional的处理方法
A : service层处理, 事务调用事务, 在上一层之中处理异常, 异常必须要处理, 异常必须要处理, 异常必须要处理!!!
事务的处理在Spring之中需要套用调用, 即先写好一个在service之中的方法, 在这个方法之中对需要事务处理的方法进行标注, 然后当有一些可以判断或者无法判断的情况时候, 抛出异常, 抛出异常之后, 在调用此service的另一个service之中处理异常. 
如下:`RecommendMobileRewardRuleChangeService`调用`RecommendMobileRewardRuleTransactionalService`

```java
//RecommendMobileRewardRuleTransactionalService
@Service
public class RecommendMobileRewardRuleTransactionalService {
	public static final int HAVE_EXIST = -1;
	public static final int NOT_EXIST = 0;

	@Autowired
	private RecommendMobileRewardRuleMapper recommendMobileRewardRuleMapper;
	@Autowired
	private RecommendMobileRewardRuleHistoryService recommendMobileRewardRuleHistoryService;

	/*插入一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int insert(int mobileType, int amount) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);// 不使用id
		if (tempRule != null) {
			return HAVE_EXIST;// mobileType已经存在
		}
		RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
		long time = TimeUtils.now();
		rule.setMobileType(mobileType);
		rule.setAmount(amount);
		rule.setCreated(time);
		rule.setUpdated(time);
		recommendMobileRewardRuleMapper.insert(rule);

		// 记录操作历史
		Integer ruleId = rule.getId();
		throw new RuntimeException();
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_INSERT.getCode(), ruleId, mobileType, amount);
		/* 处理findbugs, 有待优化 */
		if (ruleId <= 0 || ruleId==null || hisId <= 0 || hisId==null) {
			throw new RuntimeException();
		}
		return ruleId;
	}

	/*删除一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int deleteById(int id) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);
		if (tempRule == null) {
			return NOT_EXIST;
		}
		Integer result = recommendMobileRewardRuleMapper.deleteById(id);
		throw new RuntimeException();
		// 记录操作历史
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_DELETE.getCode(), id, tempRule.getMobileType(),
				tempRule.getAmount());
		/* 处理findbugs, 有待优化 */
		if (result <= 0 || result==null || hisId <= 0 || hisId==null) {
			throw new RuntimeException();
		}
		return result;
	}

	/* 更新一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int updateById(int amount, int id) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);// 不使用mobileType
		if (tempRule == null) {
			return NOT_EXIST;// 没有对应的奖励规则
		}
		long time = TimeUtils.now();// 只能修改某种套餐的amount,不可修改套餐的种类
		Integer result = recommendMobileRewardRuleMapper.updateById(amount, time, id);
		throw new RuntimeException();
		// 记录操作历史
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_UPDATE.getCode(), id, tempRule.getMobileType(),
				tempRule.getAmount());
		/* 处理findbugs, 有待优化 */
		if (result <= 0 || result==null || hisId <= 0 || hisId==null) {
			throw new RuntimeException();
		}
		return result;
	}

	/*查询一条奖励规则使用id或者type*/
	public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
		RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.getByIdOrTypeId(id, mobileType);
		return rule;
	}
}
```

```java
//RecommendMobileRewardRuleChangeService调用RecommendMobileRewardRuleTransactionalService
@Service
@Slf4j
public class RecommendMobileRewardRuleChangeService {
	public static final int ERROR_NUMBER = -2;

	@Autowired
	RecommendMobileRewardRuleTransactionalService ruleTransactionalService;

	public int insert(int mobileType, int amount) {
		try {//处理异常
			int result = ruleTransactionalService.insert(mobileType, amount);
			return result;
		} catch (Exception e) {
			log.error("RecommendMobileRewardRuleTransactionalService：mobileType:{}, amount:{}", mobileType, amount, e);
			return ERROR_NUMBER;
		}
	}

	public int deleteById(int id) {
		try {//处理异常
			int result = ruleTransactionalService.deleteById(id);
			return result;
		} catch (Exception e) {
			log.error("RecommendMobileRewardRuleTransactionalService：id:{}", id, e);
			return ERROR_NUMBER;
		}
	}

	public int updateById(int amount, int id) {
		try {//处理异常
			int result = ruleTransactionalService.updateById(amount, id);
			return result;
		} catch (Exception e) {
			log.error("RecommendMobileRewardRuleTransactionalService：amount:{}, id:{}", amount, id, e);
			return ERROR_NUMBER;
		}
	}
}
```
在Controller之中, 最好对异常情况有明确的处理, 打日志, 输出相关参数等, 按照返回码给前端返回code, result等
```java
//RecommendMobileRewardRuleController
@RestController
@RequestMapping("recommendmobile")
@Slf4j
public class RecommendMobileRewardRuleController {
	@Autowired
	RecommendMobileRewardRuleTransactionalService ruleService;
	@Autowired
	RecommendMobileRewardRuleChangeService ruleChangeService;

	@RequestMapping(value = "/insertRule", method = RequestMethod.POST)
	@ResponseBody
	public YjfJsonResult insert(int mobileType, int amount) {
		// mobileType是unique的
		int result = ruleChangeService.insert(mobileType, amount);
		if (result == RecommendMobileRewardRuleTransactionalService.HAVE_EXIST) {
			log.info("电话卡类型的奖励规则已经存在! mobileType:{}", mobileType);
			return YjfJsonResult.builder().code(ResultCode.MOBILE_TYPE_EXIST.val())
					.message(ResultCode.MOBILE_TYPE_EXIST.msg()).result(result).build();
		}
		// 异常情况的处理
		if (result == RecommendMobileRewardRuleChangeService.ERROR_NUMBER) {
			return YjfJsonResult.builder().code(ResultCode.EXCEPTION.val()).
                message(ResultCode.EXCEPTION.msg()).build();
		}
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(result).build();
	}

	/* 删除一条奖励规则 */
	@RequestMapping(value = "/deleteRule", method = RequestMethod.GET)
	@ResponseBody
	public YjfJsonResult deleteById(int id) {
		int result = ruleChangeService.deleteById(id);
		if (result == RecommendMobileRewardRuleTransactionalService.NOT_EXIST) {
			log.info("电话卡类型的奖励规则不存在! id:{} ", id);
			return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
					.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).
                result(ruleService.NOT_EXIST).build();
		}
		// 异常情况的处理
		if (result == RecommendMobileRewardRuleChangeService.ERROR_NUMBER) {
			return YjfJsonResult.builder().code(ResultCode.EXCEPTION.val()).
                message(ResultCode.EXCEPTION.msg()).build();
		}
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(result)
				.build();
	}

	@RequestMapping(value = "/updateRule", method = RequestMethod.POST)
	@ResponseBody
	public YjfJsonResult updateById(int amount, int id) {
		int result = ruleChangeService.updateById(amount, id);
		if (result == RecommendMobileRewardRuleTransactionalService.NOT_EXIST) {
			log.info("电话卡类型的奖励规则不存在! amount:{}, id:{} ", amount, id);
			return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
					.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).
                result(ruleService.NOT_EXIST).build();
		}
		// 异常情况的处理
		if (result == RecommendMobileRewardRuleChangeService.ERROR_NUMBER) {
			return YjfJsonResult.builder().code(ResultCode.EXCEPTION.val()).
                message(ResultCode.EXCEPTION.msg()).build();
		}
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(result).build();
	}
}
```



##### 87 : @Transactional的测试方法
A : 实际上比较简单, 只需要在我们添加了@Transactional注解的方法中抛出一个异常, 即可.示例如下:
```java
//RecommendMobileRewardRuleTransactionalService
@Service
public class RecommendMobileRewardRuleTransactionalService {
	public static final int HAVE_EXIST = -1;
	public static final int NOT_EXIST = 0;

	@Autowired
	private RecommendMobileRewardRuleMapper recommendMobileRewardRuleMapper;

	@Autowired
	private RecommendMobileRewardRuleHistoryService recommendMobileRewardRuleHistoryService;

	/*插入一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int insert(int mobileType, int amount) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);// 不使用id
		if (tempRule != null) {
			return HAVE_EXIST;// mobileType已经存在
		}

		RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
		long time = TimeUtils.now();
		rule.setMobileType(mobileType);
		rule.setAmount(amount);
		rule.setCreated(time);
		rule.setUpdated(time);
		recommendMobileRewardRuleMapper.insert(rule);

		// 记录操作历史
		Integer ruleId = rule.getId();
		throw new RuntimeException();//抛出一个异常, 来打断事务
        //下面的代码已经跑不了了, 所以注释掉
//		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
//				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_INSERT.getCode(), ruleId, mobileType, amount);
//		// 判断 StringUtils.equals(String.valueOf(ruleId),"null");
//		if (ruleId <= 0 || StringUtils.equals(String.valueOf(ruleId), "null") || hisId <= 0
//				|| StringUtils.equals(String.valueOf(hisId), "null")) {
//			throw new RuntimeException();
//		}
//		return ruleId;
	}
}
```



##### 88: Java四种访问权限的范围与继承关系
代码继承和包结构如下
```shell
packageM
|
|- - - A
|- - - B
|- - - E
|- - - F extends E
|- - - packageN
|- - - |
|- - - |- - - C extends A
|- - - |- - - D
```
**访问控制情况**
|               | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| ------------- | -------- | -------- | ------------ | -------------- |
| public        | √        | √        | √            | √              |
| protected     | √        | √        | √            |                |
| 默认(default) | √        | √        |              |                |
| private       | √        |          |              |                |

> Tips：其中private和protected不能修饰一般的类，否则编译就会报“modifier private not allowed here”，如果是内部类就另当别论了）

**默认(friendly)权限**
1. 类A和类D**不在同一个包**之中, 类A无法访问类D的友好字段和方法, 类A**只能访问**类D的public字段和方法, 反之亦然.
2. 类A和类B在**同一个包**之中, 类A可以访问类B的友好字段和方法,  反之亦然.

继承的几个问题
1. 继承extends与类所在包的层级无关系, 即和包的位置无直接关系, 间接关系见第3条;
2. 继承的子类可以访问父类的public, protected类型的方法, 不可以访问默认(友好), private的方法,
   可以访问public, protected的字段, 不可以访问默认(友好), private的字段;
3. 继承和默认权限之间的重叠点在于**当父类和子类处于同一个包的时候**, *可以访问其友好字段或方法的, 不在同一个包的时候不可以访问友好的字段和方法*.

**默认(friendly)权限和继承的关键点**
简言之:
默认(友好)管到包的级别,只要是同一个包里面的,既可以访问到友好以上级别的方法和字段;
继承管到protected级别,只要是子类继承了父类,子类就可以访问父类protected级别以上的方法和字段.



##### 89: 处理findbugs的Integer的Null
A : 一般情况下, 我们使用`Integer a; if(a==null)`这种方式比较, 但是有时候会报错(见86@Transactional的处理方法的`RecommendMobileRewardRuleTransactionalService`之中的方法), 因为包装类型都可以允许null值的存在, 所以这是一个需要注意的点, 为了避免,可以使用`StringUtils.equals(String.valueOf(XXX),"null");`来比较, 如下:

```java
	/* 删除一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int deleteById(int id) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);
		if (tempRule == null) {
			return NOT_EXIST;
		}
		Integer result = recommendMobileRewardRuleMapper.deleteById(id);
		throw new RuntimeException();
		// 记录操作历史
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
			    RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_DELETE.getCode(), 
                 id, tempRule.getMobileType(), tempRule.getAmount());
		// 判断, 判断 StringUtils.equals(String.valueOf(result),"null");
		if (result <= 0 || StringUtils.equals(String.valueOf(result), "null") || hisId <= 0
				|| StringUtils.equals(String.valueOf(hisId), "null")) {
			throw new RuntimeException();
		}
		return result;
	}
```



##### 90 : FindBugs EI_EXPOSE_REP EI_EXPOSE_REP2
A : 提示信息：

EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP) 

Returning a reference to a mutable object value stored in one of the object’s fields exposes the internal representation of the object. If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations. 

EI：可以通过返回对可变对象的引用来公开内部表示 

返回对存储在对象的一个字段中的可变对象值的引用会公开对象的内部表示。如果不受信任的代码访问实例，并且对可变对象的未经检查的更改会危及安全性或其他重要属性。在许多情况下，返回对象的新副本是更好的方法。

原代码：

```java
    /**
     * 获取：创建时间
     */
    public Date getGmtCreate() {
        return gmtCreate;
    }
```

修改后代码：

```java
    /**
     * 获取：创建时间
     */
    public Date getGmtCreate() {
        if (this.gmtCreate != null) {
            return new Date(this.gmtCreate.getTime());
        } else {
            return null;
        }
    }
```

提示信息：

EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2) 

This code stores a reference to an externally mutable object into the internal representation of the object. If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations. 

EI2：可以通过引用可变对象来公开内部表示 

此代码将对外部可变对象的引用存储到对象的内部表示中。如果不受信任的代码访问实例，并且对可变对象的未经检查的更改会危及安全性或其他重要属性。在许多情况下，存储对象的副本是更好的方法。

原代码：

```java
    /**
     * 设置：创建时间
     */
    public void setGmtCreate(Date gmtCreate) {
        this.gmtCreate = gmtCreate;
    }
```

修改后代码：

```java
    /**
     * 设置：创建时间
     */
    public void setGmtCreate(Date gmtCreate) {
        if (gmtCreate != null) {
            this.gmtCreate = (Date) gmtCreate.clone();
        } else {
            this.gmtCreate = null;
        }
    }
```



##### 91 : Redis的数据类型
A : 如下

|      类型       | 作用                                                         |
| :-------------: | ------------------------------------------------------------ |
| 字符串(String)  | Redis值的最基础的类型. Redis字符串是二进制安全的, 这意味着一个Redis字符串可以包含任何种类的数据, 例如一个JPEG图像或者一个序列化的Ruby对象. 一个字符串值最多可以保存512M字节的内容. |
|  散列类(hash)   | hash类型与Java中的HashMap相似，是一组键值对的集合，且支持单独对其中一个键进行增删改查操作 |
|   列表(list)    | 一个列表可以包含一个或一个以上的数量的项（item, list是有序的, **每个项按照它们被推入到列表的位置来排列** |
|    集合(Set)    | Redis的集合**以无序的方式储存**多个各不相同的元素. 用户可以快速的地向集合添加元素, 或者从集合里面删除元素, 也可以对多个集合进行集合运算操作, 比如计算并集, 交集和差集. |
| 有序集合(zset)  | 和集合一样，都可以包含任意数量的、各不相同的元素(element), 不同于集合的是, 有序集合的每个元素都关联着一个浮点数格式的分值(score), 并且有序集合会按照分值, 以从小到大的顺序来排列有序集合中的各个元素. 虽然有序集合中的每个元素都必须是各不相同的, 但元素的分值并没有这一限制, 换句话来说, 两个不同元素的分值可以是相同的 |
| HyperLogLog类型 | Redis在2.8.9版本添加了 HyperLogLog结构. 基数: 集合中不同元素的数量. 比如 {'java',  'C#',  'ruby',  'C#',  'java'}的基数就是3, 估算值: 算法给出的基数并不是精确的, 可能会比实际稍微多一些或者稍微少一些, 但会控制在合理的范围之内 |
|   GEO地理位置   | Redis的GEO特性将在 Redis 3.2 版本推出, 这个功能可以将用户给定的地理位置信息储存起来,并对这些信息进行操作 |



ref:
51.[mysql中decimal,numeric,double,float的区别](https://blog.csdn.net/wufaliang003/article/details/78502402),   52.[mysql 数据类型 Float、Double、Decimal和Numeric 的区别](http://www.uuboku.com/455.html),   53.[mysql中int、bigint、smallint 和 tinyint的区别与长度的含义](https://blog.csdn.net/spring21st/article/details/7332200),  54.[Java中四种访问权限总结](https://blog.csdn.net/itachiyang/article/details/43647909),   55.[FindBugs EI_EXPOSE_REP EI_EXPOSE_REP2](https://blog.csdn.net/pythonerxxs/article/details/81026322),   55.[Redis教程(1~8)](https://blog.csdn.net/yuan_xw/article/details/52084090),   56.[Redis 数据结构与内存管理策略（上）](http://blog.51cto.com/wangqingpei557/2063316),   57.[Redis 数据结构与内存管理策略（下）](http://blog.51cto.com/wangqingpei557/2065712)