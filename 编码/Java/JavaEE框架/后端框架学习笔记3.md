### 后端框架学习笔记3

***

[TOC]



##### 78 : mysql中decimal,numeric,double,float的区别
A : 区别如下
###### 显著区别
decimal,numeric属于**标准数据**类型, 指定精度和刻度；decimal的存储大小不确定, numeric的存储大小默认8个字节. 
double,float属于**非标准**数据类型, 在DB中保存的是近似值, **Decimal则以字符串的形式保存数值**. 


###### 比较
浮点数有个坏处, 当你给定的数据是整数的时候, 那么它就以整数给你处理. 这样我们在存取货币值的时候自然遇到问题, 我的default值为：0.00而实际存储是0, 同样我存取货币为12.00, 实际存储是12. 丢失了精度,变成了一个近似值.
Float数值类型用于表示单精度浮点数值, 而Double数值类型用于表示双精度浮点数值, Float和Double都是浮点型, 而Decimal是定点型；MySQL 浮点型和定点型可以用类型名称后加（M, D）来表示, M表示该值的总共长度, D表示小数点后面的长度, M和D又称为精度和标度, 
如float(7,4)的 可显示为-999.9999, MySQL保存值时进行四舍五入, 如果插入999.00009, 则结果为999.0001. 
Float和Double在不指 定精度时, 默认会按照实际的精度来显示, 而Decimal在不指定精度时, 默认整数为10, 小数为0. 同时, 对数据求SUM()时会出现不同的结果, Float和Double求SUM都会出现很多小数点, 而Decimal求SUM得到的是精准数值. decimal 和 numeric 是同义, 都是用于精确存储数值 . 

###### 使用小结
Mysql存储小数的时候, 大多数和金额有关系. 可以直接转换成分,以其作为整数形式来统计,最好别用浮点数,如果要用就要注意精度问题.
Float和Double存在精度的问题, 所以首选还是要用 Decimal和Numeric, 就我个人而Numeric用的比较多



##### 79: mysql中int, bigint, smallint和tinyint的区别与长度的含义
A : **之间的差别在于可以表示的范围(存储空间), 不同表示范围肯定占用不同长度的存储空间**
**bigint** : 从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）. **存储大小为 8 个字节**.
**int** : 从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）. **存储大小为 4 个字节**. int 的 SQL-92 同义字为 integer. 
**smallint** : 从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据. **存储大小为 2 个字节**. 
**tinyint** : 从 0 到 255 的整型数据. **存储大小为 1 字节**. 
int(M) 在 integer 数据类型中, M 表示最大显示宽度. 在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系. 和数字位数也无关系 int(3), int(4), int(8) 在磁盘上都是占用 4 btyes 的存储空间. 在mysql建表中的length, 只是用于显示的位数.



##### 80 : mybatis中的CURD操作方式和命名方式
A : 主要集中在两点上面, 一个在insert, **insert的时候要构造一个对象, Update的时候不要构造对象**,使用常规的参数即可. 关于函数的命名方式, insert, updateById, selectById, selectByName, deleteById, deleteByMobile这种, **将操作和字段使用By连接起来**, 也就是采用**操作-By-字段**的方式命名, 然后首字母大写即可.
:one: : **insert**语句, insert语句最好使用对象的方式来插入, 而不是使用一个一个单独的参数去完成一条记录的插入
```java
//DAO层的Mapper接口之中insert的写法
@Insert("INSERT INTO recommend_mobile(user_id, customer_name, mobile, mobile_type, status,                + amount,  reward_time, created, updated)"
		+ " VALUES (#{userId}, #{customerName}, #{mobile} #{mobileType},#{status},#{amount}, "
         + " #{rewardTime}, #{created}, #{updated})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
long insert(RecommendMobile recommendMobile);//对象
```
```java
//Service层之中insert的写法
public long insert(long userId, String customerName, String mobile) {
	RecommendMobile mobileRecord = recommendMobileMapper.getByMobile(mobile);
	if (mobileRecord != null) {
		return HAVE_EXIST;
	}
	long time = TimeUtils.now();
	RecommendMobile recommendMobile = new RecommendMobile();/使用相关的参数,构造一个对象
	recommendMobile.setUserId(userId);
	recommendMobile.setCustomerName(customerName);
	recommendMobile.setMobile(mobile);
	recommendMobile.setMobileType(RecommendMobileTypeEnum.MOBILE_NO_STATUS.getCode());
	recommendMobile.setStatus(RecommendMobileRewardTypeEnum.NOT_REWARD.getCode());
	recommendMobile.setAmount(REWARD_AMOUNT);
	recommendMobile.setRewardTime(DEFAULT_REWARD_TIME);
	recommendMobile.setCreated(time);
	recommendMobile.setUpdated(time);
	recommendMobileMapper.insert(recommendMobile);
	long result = recommendMobile.getId();
	return result;
}
```
:two: : **delete**语句, delete语句是用来删除, 删除所依据的字段需要唯一, 命名采用deleteById, deleteByMobile即可, 在**Mapper层和Service层以及Controller层的调用方式是一致的**.
:three: : **update**语句, update语句用来更新一条记录, 命名方式采用updateById, updateByMobile即可, update使用的时候, 不必构造对象, 因为我们更新的时候, 大多数时候不会全字段更新,*如果构造对象的话, 就会导致有很多的字段是null值*, 所以我们**直接使用传入的基本参数即可, 而不必构造对象更新**.
```java
//DAO层的Mapper接口之中update的写法
@Update("UPDATE recommend_mobile_reward_rule SET amount = #{amount}, updated = #{updated} WHERE id = #{id}")
int updateById(@Param("amount") int amount, @Param("updated") long updated, @Param("id") int id);
```
```java
//Service层之中update的写法
public int updateById(int amount, int id) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);// 不使用mobileType
	if (tempRule == null) return NOT_EXIST;// 没有对应的奖励规则
	long time = TimeUtils.now();// 只能修改某种套餐的amount,不可修改套餐的种类
	int result = recommendMobileRewardRuleMapper.updateById(amount, time, id);/* rule的字段有的是null, 应该是字段设置呢还是对象设置? */
	return result;
}
```
:four: : **select**语句, select语句是我们使用最多的语句, 有大量的查询, 我们得到的数据, 通常需**要使用对象,或者对象的列表来承接**,如`Hello`, `List<Hello>`, 在Mapper层之中需要注意一下, 在service层和controller层之中的调用, 和在Mapper之中的返回值保持一致即可. 命名方面一般使用selectById, selectByMobile等即可.
```java
//DAO层的Mapper接口,查询一条,使用对象来承接
@Select("<script>"
       + " SELECT id, mobile_type, amount, created, updated  FROM recommend_mobile_reward_rule "
       + " <where>"
       + " <if test=\" id !=null \"> and id = #{id} </if>"
       + " <if test=\" mobileType !=null \"> and mobile_type = #{mobileType} </if>"
       + " </where>"
       + "</script>")
RecommendMobileRewardRule getByIdOrTypeId(@Param("id") Integer id, @Param("mobileType") Integer        mobileType);
```
```java
//DAO层的Mapper接口,查询多条,使用对象列表来承接
@Select("<script>"
        + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
        + " FROM recommend_mobile "
        + " <where>"
        + " <if test=\" userId !=null \"> and user_id = #{userId} </if>"
        + " <if test=\" status !=null \"> and status = #{status} </if>"
        + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
        + " ORDER BY id DESC LIMIT #{pageSize} "
        + " </where>"
        + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int           status,@Param("id") Long id, @Param("pageSize") int pageSize);
```



##### 81 : 项目的打包和发布
A : 说明, 之前有介绍到maven的一些操作, maven是一个构建工具, 比如同事写了一些代码ap,为我们开发提供支持, 此时我们就可以其源代码拉取下来,然后编译,发布安装到本地的maven仓库之中, 然后我们就可以使用其提供的功能了,此时需要用到的命令是
```shell
mvn clean install -Dmaven.test.skip=true
```
当我们完成了一个功能, 需要从本地环境发布到线上测试环境或者线上生产环境的时候, 我们需要将新的war包发布到tomcat的webapps之中, 此时我们需要用到的是**打包命令**, 如下

```shell
mvn clean package -Dmaven.test.skip=true
```

![](../../../images/fabu1.png)
上图是打包前, 经过打包之后, 在target就会生成我们需要的war包, targe也可能因为之前打包过而存在(无关紧要)
![](../../../images/fabu2.png)
然后我们再通过FTP软件, 将我们的包上传到tomcat的webapps下面就好了.其中的oil-shop文件夹可以和旧的war包一起删除, 这是等运行起来后自动生成的class文件,当我们上传了新的war包之后, 就会有新的oil-shop文件夹生成
![](../../../images/fabu3.png)

相关参考见`77 : 项目的编译, Maven编译jar包用来引用`



##### 82 : 项目的分支问题
A : 如果采用了git-flow的开发模式, master是稳定生产模式, develop是所有的开发基础, feture是特性分支, 我们所有的新的功能都在feture分支上, **当我们需要发布项目到测试环境的时候, 我们就需要将代码经过本地的环境测试没有问题了之后, 合并到develop分支, 然后打包develop分支的代码, 将其发布到tomcat;** 如果发布到正式环境, 那么久需要在确认develop分支的代码没有问题之后, 将其合并到master分支, 然后将master分支的代码打包发布到tomcat之中.



##### 83 : mybatis动态语句if的test问题
A : 如下
```java
//如下的第一个test, xxx,yyy应该是userId还是user_id?
@Select("<script>"
        + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
        + " FROM recommend_mobile "
        + " <where>"
        + " <if test=\" xxx !=null \"> and yyy = #{userId} </if>"
        + " <if test=\" status !=null \"> and status = #{status} </if>"
        + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
        + " ORDER BY id DESC LIMIT #{pageSize} "
        + " </where>"
        + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int           status,@Param("id") Long id, @Param("pageSize") int pageSize);
```

动态sql语句是为了可以灵活处理sql字段而有的一种解决方式. 我们可以从上面的注释看到问题, 其实下面已经给出了答案, 应该是userId, **因为我们所采取的的test测试, 都是针对domain类的, 所以也就是class之中的文件, 因此应该在test的条件中填写userId, 而在真正的sql语句之中, 应该是sql数据库之中的字段**. 因此, yyy处应该是user_id, 完整的语句如下

```java
" <if test=\" userId !=null \"> and user_id = #{userId} </if>"
```

上述的第3个测试语句之中的`and id <![CDATA[ < ]]> #{id}`的`<![CDATA[ < ]]> `是一个转义字符, 其中转义的是`<`小于号, 如果没有此`<![CDATA[  ]]>`, mybatis的mapper接口执行的时候就会导致参数无法正常对应绑定, 所以需要注意一下.



##### 84 : mybatis动态语句if参数调用的问题
A : 动态sql就是为了处理多种组合条件下的sql的一种方式, 比如,一个查询, 可能需要按照id, 可能需要按照typeId, 也可能有同时按照id和typeId查询的情况, 这时候如果三种情况都写, 就要三个语句, 那样很麻烦, 所以我们可以使用动态语句, test之中是测试条件, 由于测试的是参数的有无, 所以用是否为null, 如`id!=null`来判断, **由于基本类型, 如int, double等在初始化的时候jvm会给其一个默认的初始值, 所以永远不会为`null`, 所以如果有~~null需求~~的字段和测试的时候, 需要使用包装类型的定义, 如Long, Integer等**

```java
//DAO层的Mapper接口,动态查询,那么如何在servicec层和controller层调用呢?
@Select("<script>"
       + " SELECT id, mobile_type, amount, created, updated  FROM recommend_mobile_reward_rule "
       + " <where>"
       + " <if test=\" id !=null \"> and id = #{id} </if>"
       + " <if test=\" mobileType !=null \"> and mobile_type = #{mobileType} </if>"
       + " </where>"
       + "</script>")
RecommendMobileRewardRule getByIdOrTypeId(@Param("id") Integer id, @Param("mobileType") Integer mobileType);
```

```java
//service层调用动态语句
public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
	    RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.
            getByIdOrTypeId(id, mobileType);
		return rule;
}
```

由此可以看出, service层的调用其实没有什么特殊的作为, 就是按照其方法调用, 那么controller层呢?

```java
//controller层调用动态语句
@RequestMapping(value = "/getByIdOrTypeId", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByIdOrTypeId(Integer id, Integer mobileType) {
	// 参数检查
	if (id == null && mobileType == null) {
		return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
            message(ResultCode.PARAMS_ERROR.msg()).build();
		}
	RecommendMobileRewardRule rewardRule = ruleService.getByIdOrTypeId(id, mobileType);
	if (rewardRule == null) {
		log.info("电话卡类型的奖励规则已经存在! id:{}, mobileType:{}", id, mobileType);
        return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).result(ruleService.NOT_EXIST).build();
		}
        return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(rewardRule).build();
	}
```

由controller可以看出也是一样的, 其决定于如何传入的参数, 如果传入id为null那么久按照mobileType查询, 反之同理, **这是正常调用走mapper-->service-->controller的路径, 所有的调用参数都按照正常的方式调用, 采用什么参数, 由前端传入的参数自动决定**, 但是, 但是, 但是,有一种情况, 就是**可能这个使用动态语句的service方法只是为其他的方法提供支持的, 那么我们就需要在service层让别人调用, 由此可得, 当只是进行某些特殊的操作时候, 我们可以将不需要的字段设置为null 或者是test测试条件失效的条件即可**, 其实同url前端传入的方式是同理的, 只不过一个是手动, 一个是自动的, 例子如下

```java
//service层的特定调用
//插入使用mobileType, 不需要id
public int insert(int mobileType, int amount) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);//insert使用mobileType, 不需要id, 所以设置id=null
	if (tempRule != null) {
		return HAVE_EXIST;// mobileType已经存在
	}
	RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
	long time = TimeUtils.now();
	rule.setMobileType(mobileType);
	rule.setAmount(amount);
	rule.setCreated(time);
	rule.setUpdated(time);
	recommendMobileRewardRuleMapper.insert(rule);
	int result = rule.getId();
	return result;
}

// 删除使用使用id, 不需要mobileType
public int deleteById(int id) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);//delete使用id, 不需要mobileType,所以设置mobileType=null
	if (tempRule == null) return NOT_EXIST;
	int result = recommendMobileRewardRuleMapper.deleteById(id);
	return result;
}

//查询一条奖励规则使用id或者mobileType
public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
	RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.getByIdOrTypeId(id, mobileType);
	return rule;
}
```

其实说白了, **动态sql的调用,就是把需要的参数设置为正常的, 把不需要的参数设置为null**.






ref:
51.[mysql中decimal,numeric,double,float的区别](https://blog.csdn.net/wufaliang003/article/details/78502402),   52.[mysql 数据类型 Float、Double、Decimal和Numeric 的区别](http://www.uuboku.com/455.html),   53.[mysql中int、bigint、smallint 和 tinyint的区别与长度的含义](https://blog.csdn.net/spring21st/article/details/7332200)