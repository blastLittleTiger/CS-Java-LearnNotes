### 后端框架学习笔记4

***

[TOC]

##### 102 : Throwable, Error, Exception, RuntimeException, throw, throws的区别
A : 区别如下

在Java中, 根据错误性质将运行错误分为两类: 错误和异常. 在Java程序的执行过程中, 如果出现了异常事件, 就会生成一个异常对象. 生成的异常对象将传递Java运行时系统, 这一异常的产生和提交过程称为抛弃(throw)异常.当Java运行时系统得到一个异常对象时, 它将会沿着方法的调用栈逐层回溯, 寻找处理这一异常的代码. 找到能够处理这类异常的方法后, 运行时系统把当前异常对象交给这个方法进行处理, 这一过程称为捕获(catch)异常.
![](../../../images/exception%20series.png)



**Throwable**
类是 Java 语言中所有错误或异常的超类, 它的两个子类是Error和Exception



**Error**
是Throwable 的子类, 用于指示**合理的应用程序不应该试图捕获的严重问题**. 大多数这样的错误都是异常条件. 虽然   ThreadDeath 错误是一个"正规"的条件, 但它也是 Error 的子类, 因为**大多数应用程序都不应该试图捕获它**. 在执行该方法期间, 无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类, 因为这些错误可能是再也不会发生的异常条件. Error类包括一些严重的程序不能处理的系统错误类, 如内存溢出, 虚拟机错误, 栈溢出等. 这类错误一般与硬件有关, 与程序本身无关, 通常由系统进行处理, 程序本身无法捕获和处理.

1.OutOfMemoryError内存溢出一般是出现在申请了较多的内存空间没有释放的情形

```java
//java.lang.OutOfMemoryError  -Xmx150m
try {
	byte[] b = new byte[1024*1024*600];
} catch (OutOfMemoryError e) {
	e.printStackTrace();
}
```

运行时，设置jvm最大的heap内存150m，此时申请600m的内存，因此会报error

```java
java.lang.OutOfMemoryError: Java heap space
```

2.StackOverflowError
堆栈溢出错误. 当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误. 

```java
public static void main(String[] args) {
	method();
}
public static void method() {
	while (true) {
		method();
	}
}
```

无限次的递归调用出现

```java
Exception in thread "main" java.lang.StackOverflowError
```



**Exception**
类及其子类是 Throwable 的一种形式, 它指出了**合理的应用程序想要捕获的条件**. 有些异常在编写程序时无法预料的, 如中断异常, 非法存取异常等. 为了保证程序的健壮性, **Java要求必须对这些可能出现的异常进行捕获, 并对其进行处理**. Exception的除RuntimeException类的对象, 都是可检查的异常(Checked exception), Checked exception需要明确声明.

> public class Exception extends Throwable
>
> The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.
>
> The class Exception and any subclasses that are not also subclasses of RuntimeException are checked exceptions. Checked exceptions need to be declared in a method or constructor's throws clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary.



**RuntimeException**
类是Exception类的子类. **RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类**, 可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明. 它是Exception的子类. 常见的运行时异常:

```java
try {
	String str = new String("AA");
	str = null;
	System.out.println(str.length());
} catch (NullPointerException e) {
	e.printStackTrace();
	System.out.println("出现空指针的异常了");
}

try {
	Object obj = new Date();
	String str = (String) obj;
} catch (ClassCastException e) {
	System.out.println("出现类型转换的异常了");
} catch (Exception e) {
	e.printStackTrace();
} finally {
	System.out.println("处理完异常后的逻辑");
}

try {
	int i = 10;
	System.out.println(i / 0);
} catch (ArithmeticException e) {
	System.out.println("算术异常"+e.getMessage());
}

try {
	int[] i = new int[10];
	System.out.println(i[-10]);
} catch (ArrayIndexOutOfBoundsException e) {
	System.out.println("数组下标越界的异常！");
}
```

 

**IOExeption**

类是Exception类的子类, 从一个不存在的文件中读取数据, 越过文件结尾继续读取, 连接一个不存在的URL

```java
FileInputStream fis = null;
try {
	fis = new FileInputStream(new File("hello1.txt"));
	int b;
	while ((b = fis.read()) != -1) {
		System.out.print((char) b);
	}
} catch (FileNotFoundException e1) {
	System.out.println("文件找不到了！");
} catch (IOException e1) {
	System.out.println(e1.getMessage());
} finally {
	try {
		fis.close();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
```

 **throws用来声明一种可能要抛出的异常类型, throw用来抛出一个异常对象**.



##### 103 : Java中数组、List、Set互相转换
A : 主要是List和Set之中的toArray方法, 以及List和Set创建的时候, 由于可以使用collection参数, 所以相当于可以直接转换.

```java
import java.util.*;

public class ArrayListSet {
    //Array, List, Set之间的相互转换
    public static void main(String[] args) {
        //定义数组, 数据来源
        String[] names = new String[]{"关羽", "Justin", "大桥未久", "天海翼", "爱因斯坦", "白素贞"};
        /*数组转换成其他类型的数据*/
        Array2ListNoAddRemove(names);//数组-->List
        Array2ListHaveAddRemove(names);
        Array2Set(names);//数组-->Set

        /*List转换成Set和Array*/
        List2Set(names);//List-->Set
        List2Array(names);//List-->Array

        /*Set转换成List和Array*/
        HashSet<String> hashSet = new HashSet<>();
        hashSet.add("北京");
        hashSet.add("北京");
        hashSet.add("上海");
        hashSet.add("天津");
        hashSet.add("成都");
        hashSet.add("杭州");
        hashSet.add("广州");
        Set2Array(hashSet);//Set-->数组
        Set2List(hashSet);//Set-->List
    }

    public static void Array2Set(String[] nameArray) {
        System.out.println("\nArray------>Set");
        Set<String> starts = new HashSet<>(Arrays.asList(nameArray));
        starts.add("Mary"); // ok
        starts.remove("Tom"); // ok
        System.out.println("set长度: " + starts.size());

    }

    // array 转换 Collection(不可添加删除元素, 固定大小)
    public static void Array2ListHaveAddRemove(String[] nameArray) {
        System.out.println("\nArray------>List(可以add & remove)");
        List nameList = new ArrayList<String>();
        for (String temp : nameArray) {
            nameList.add(temp);
        }
        nameList.add("Mary"); // ok
        nameList.remove(0); // ok
        StringBuilder sb2 = new StringBuilder();
        Iterator<String> iterator = nameList.iterator();
        while (iterator.hasNext()) {
            sb2.append(iterator.next() + " ,");
        }
        String listStrTemp2 = sb2.toString();
        String listStr2 = listStrTemp2.substring(0, listStrTemp2.length() - 1);
        System.out.println("最后一个,去除: " + listStr2);
    }

    // array 转换 list(不可添加删除元素, 固定大小)
    public static void Array2ListNoAddRemove(String[] nameArray) {
        System.out.println("\nArray------>List(不能add & remove)");
        List<String> list = Arrays.asList(nameArray);
        System.out.println("list的size(): " + list.size());
        StringBuilder sb1 = new StringBuilder();
        ListIterator<String> it = list.listIterator();
        while (it.hasNext()) {
            sb1.append(it.next() + " ,");
        }
        String listStrTemp = sb1.toString();//去除掉最后一个","
        System.out.println("最后一个,未去除: " + listStrTemp);
        String listStr = listStrTemp.substring(0, listStrTemp.length() - 1);
        System.out.println("最后一个,去除: " + listStr);
        //list.add("123"); // Arrays.asList()方法, 只能产生固定长度的list, 转换后添加和删除都不可以
    }

    public static void List2Array(String[] nameArray) {
        System.out.println("\nList------>Array");
        List<String> list = Arrays.asList(nameArray);
        String[] strArray = (String[]) list.toArray();//toarray
        for (String obj : strArray) {
            System.out.print((obj + ", "));
        }
        System.out.println("\n转换后数组的size:" + strArray.length);
    }

    public static void List2Set(String[] nameArray) {
        System.out.println("\nList------>Set");
        List<String> list = Arrays.asList(nameArray);
        HashSet hashSet = new HashSet(list);
        for (Object obj : hashSet) {
            System.out.print((String) obj + ", ");
        }
        System.out.println("\nhashSet的size:" + hashSet.size());
    }

    public static void Set2Array(HashSet hashSet) {
        System.out.println("\nSet------>Array");
        Object[] strArr = hashSet.toArray();//List,Set自带 toArray方法
        System.out.println("strArr.size(): " + strArr.length);
    }

    public static void Set2List(HashSet hashSet) {
        System.out.println("\nSet------>Hash");
        List<String> list = new ArrayList<>(hashSet);//这个是来自于Collection的构造函数
        list.add("123");
        System.out.println("list.size(): " + list.size());
    }
}
```



##### 104 : String类的基本方法, StringBuffer以及StringBuilder类

A : String是常量, 创建之后就无法修改, StringBuffer以及StringBuilder创建的是变量, StringBuffer线程安全, 速度慢一点, StringBuilder线程不安全, 速度快一点.

![](../../../images/stringsbuffersbuilder.png)

String类的用法如下:

```java
public class UseLangString {
    public static void main(String[] args) {
        useValueOf();
        charAndByte();
        useIndexOf();
        lowAndUp();
        startAndEnd();
        getSubStr();
    }

    /*使用valueOf*/
    public static void useValueOf() {
        System.out.println("\n---使用valueOf---");
        long longValue = 10l;
        String longValueStr = String.valueOf(longValue);
        System.out.println("method valueOf: " + longValueStr);
        char[] chars = new char[]{'h', 'e', 'l', 'l', 'o'};
        String charStr = String.valueOf(chars); //对应于chars
        System.out.println("method valueOf: " + charStr);
    }

    /*使用char和Byte的功能*/
    public static void charAndByte() {
        System.out.println("\n---使用char和Byte的功能---");
        String str1 = "今天是美好的一天";
        String str2 = "Hello, wonderful day!";
        byte[] str1ByteArr = str1.getBytes();//获得byte[] 数组
        byte[] str2ByteArr = str2.getBytes();//byte是二进制的编码
        System.out.println(str1ByteArr.length);
        System.out.println(str2ByteArr.length);
        for (byte temp : str1ByteArr) {//遍历byte[] str1ByteArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");
        for (byte temp : str2ByteArr) {//遍历byte[] str2ByteArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");
        char[] str1CharArr = str1.toCharArray();// 相当于把汉字完全分开了
        char[] str2CharArr = str2.toCharArray();
        System.out.println(str1CharArr.length);
        System.out.println(str2CharArr.length);
        for (char temp : str1CharArr) {//遍历char[] str1CharArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");
        for (char temp : str2CharArr) {//遍历char[] str2CharArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");

    }

    /*使用indexOf*/
    public static void useIndexOf() {
        System.out.println("\n---使用indexOf---");
        String wenhou = "你们好,中国人民!";
        String hello = " hello, chinese people!";
        System.out.println(wenhou.indexOf(2));//'2'字符的位置在何处, 没有2字符在其中
        System.out.println(wenhou.indexOf('好'));//'好'字符的位置在何处
        System.out.println(hello.indexOf(2));
        System.out.println(hello.indexOf('人'));
        System.out.println(hello.charAt(2));
        System.out.println(wenhou.codePointAt(6));//返回在unicode编码的具体位置
        System.out.println(hello.codePointAt(2));
        System.out.println(hello.lastIndexOf(1));
        System.out.println(hello.lastIndexOf('e'));//'e'最后一次在hello之中出现的位置
        System.out.println(hello.lastIndexOf("people"));//"people"最后一次在hello之中出现的位置
    }

    /*使用大小写转换和比较*/
    public static void lowAndUp() {
        System.out.println("\n---使用大小写转换和比较---");
        String low = "abcddd";
        String up = "ABCddd";
        System.out.println(low.toUpperCase());
        System.out.println(up.toLowerCase());
        System.out.println(low.equalsIgnoreCase(up));//不记大小写, 然后比较是否相等
        System.out.println(low.compareToIgnoreCase(up));//不计大小写, 返回比较结果(-1,0,1)
        System.out.println(low.compareTo(up));// 比较大小, 返回值大于0, 则表示low大于up, low-up, 小写字母大于大写字母的值
    }

    /*使用start和end相关方法*/
    public static void startAndEnd() {
        System.out.println("\n---使用start和end相关方法---");
        String str1 = "    今天是美好的一天";
        String str2 = "Hello, wonderful day!";
        System.out.println(str1.startsWith("jin"));
        System.out.println(str1.startsWith("今"));
        System.out.println(str2.endsWith("!"));
        System.out.println(str1);
        System.out.println(str1.trim());//去除前后空格

    }

    /*取得部分的字符串*/
    public static void getSubStr() {
        System.out.println("\n---取得部分的字符串---");
        String clause1 = "白日依山尽, 黄河入海流";
        String clause2 = "Do not, for one repulse, give up the purpose that you resolved to effect."
                + "To be, or not to be, that is the question.";
        System.out.println(clause1);
        System.out.println(clause2);
        System.out.println(clause1.concat(clause2));//二者拼接起来
        System.out.println(clause1.substring(6));   //取得部分的字符串
        System.out.println(clause1.substring(6, 10));
        System.out.println(clause1.isEmpty());//是否为空
        System.out.println(clause2.contains("purpose"));//是否包含一个字符串
        System.out.println(clause2.replace("o", "=*="));//替换
        String[] clause1SplitArr = clause2.split(",");//分割
        String[] clause2SplitArr = clause2.split(",", 3);//使用","作为分割符, 但是只分割三次, 后面的不分割了放在一起
        System.out.println(clause1SplitArr.length);
        System.out.println(clause2SplitArr.length);
        for (String temp : clause1SplitArr) {
            System.out.print(temp + "   ");
        }
        System.out.println(" ");
        for (String temp : clause2SplitArr) {
            System.out.print(temp + "   ");
        }
        System.out.println(" ");
        //Do not    for one repulse    give up the purpose that you resolved to effect.To be    or not to be    that is the question.
        //Do not    for one repulse    give up the purpose that you resolved to effect.To be, or not to be, that is the question.
    }   
}
```

StringBuffer和StringBuilder类的用法

```java
public class UseStringBufferBuilder {
    public static void main(String[] args) {
        System.out.println("StringBuffer: A thread-safe, mutable sequence of characters. "
                + "StringBuffer:可变字符串, 速度中等, 线程安全");
        System.out.println("StringBuilder: A mutable sequence of characters. This class "
                + "provides an API compatible with StringBuffer, but with no guarantee of synchronization."
                + "StringBuilder:可变字符串, 高效快速, 线程不安全");
        System.out.println("StringBuilder和StringBuffer之间的区别就在于线程安全性上面, 其他的方面都相同,api定义和用法都相同");
        useStringBuffer();
        useStringBuilder();

    }

    public static void useStringBuffer() {
        System.out.println("\n\n\n---使用StrigBuffer的功能---");
        String poem = "我欲抽到断扬子, 问天谁敢与争锋!";
        StringBuffer sb1 = new StringBuffer();
        StringBuffer sb2 = new StringBuffer(6);//设置容量
        StringBuffer sb3 = new StringBuffer(poem);//通过String字符串来创建StringBuffer对象.


        System.out.println("\n使用各种构造函数, 创建一个StringBuffer---");
        sb1.append(12);//int
        sb1.append("hello world!");//str
        sb1.append(new Object().toString());//对象
        sb1.append(36.8d);//duble
        sb1.append(poem, 2, 8);//从String字符串之中取一部分
        System.out.println(sb1.toString());//StringBuffer转换成String, toString


        System.out.println("\n使用delete, insert等api");
        sb1.deleteCharAt(2);//按位置删除, 第2个char
        sb1.delete(3, 12);//删除第3-12个char, 范围是[3,12]
        System.out.println(sb1.toString());
        System.out.println(sb1.capacity());//容量
        sb1.insert(5, 12345678);/*offset的含义是什么?*/
        System.out.println(sb1.toString());
        System.out.println(sb1.capacity());//容量
        sb1.insert(0, "你说什么?");//insert String,offset=0, 表示从现在的第0个位置插入
        char[] ch1 = new char[]{'中', '❀', '民', '果'};
        sb1.insert(sb1.length(), ch1);//末尾插入, 插入一个char 数组
        System.out.println(sb1.toString());


        System.out.println("\n使用index, subString, reverse, replace和getChars等api");
        int num = sb1.lastIndexOf("8");//最后一个8出现的位置
        int index = sb1.indexOf("❀");
        String sb7_end = sb1.substring(7);//取其中一部分就变成了String类型
        String sb3_9 = sb1.substring(3, 9);
        System.out.println("num: " + num + ", index: " + index + ", sb7_end:" + sb7_end + ", sb3_9:" + sb3_9);

        char[] chars = new char[]{'h', 'e', 'l', 'l', 'o', '!', 'M', 'I', 'A'};//size为7, 不过貌似没什么异常发生
        sb2.append(chars);
        System.out.println(sb2.toString() + ", " + sb2.toString().length());
        System.out.println(sb2.reverse());//reverse
        sb2.replace(2, 4, "******(敏感词屏蔽掉)******");
        System.out.println(sb2.toString());
        char[] chars123 = new char[10];
        sb2.getChars(1, 7, chars123, 3);//去填充一个char[]数组
        for (char ch : chars123) {
            System.out.print(ch);
        }
        System.out.println(" ");
        System.out.println(sb3.toString());
    }

    public static void useStringBuilder() {
        System.out.println("\n\n\n---使用StrigBuilder的功能---");
        String poem = "我欲抽到断扬子, 问天谁敢与争锋!";
        StringBuilder stringBuilder1 = new StringBuilder();
        StringBuilder stringBuilder2 = new StringBuilder(6);//设置容量
        StringBuilder stringBuilder3 = new StringBuilder(poem);//通过String字符串来创建StringBuilder对象.


        System.out.println("\n使用各种构造函数, 创建一个StringBuffer---");
        stringBuilder1.append(12);//int
        stringBuilder1.append("hello world!");//str
        stringBuilder1.append(new Object().toString());//对象
        stringBuilder1.append(36.8d);//duble
        stringBuilder1.append(poem, 2, 8);//从String字符串之中取一部分
        System.out.println(stringBuilder1.toString());//StringBuffer转换成String, toString


        System.out.println("\n使用delete, insert等api");
        stringBuilder1.deleteCharAt(2);//按位置删除, 第2个char
        stringBuilder1.delete(3, 12);//删除第3-12个char, 范围是[3,12]
        System.out.println(stringBuilder1.toString());
        System.out.println(stringBuilder1.capacity());//容量
        stringBuilder1.insert(5, 12345678);/*offset的含义是什么?*/
        System.out.println(stringBuilder1.toString());
        System.out.println(stringBuilder1.capacity());//容量
        stringBuilder1.insert(0, "你说什么?");//insert String,offset=0, 表示从现在的第0个位置插入
        char[] ch1 = new char[]{'中', '❀', '民', '果'};
        stringBuilder1.insert(stringBuilder1.length(), ch1);//末尾插入, 插入一个char 数组
        System.out.println(stringBuilder1.toString());


        System.out.println("\n使用index, subString, reverse, replace和getChars等api");
        int num = stringBuilder1.lastIndexOf("8");//最后一个8出现的位置
        int index = stringBuilder1.indexOf("❀");
        String sb7_end = stringBuilder1.substring(7);//取其中一部分就变成了String类型
        String sb3_9 = stringBuilder1.substring(3, 9);
        System.out.println("num: " + num + ", index: " + index + ", sb7_end:" + sb7_end + ", sb3_9:" + sb3_9);

        char[] chars = new char[]{'h', 'e', 'l', 'l', 'o', '!', 'M', 'I', 'A'};//size为7, 不过貌似没什么异常发生
        stringBuilder2.append(chars);
        System.out.println(stringBuilder2.toString() + ", " + stringBuilder2.toString().length());
        System.out.println(stringBuilder2.reverse());//reverse
        stringBuilder2.replace(2, 4, "******(敏感词屏蔽掉)******");
        System.out.println(stringBuilder2.toString());
        char[] chars123 = new char[10];
        stringBuilder2.getChars(1, 7, chars123, 3);//去填充一个char[]数组
        for (char ch : chars123) {
            System.out.print(ch);
        }
        System.out.println(" ");
        System.out.println(stringBuilder3.toString());

    }
}
```



##### 105 : Arrays类的基本方法
A : 区别如下



##### 106 : Collections类的基本方法
A : 区别如下



##### 107 : Comparable接口和Comparator接口的用法比较
A : Comparable和Comparator接口都是为了对类进行比较, 众所周知, 诸如Integer, double等基本数据类型, java可以对他们进行比较, 而对于类的比较, 需要人工定义比较用到的字段比较逻辑. 可以把**Comparable理解为内部比较, 实现了内部比较**, 而**Comparator是外部比较器, 专门用来比较**.  基本的写法如下:

> *Comparable接口在`java.lang`包之中, 而Comparator接口在`java.util`包之中*.
> 创建了比较器Comparator来compare对象o1和o2, 而Comparable是让一个类的对象拥有自己和自己对象比较的compareTo()方法, Comparator是用来创建比较某种类型的比较器的专门的接口

SlaveKindOneComparable(使用Comparable)
```java
//Comparable接口的使用
import lombok.Data;

/**
 * @Author: prayjourney
 * @Despcription:
 * @Date: Created in 2018/8/13 0:35
 * @Modified by:
 */
@Data
public class SlaveKindOneComparable extends Slave implements Comparable {
    private int age;
    private String name;
    private float price;

    SlaveKindOneComparable(int age, String name, float price) {
        super();
        this.age = age;
        this.name = name;
        this.price = price;
    }

    //仅仅按照年龄来比较
    @Override
    public int compareTo(Object o) {
        if (this.age < ((SlaveKindOneComparable) o).getAge()) {
            return -1;
        } else if (this.age == ((SlaveKindOneComparable) o).getAge()) {
            return 0;
        } else {
            return 1;
        }
    }

    public static void main(String[] args) {
        SlaveKindOneComparable slave1 = new SlaveKindOneComparable(18, "jim", 67.9f);
        SlaveKindOneComparable slave2 = new SlaveKindOneComparable(13, "fg1", 67.2f);
        System.out.println(slave1.compareTo(slave2));//比较
    }
}

@Data
class Slave {
    private int age;
    private String name;
    private float price;
}
```

SlaveKindTwoComparator(使用Comparator)
```java
//Comparator接口的使用
import lombok.Data;

import java.util.Comparator;

/**
 * @Author: prayjourney
 * @Despcription:
 * @Date: Created in 2018/8/13 0:56
 * @Modified by:
 */
public class SlaveKindTwoComparator implements Comparator {

    //仅仅按照年龄来比较
    @Override
    public int compare(Object o1, Object o2) {
        if (((SlaveKindTwo) o1).getAge() > ((SlaveKindTwo) o2).getAge()) {
            return 1;
        } else if (((SlaveKindTwo) o1).getAge() == ((SlaveKindTwo) o2).getAge()) {
            return 0;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        SlaveKindTwo slave1 = new SlaveKindTwo(18, "jim", 67.9f);
        SlaveKindTwo slave2 = new SlaveKindTwo(21, "张三", 97.2f);
        SlaveKindTwo slave3 = new SlaveKindTwo(21, "罗斯托夫斯基", 17.2f);
        SlaveKindTwo slave4 = new SlaveKindTwo(32, "瓦洛佳", 22.2f);

        /*这是比较器*/
        SlaveKindTwoComparator sktc = new SlaveKindTwoComparator();
        //在外部比较
        System.out.println(sktc.compare(slave1, slave2));
        System.out.println(sktc.compare(slave2, slave3));
        System.out.println(sktc.compare(slave3, slave1));
        System.out.println(sktc.compare(slave1, slave4));

    }
}

@Data
class SlaveKindTwo extends Slave {
    private int age;
    private String name;
    private float price;

    SlaveKindTwo(int age, String name, float price) {
        super();
        this.age = age;
        this.name = name;
        this.price = price;
    }
}

@Data
class Slave {
    private int age;
    private String name;
    private float price;
}
```



##### 108 : 去掉String字符后的最后一个字符
A : 如下

```java
String listStrTemp2 = sb2.toString();
String listStr2 = listStrTemp2.substring(0, listStrTemp2.length() - 1);
System.out.println("最后一个,去除: " + listStr2);
```



##### 109 : Apache工具类的使用

A : 示例如下



##### 110 : String 和 CharSequence 关系与区别

A : String 继承于CharSequence, 也就是说**String也是CharSequence类型**. CharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口. 除了String实现了CharSequence之外, StringBuffer和StringBuilder也实现了 CharSequence接口. 需要说明的是, **CharSequence就是字符序列，String, StringBuilder和StringBuffer本质上都是通过字符数组实现的!**
**CharSequence 是 char 值的一个可读序列**. 此接口对许多不同种类的 char 序列提供统一的只读访问(个人理解应该算得上是char类型得一个集合, 是interface). **String 类代表字符串, 实现了CharSequence 接口**. Java 程序中的所有字符串字面值(如"abc")都作为此类的实例来实现. CharSequence是String实现的一个接口, 就是要求是一串字符. 所以每个参数类型是CharSequence的方法，**都可以实际代入String对象**. *为什么这些方法不干脆定义String作为参数类型* ? 因为还有其他的CharSequence类型的类, 比如StringBuffer和StringBuilder这两个很重要的类. String对象是不可变的, 这两个可变, 所以我们在构造字符串的过程中往往要用到StringBuffer和StringBuilder.  如果那些方法定义String作为参数类型, 那么就没法对它们用那些方法, 先得转化成String才能用. 但StringBuffer和StringBuilder转换为String再转换过来很耗费时间，用它们而不是直接用String的“加法”来构造新String本来就是为了省时间, 所以如果用String作为参数类型就无法达到期待的效果.

![](../../../images/stringsbuffersbuilder.png)

```java
public final class String extends Object 
implements Serializable, Comparable<String>, CharSequence

The String class represents character strings. All string literals in Java programs, such as "abc", are implemented as instances of this class.
Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. For example:
```



##### 111 : HashMap的遍历

A : 总的来说, 有5种遍历, 其中1种是仅遍历了values, 4种完全遍历了整个的map, 分类和原理介绍如下

###### 划分

Map的遍历: 
**遍历方式**: 分为**foreach**和**iterator**两种, *foreach效率好一点*. 这是方式上面的区别, 还有在使用的遍历因子的不同;
**遍历因子**: 按照遍历因子来划分,  则有**keySet()**和**entrySet()**两种, map的内部功能有Map.Entry接口实现, keySet()是直接取到keys, entrySet是首先取到每一个entry, 然后使用entry的getKey() 和 getValue()来完整的实现遍历, 速度要更好.

###### CreateTraversal.java(使用例子)

```java
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * @Author: renjiaxin
 * @Despcription:
 * @Date: Created in 2018/8/17 9:52
 * @Modified by:
 */
@Slf4j
public class CreateTraversal {
    public static Map<String, Object> createMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("天海翼", "36C");
        map.put("小泽玛利亚", "42F");
        map.put("", "");//可以的, 这样定义也可以
        map.put(null, null);/*key可以为null, 但是只能有一个, 只有一个起作用*/
        map.put(null, null);
        map.put("波多野结衣", "36C");
        map.put("苍井空", "28B");
        map.put(" ", " ");//可以的, 这样定义也可以
        map.put("小仓优子", "26A");
        map.put("深田恭子", null);
        map.put("雨宫琴音", "36C");
        map.put("北条麻妃", null);//value为null, 资料暂空, value为null可以有多个
        map.put("青山葵", "43F");

        return map;
    }

    public static void traversalMap(Map<String, Object> map, int type) {
        if (type < 0 || type > 4) {
            log.warn("错误的遍历类型, type:{}", type);
        }
        switch (type) {
            case 0:
                partForEachTraversal(map);
                break;
            case 1:
                forEachKeySetTraversal(map);
                break;
            case 2:
                forEachEntrySetTraversal(map);
                break;
            case 3:
                iteratorKeySetTraversal(map);
                break;
            case 4:
                System.out.println("推荐map.entrySet()+iterator");
                iteratorEntrySetTraversal(map);
                break;
            default:
                iteratorEntrySetTraversal(map);

        }
    }

    /*只是遍历了values, 没有遍历keys*/
    private static void partForEachTraversal(Map<String, Object> map) {
        System.out.println("\n使用values来循环, 只能遍历values, 无法遍历keys");
        long start = System.currentTimeMillis();
        for (Object value : map.values()) {
            System.out.print(value + " ");
        }
        long end = System.currentTimeMillis();
        long time = start - end;
        System.out.println("\nmap的大小n: " + map.values().size());
        System.out.println("运行时间为: " + time + "ms");
        System.out.println("");

    }

    /*map.keySet()+foreach*/
    private static void forEachKeySetTraversal(Map<String, Object> map) {
        System.out.println("map.keySet()+foreach, 完成遍历, 速度慢!");
        long start = System.currentTimeMillis();
        for (String key : map.keySet()) {
            System.out.print("key: " + key + ", values: " + map.get(key) + "; ");
        }
        long end = System.currentTimeMillis();
        long time = start - end;
        System.out.println("\nmap的大小n: " + map.values().size());
        System.out.println("运行时间为: " + time + "ms");
        System.out.println("");
    }

    /*map.entrySet()+foreach*/
    private static void forEachEntrySetTraversal(Map<String, Object> map) {
        System.out.println("map.entrySet()+foreach, 完成遍历, 速度快!");
        System.out.println("Map.Entry是Map类内部的一个接口,提供了Map类的主体方法和功能");
        long start = System.currentTimeMillis();
        Set<Map.Entry<String, Object>> entrySet = map.entrySet();//把这个set取出来
        for (Map.Entry<String, Object> entry : entrySet) {/*---*/
            System.out.print("key= " + entry.getKey() + " and value= " + entry.getValue() + "; ");
        }
        long end = System.currentTimeMillis();
        long time = start - end;
        System.out.println("\nmap的大小n: " + map.values().size());
        System.out.println("运行时间为: " + time + "ms");
        System.out.println("");
    }


    /*map.keySet()+iterator*/
    private static void iteratorKeySetTraversal(Map<String, Object> map) {
        System.out.println("map.keySet()+iterator, 完成遍历");
        long start = System.currentTimeMillis();
        Iterator<String> it = map.keySet().iterator();/**/
        while (it.hasNext()) {
            System.out.print("key :" + it.next() + " , value: " + map.get(it.next()));
        }
        long end = System.currentTimeMillis();
        long time = start - end;
        System.out.println("\nmap的大小n: " + map.values().size());
        System.out.println("运行时间为: " + time + "ms");
        System.out.println("");
    }

    /*map.entrySet()+iterator*/
    private static void iteratorEntrySetTraversal(Map<String, Object> map) {
        System.out.println("map.entrySet()+iterator, 完成遍历, 推荐的做法!");
        long start = System.currentTimeMillis();
        //Iterator it = map.entrySet().iterator();/*---*/
        Iterator<Map.Entry<String, Object>> it = map.entrySet().iterator();//上下相同, 这个清晰一些
        while (it.hasNext()) {
            System.out.print("key :" + it.next() + " , value: " + map.get(it.next()));
        }
        long end = System.currentTimeMillis();
        long time = start - end;
        System.out.println("\nmap的大小n: " + map.values().size());
        System.out.println("运行时间为: " + time + "ms");
        System.out.println("");
    }

    public static void main(String[] args) {
        System.out.println("由于map使用key-value形式的数据结构,所以没有使用数字形式的位置,不可使用for(int i=0;i<n;i++形式)");
        Map<String, Object> mp = createMap();
        traversalMap(mp, 0);
        traversalMap(mp, 1);
        traversalMap(mp, 2);
        traversalMap(mp, 3);
        traversalMap(mp, 4);
    }
}
```



##### 112 : HashMap实现原理

A : **HashMap的主干是一个Entry数组. Entry是HashMap的基本组成单元, 每一个Entry包含一个key-value键值对**. 具体介绍如下:

Entry数组

> 关于Entry数组的理解
> int数组之中的值,也全都是int. 所以Map.Entry数组之中的值, 也全都是Map.Entry类型的值, 桶用来索引(找到hashcode)这个作用是用数组来完成的,而这个进入到比如Map.Entry[1]位置的Map.Entry,他不是一个单纯的数字或者值, 而是一个可以继续索引其他值的"值+索引",是一个复合的值,可以表示值和索引,而这个值,是key+value,这在其定义之中体现了出来.

```java
//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
```

 Entry是HashMap中的一个静态内部类. 代码如下

```java
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;//存储指向下一个Entry的引用，单链表结构
    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

    /**
    * Creates new entry.
    */
    Entry(int h, K k, V v, Entry<K,V> n) {
    value = v;
    next = n;
    key = k;
    hash = h;
} 
```

 所以, HashMap的整体结构如下

![img](../../../images/entryandarray.png)　　

简单来说:**HashMap由数组+链表组成的, 数组是HashMap的主体, 链表则是主要为了解决哈希冲突而存在的, 如果定位到的数组位置不含链表(当前entry的next指向null), 那么对于查找, 添加等操作很快, 仅需一次寻址即可; 如果定位到的数组包含链表, 对于添加操作, 其时间复杂度为O(n), 首先遍历链表, 存在即覆盖, 否则新增; 对于查找操作来讲, 仍需遍历链表, 然后通过key对象的equals方法逐一比对查找. 所以, 性能考虑, HashMap中的链表出现越少, 性能才会越好**. 



##### 113 : HashMap和HashSet之间的关系
A : HashMap 和 HashSet 是 Java Collection Framework 的两个重要成员, 其中 HashMap 是 Map 接口的常用实现类, HashSet 是 Set 接口的常用实现类. 由哈希表(实际上是一个HashMap实例)支持, 它不保证set 的迭代顺序, 特别是它不保证该顺序恒久不变, 此类允许使用null元素. 虽然 HashMap 和 HashSet 实现的接口规范不同, 但它们底层的 Hash 存储机制完全一样, **HashSet 本身就采用 HashMap 来实现的**, HashSet的实现其实非常简单, 它只是封装了一个HashMap对象来存储所有的集合元素. **所有放入HashSet中的集合元素实际上由HashMap的key来保存, 而HashMap的value则存储了一个PRESENT, 它是一个静态的Object对象**. HashSet的绝大部分方法都是通过调用HashMap的方法来实现的, 因此HashSet和HashMap两个集合在实现本质上是相同的. **对于HashSet中保存的对象, 请注意正确重写其equals和hashCode方法**, 以保证放入的对象的唯一性. 
![](../../../images/hashsethashmap.png)

HashSet的源码如下:

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {  
    static final long serialVersionUID = -5024744406713321676L;  
  
    // 底层使用HashMap来保存HashSet中所有元素。  
    private transient HashMap<E,Object> map;  
      
    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  
    private static final Object PRESENT = new Object();  
  
    /** 
     * 默认的无参构造器，构造一个空的HashSet。 
     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 
     */  
    public HashSet() {  
    map = new HashMap<E,Object>();  
    }  
  
    /** 
     * 构造一个包含指定collection中的元素的新set。 
     * 实际底层使用默认的加载因子0.75和足以包含指定 
     * collection中所有元素的初始容量来创建一个HashMap。 
     * @param c 其中的元素将存放在此set中的collection。 
     */  
    public HashSet(Collection<? extends E> c) {  
    map = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));  
    addAll(c);  
    }  
  
    /** 
     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 
     * 实际底层以相应的参数构造一个空的HashMap。 
     * @param initialCapacity 初始容量。 
     * @param loadFactor 加载因子。 
     */  
    public HashSet(int initialCapacity, float loadFactor) {  
    map = new HashMap<E,Object>(initialCapacity, loadFactor);  
    }  
  
    /** 
     * 以指定的initialCapacity构造一个空的HashSet。 
     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 
     * @param initialCapacity 初始容量。 
     */  
    public HashSet(int initialCapacity) {  
    map = new HashMap<E,Object>(initialCapacity);  
    }  
  
    /** 
     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 
     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 
     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 
     * @param initialCapacity 初始容量。 
     * @param loadFactor 加载因子。 
     * @param dummy 标记。 
     */  
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {  
    map = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);  
    }  
  
    /** 
     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 
     * 底层实际调用底层HashMap的keySet来返回所有的key。 
     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， 
     * value使用一个static final的Object对象标识。 
     * @return 对此set中元素进行迭代的Iterator。 
     */  
    public Iterator<E> iterator() {  
    return map.keySet().iterator();  
    }  
  
    /** 
     * 返回此set中的元素的数量（set的容量）。 
     * 
     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 
     * @return 此set中的元素的数量（set的容量）。 
     */  
    public int size() {  
    return map.size();  
    }  
  
    /** 
     * 如果此set不包含任何元素，则返回true。 
     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 
     * @return 如果此set不包含任何元素，则返回true。 
     */  
    public boolean isEmpty() {  
    return map.isEmpty();  
    }  
  
    /** 
     * 如果此set包含指定元素，则返回true。 
     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) 
     * 的e元素时，返回true。      * 
     * 底层实际调用HashMap的containsKey判断是否包含指定key。 
     * @param o 在此set中的存在已得到测试的元素。 
     * @return 如果此set包含指定元素，则返回true。 
     */  
    public boolean contains(Object o) {  
    return map.containsKey(o);  
    }  
  
    /** 
     * 如果此set中尚未包含指定元素，则添加指定元素。 
     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) 
     * 的元素e2，则向此set 添加指定的元素e。 
     * 如果此set已包含该元素，则该调用不更改set并返回false。 
     * 底层实际将将该元素作为key放入HashMap。 
     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key 
     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， 
     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， 
     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， 
     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 
     * @param e 将添加到此set中的元素。 
     * @return 如果此set尚未包含指定元素，则返回true。 
     */  
    public boolean add(E e) {  
    return map.put(e, PRESENT)==null;  
    }  
  
    /** 
     * 如果指定元素存在于此set中，则将其移除。 
     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， 
     * 则将其移除。如果此set已包含该元素，则返回true 
     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 
     * 底层实际调用HashMap的remove方法删除指定Entry。 
     * @param o 如果存在于此set中则需要将其移除的对象。 
     * @return 如果set包含指定元素，则返回true。 
     */  
    public boolean remove(Object o) {  
    return map.remove(o)==PRESENT;  
    }  
  
    /** 
     * 从此set中移除所有元素。此调用返回后，该set将为空。
     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 
     */  
    public void clear() {  
    map.clear();  
    }  
  
    /** 
     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 
     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 
     */  
    public Object clone() {  
        try {  
            HashSet<E> newSet = (HashSet<E>) super.clone();  
            newSet.map = (HashMap<E, Object>) map.clone();  
            return newSet;  
        } catch (CloneNotSupportedException e) {  
            throw new InternalError();  
        }  
    }  
}  
```



##### 114 : Java中集合类的关系图谱介绍
A : 一些详细的介绍如下, 一些图片在115之中
###### Collection 和 Collections

首先要明确的是, Collection 和 Collections是两个不同的概念. Collection是一个接口, 所有的集合类(除Map外)都要继承(实现)自该接口. 它提供了对集合对象进行基本操作的通用接口方法. **Collections是一个包装类**, 它包含有各种有关集合操作的静态多态方法.(**Collections是一个工具类, 不能实例化**)
![CollectionVsCollections](../../../images/CollectionVsCollections.jpeg)

###### Collection家族关系图
![java-collection-hierarchy](../../../images/java-collection-hierarchy.jpeg)

###### Map家族的关系图
![MapClassHierarchy-600x354](../../../images/MapClassHierarchy-600x354.jpg)

###### 关系图谱
![collection-summary](../../../images/collection-summary.png)



##### 115 : Java中集合类的关系图
A : 如下:
![allcollectionmap](../../../images/allcollectionmap.png)

![collection1](../../../images/collection1.png)

![collection2](../../../images/collection2.png)

![collection3](../../../images/collection3.png)

![collection4](../../../images/collection4.png)

![collection5](../../../images/collection5.png)

![collection6](../../../images/collection6.png)





##### 116 : Usage of API documented as @since 1.6+
A : 具体报错内容如下:
This inspection finds all usages of methods that have @since tag in their documentation.  This may be useful when development is performed under newer SDK version as the target platform for production

报错图:
![img](../../../images/sinceerror.png)

解决方案:
![img](../../../images/sinceerrorslove.png)

看代码意思是, 那个方法是自Java1.6开始的, 但是, 看我图上面的language level 才是5, 级别不够, 所以就报错了. 在这个编辑器里面有好 几个地方都有关于这个jdk的版本的设置. 这么改完之后乍一看好像没问题了, 但是一会问题就又出来啦, 还得如下, 在maven build 里面添加如下的插件, 设置一下Java的版本就好啦. 
```xml
<build>  
    <plugins>  
        <plugin>  
            <groupId>org.apache.maven.plugins</groupId>  
            <artifactId>maven-compiler-plugin</artifactId>  
            <version>3.6.0</version>  
            <configuration>  
                <source>1.8</source>  
                <target>1.8</target>  
            </configuration>  
        </plugin>  
    </plugins>  
</build>  
```

 

ref:

80.[java中Comparable和Comparator两种比较器的区别](https://www.cnblogs.com/andywithu/p/7239613.html),   81.[Comparable和Comparator的区别](https://www.cnblogs.com/szlbm/p/5504634.html),   82.[Comparator和Comparable之间的区别](https://blog.csdn.net/u014133299/article/details/78608454),   83.[Java中数组、List、Set互相转换](https://blog.csdn.net/my_precious/article/details/53010232),   84.[String空格删除和java删除字符串最后一个字符的几种方法](https://www.cnblogs.com/ceshi2016/p/7574005.html),   85.[详解Java异常Throwable、Error、Exception、RuntimeException的区别](https://blog.csdn.net/kwu_ganymede/article/details/51382461),   86.[String详解, String和CharSequence区别, StringBuilder和StringBuffer的区别 (String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html) ,   87.[String 和 CharSequence 关系与区别](https://www.cnblogs.com/ChrisMurphy/p/4760197.html),   88.[遍历HashMap的四种方法](https://www.cnblogs.com/Berryxiong/p/6144086.html),   89.[HashMap遍历和使用](https://blog.csdn.net/zhangfengBX/article/details/76783348),   90.[Java中如何遍历Map对象的4种方法](https://blog.csdn.net/tjcyjd/article/details/11111401),   91.[Java中遍历Map的各种方式](https://www.jianshu.com/p/3d1fb84b2b63),  92.[HashMap遍历的两种方式，推荐使用entrySet()](https://blog.csdn.net/xueyepiaoling/article/details/5217709),   93.[HashMap循环遍历方式及其性能对比](http://www.trinea.cn/android/hashmap-loop-performance/),   94.[JCFInternals](https://github.com/prayjourney/JCFInternals),   95.[Intellij IDEA 出现“Usage of API documented as @since 1.6+”的解决办法](https://blog.csdn.net/qq_27093465/article/details/69372028),   96.[Java中集合类的关系图谱](http://www.hollischuang.com/archives/1342),   97.[Java集合框架](https://www.cnblogs.com/jqctop1/p/4722648.html),   98.[java集合复习笔记-java集合继承关系图](https://blog.csdn.net/sdhgood/article/details/38849477),   99.[史上最全Java集合关系图](https://blog.csdn.net/u010887744/article/details/50575735),   100.[JDK-Study](https://github.com/zxiaofan/JDK-Study/tree/master/src/java1/util/map),   101.[HashMap、HashSet和HashTable详解](https://blog.csdn.net/bear_wr/article/details/52275874),   102.[HashSet 的实现原理](http://wiki.jikexueyuan.com/project/java-collection/hashset.html),   103.[深入Java集合学习系列：HashSet的实现原理](http://zhangshixi.iteye.com/blog/673143),   104.[HashSet实现原理及源码分析](https://blog.csdn.net/itmyhome1990/article/details/76212556),   105.[JAVA提高十四：HashSet深入分析](https://www.cnblogs.com/pony1223/p/7877443.html),   106.[图解HashMap和HashSet的内部工作机制](http://www.importnew.com/21841.html)