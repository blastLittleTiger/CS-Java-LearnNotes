### 后端框架学习笔记4

***

[TOC]

##### 102 : Throwable, Error, Exception, RuntimeException, throw, throws的区别
A : 区别如下

在Java中, 根据错误性质将运行错误分为两类: 错误和异常. 在Java程序的执行过程中, 如果出现了异常事件, 就会生成一个异常对象. 生成的异常对象将传递Java运行时系统, 这一异常的产生和提交过程称为抛弃(throw)异常.当Java运行时系统得到一个异常对象时, 它将会沿着方法的调用栈逐层回溯, 寻找处理这一异常的代码. 找到能够处理这类异常的方法后, 运行时系统把当前异常对象交给这个方法进行处理, 这一过程称为捕获(catch)异常.
![](F:/CodeBank/MyGit/SummaryOfProgramming/images/exception%20series.png)



**Throwable**
类是 Java 语言中所有错误或异常的超类, 它的两个子类是Error和Exception



**Error**
是Throwable 的子类, 用于指示**合理的应用程序不应该试图捕获的严重问题**. 大多数这样的错误都是异常条件. 虽然   ThreadDeath 错误是一个"正规"的条件, 但它也是 Error 的子类, 因为**大多数应用程序都不应该试图捕获它**. 在执行该方法期间, 无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类, 因为这些错误可能是再也不会发生的异常条件. Error类包括一些严重的程序不能处理的系统错误类, 如内存溢出, 虚拟机错误, 栈溢出等. 这类错误一般与硬件有关, 与程序本身无关, 通常由系统进行处理, 程序本身无法捕获和处理.

1.OutOfMemoryError内存溢出一般是出现在申请了较多的内存空间没有释放的情形

```java
//java.lang.OutOfMemoryError  -Xmx150m
try {
	byte[] b = new byte[1024*1024*600];
} catch (OutOfMemoryError e) {
	e.printStackTrace();
}
```

运行时，设置jvm最大的heap内存150m，此时申请600m的内存，因此会报error

```java
java.lang.OutOfMemoryError: Java heap space
```

2.StackOverflowError
堆栈溢出错误. 当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误. 

```java
public static void main(String[] args) {
	method();
}
public static void method() {
	while (true) {
		method();
	}
}
```

无限次的递归调用出现

```java
Exception in thread "main" java.lang.StackOverflowError
```



**Exception**
类及其子类是 Throwable 的一种形式, 它指出了**合理的应用程序想要捕获的条件**. 有些异常在编写程序时无法预料的, 如中断异常, 非法存取异常等. 为了保证程序的健壮性, **Java要求必须对这些可能出现的异常进行捕获, 并对其进行处理**. Exception的除RuntimeException类的对象, 都是可检查的异常(Checked exception), Checked exception需要明确声明.

> public class Exception extends Throwable
>
> The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.
>
> The class Exception and any subclasses that are not also subclasses of RuntimeException are checked exceptions. Checked exceptions need to be declared in a method or constructor's throws clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary.



**RuntimeException**
类是Exception类的子类. **RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类**, 可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明. 它是Exception的子类. 常见的运行时异常:

```java
try {
	String str = new String("AA");
	str = null;
	System.out.println(str.length());
} catch (NullPointerException e) {
	e.printStackTrace();
	System.out.println("出现空指针的异常了");
}

try {
	Object obj = new Date();
	String str = (String) obj;
} catch (ClassCastException e) {
	System.out.println("出现类型转换的异常了");
} catch (Exception e) {
	e.printStackTrace();
} finally {
	System.out.println("处理完异常后的逻辑");
}

try {
	int i = 10;
	System.out.println(i / 0);
} catch (ArithmeticException e) {
	System.out.println("算术异常"+e.getMessage());
}

try {
	int[] i = new int[10];
	System.out.println(i[-10]);
} catch (ArrayIndexOutOfBoundsException e) {
	System.out.println("数组下标越界的异常！");
}
```

 

**IOExeption**

类是Exception类的子类, 从一个不存在的文件中读取数据, 越过文件结尾继续读取, 连接一个不存在的URL

```java
FileInputStream fis = null;
try {
	fis = new FileInputStream(new File("hello1.txt"));
	int b;
	while ((b = fis.read()) != -1) {
		System.out.print((char) b);
	}
} catch (FileNotFoundException e1) {
	System.out.println("文件找不到了！");
} catch (IOException e1) {
	System.out.println(e1.getMessage());
} finally {
	try {
		fis.close();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
```

 **throws用来声明一种可能要抛出的异常类型, throw用来抛出一个异常对象**.



##### 103 : Java中数组、List、Set互相转换
A : 主要是List和Set之中的toArray方法, 以及List和Set创建的时候, 由于可以使用collection参数, 所以相当于可以直接转换.

```java
import java.util.*;

public class ArrayListSet {
    //Array, List, Set之间的相互转换
    public static void main(String[] args) {
        //定义数组, 数据来源
        String[] names = new String[]{"关羽", "Justin", "大桥未久", "天海翼", "爱因斯坦", "白素贞"};
        /*数组转换成其他类型的数据*/
        Array2ListNoAddRemove(names);//数组-->List
        Array2ListHaveAddRemove(names);
        Array2Set(names);//数组-->Set

        /*List转换成Set和Array*/
        List2Set(names);//List-->Set
        List2Array(names);//List-->Array

        /*Set转换成List和Array*/
        HashSet<String> hashSet = new HashSet<>();
        hashSet.add("北京");
        hashSet.add("北京");
        hashSet.add("上海");
        hashSet.add("天津");
        hashSet.add("成都");
        hashSet.add("杭州");
        hashSet.add("广州");
        Set2Array(hashSet);//Set-->数组
        Set2List(hashSet);//Set-->List
    }

    public static void Array2Set(String[] nameArray) {
        System.out.println("\nArray------>Set");
        Set<String> starts = new HashSet<>(Arrays.asList(nameArray));
        starts.add("Mary"); // ok
        starts.remove("Tom"); // ok
        System.out.println("set长度: " + starts.size());

    }

    // array 转换 Collection(不可添加删除元素, 固定大小)
    public static void Array2ListHaveAddRemove(String[] nameArray) {
        System.out.println("\nArray------>List(可以add & remove)");
        List nameList = new ArrayList<String>();
        for (String temp : nameArray) {
            nameList.add(temp);
        }
        nameList.add("Mary"); // ok
        nameList.remove(0); // ok
        StringBuilder sb2 = new StringBuilder();
        Iterator<String> iterator = nameList.iterator();
        while (iterator.hasNext()) {
            sb2.append(iterator.next() + " ,");
        }
        String listStrTemp2 = sb2.toString();
        String listStr2 = listStrTemp2.substring(0, listStrTemp2.length() - 1);
        System.out.println("最后一个,去除: " + listStr2);
    }

    // array 转换 list(不可添加删除元素, 固定大小)
    public static void Array2ListNoAddRemove(String[] nameArray) {
        System.out.println("\nArray------>List(不能add & remove)");
        List<String> list = Arrays.asList(nameArray);
        System.out.println("list的size(): " + list.size());
        StringBuilder sb1 = new StringBuilder();
        ListIterator<String> it = list.listIterator();
        while (it.hasNext()) {
            sb1.append(it.next() + " ,");
        }
        String listStrTemp = sb1.toString();//去除掉最后一个","
        System.out.println("最后一个,未去除: " + listStrTemp);
        String listStr = listStrTemp.substring(0, listStrTemp.length() - 1);
        System.out.println("最后一个,去除: " + listStr);
        //list.add("123"); // Arrays.asList()方法, 只能产生固定长度的list, 转换后添加和删除都不可以
    }

    public static void List2Array(String[] nameArray) {
        System.out.println("\nList------>Array");
        List<String> list = Arrays.asList(nameArray);
        String[] strArray = (String[]) list.toArray();//toarray
        for (String obj : strArray) {
            System.out.print((obj + ", "));
        }
        System.out.println("\n转换后数组的size:" + strArray.length);
    }

    public static void List2Set(String[] nameArray) {
        System.out.println("\nList------>Set");
        List<String> list = Arrays.asList(nameArray);
        HashSet hashSet = new HashSet(list);
        for (Object obj : hashSet) {
            System.out.print((String) obj + ", ");
        }
        System.out.println("\nhashSet的size:" + hashSet.size());
    }

    public static void Set2Array(HashSet hashSet) {
        System.out.println("\nSet------>Array");
        Object[] strArr = hashSet.toArray();//List,Set自带 toArray方法
        System.out.println("strArr.size(): " + strArr.length);
    }

    public static void Set2List(HashSet hashSet) {
        System.out.println("\nSet------>Hash");
        List<String> list = new ArrayList<>(hashSet);//这个是来自于Collection的构造函数
        list.add("123");
        System.out.println("list.size(): " + list.size());
    }
}
```



##### 104 : String类的基本方法, StringBuffer以及StringBuilder类

A : String是常量, 创建之后就无法修改, StringBuffer以及StringBuilder创建的是变量, StringBuffer线程安全, 速度慢一点, StringBuilder线程不安全, 速度快一点.

![](../../../images/stringsbuffersbuilder.png)

String类的用法如下:

```java
public class UseLangString {
    public static void main(String[] args) {
        useValueOf();
        charAndByte();
        useIndexOf();
        lowAndUp();
        startAndEnd();
        getSubStr();
    }

    /*使用valueOf*/
    public static void useValueOf() {
        System.out.println("\n---使用valueOf---");
        long longValue = 10l;
        String longValueStr = String.valueOf(longValue);
        System.out.println("method valueOf: " + longValueStr);
        char[] chars = new char[]{'h', 'e', 'l', 'l', 'o'};
        String charStr = String.valueOf(chars); //对应于chars
        System.out.println("method valueOf: " + charStr);
    }

    /*使用char和Byte的功能*/
    public static void charAndByte() {
        System.out.println("\n---使用char和Byte的功能---");
        String str1 = "今天是美好的一天";
        String str2 = "Hello, wonderful day!";
        byte[] str1ByteArr = str1.getBytes();//获得byte[] 数组
        byte[] str2ByteArr = str2.getBytes();//byte是二进制的编码
        System.out.println(str1ByteArr.length);
        System.out.println(str2ByteArr.length);
        for (byte temp : str1ByteArr) {//遍历byte[] str1ByteArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");
        for (byte temp : str2ByteArr) {//遍历byte[] str2ByteArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");
        char[] str1CharArr = str1.toCharArray();// 相当于把汉字完全分开了
        char[] str2CharArr = str2.toCharArray();
        System.out.println(str1CharArr.length);
        System.out.println(str2CharArr.length);
        for (char temp : str1CharArr) {//遍历char[] str1CharArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");
        for (char temp : str2CharArr) {//遍历char[] str2CharArr
            System.out.print(temp + " ");
        }
        System.out.println(" ");

    }

    /*使用indexOf*/
    public static void useIndexOf() {
        System.out.println("\n---使用indexOf---");
        String wenhou = "你们好,中国人民!";
        String hello = " hello, chinese people!";
        System.out.println(wenhou.indexOf(2));//'2'字符的位置在何处, 没有2字符在其中
        System.out.println(wenhou.indexOf('好'));//'好'字符的位置在何处
        System.out.println(hello.indexOf(2));
        System.out.println(hello.indexOf('人'));
        System.out.println(hello.charAt(2));
        System.out.println(wenhou.codePointAt(6));//返回在unicode编码的具体位置
        System.out.println(hello.codePointAt(2));
        System.out.println(hello.lastIndexOf(1));
        System.out.println(hello.lastIndexOf('e'));//'e'最后一次在hello之中出现的位置
        System.out.println(hello.lastIndexOf("people"));//"people"最后一次在hello之中出现的位置
    }

    /*使用大小写转换和比较*/
    public static void lowAndUp() {
        System.out.println("\n---使用大小写转换和比较---");
        String low = "abcddd";
        String up = "ABCddd";
        System.out.println(low.toUpperCase());
        System.out.println(up.toLowerCase());
        System.out.println(low.equalsIgnoreCase(up));//不记大小写, 然后比较是否相等
        System.out.println(low.compareToIgnoreCase(up));//不计大小写, 返回比较结果(-1,0,1)
        System.out.println(low.compareTo(up));// 比较大小, 返回值大于0, 则表示low大于up, low-up, 小写字母大于大写字母的值
    }

    /*使用start和end相关方法*/
    public static void startAndEnd() {
        System.out.println("\n---使用start和end相关方法---");
        String str1 = "    今天是美好的一天";
        String str2 = "Hello, wonderful day!";
        System.out.println(str1.startsWith("jin"));
        System.out.println(str1.startsWith("今"));
        System.out.println(str2.endsWith("!"));
        System.out.println(str1);
        System.out.println(str1.trim());//去除前后空格

    }

    /*取得部分的字符串*/
    public static void getSubStr() {
        System.out.println("\n---取得部分的字符串---");
        String clause1 = "白日依山尽, 黄河入海流";
        String clause2 = "Do not, for one repulse, give up the purpose that you resolved to effect."
                + "To be, or not to be, that is the question.";
        System.out.println(clause1);
        System.out.println(clause2);
        System.out.println(clause1.concat(clause2));//二者拼接起来
        System.out.println(clause1.substring(6));   //取得部分的字符串
        System.out.println(clause1.substring(6, 10));
        System.out.println(clause1.isEmpty());//是否为空
        System.out.println(clause2.contains("purpose"));//是否包含一个字符串
        System.out.println(clause2.replace("o", "=*="));//替换
        String[] clause1SplitArr = clause2.split(",");//分割
        String[] clause2SplitArr = clause2.split(",", 3);//使用","作为分割符, 但是只分割三次, 后面的不分割了放在一起
        System.out.println(clause1SplitArr.length);
        System.out.println(clause2SplitArr.length);
        for (String temp : clause1SplitArr) {
            System.out.print(temp + "   ");
        }
        System.out.println(" ");
        for (String temp : clause2SplitArr) {
            System.out.print(temp + "   ");
        }
        System.out.println(" ");
        //Do not    for one repulse    give up the purpose that you resolved to effect.To be    or not to be    that is the question.
        //Do not    for one repulse    give up the purpose that you resolved to effect.To be, or not to be, that is the question.
    }   
}
```

StringBuffer和StringBuilder类的用法

```java
public class UseStringBufferBuilder {
    public static void main(String[] args) {
        System.out.println("StringBuffer: A thread-safe, mutable sequence of characters. "
                + "StringBuffer:可变字符串, 速度中等, 线程安全");
        System.out.println("StringBuilder: A mutable sequence of characters. This class "
                + "provides an API compatible with StringBuffer, but with no guarantee of synchronization."
                + "StringBuilder:可变字符串, 高效快速, 线程不安全");
        System.out.println("StringBuilder和StringBuffer之间的区别就在于线程安全性上面, 其他的方面都相同,api定义和用法都相同");
        useStringBuffer();
        useStringBuilder();

    }

    public static void useStringBuffer() {
        System.out.println("\n\n\n---使用StrigBuffer的功能---");
        String poem = "我欲抽到断扬子, 问天谁敢与争锋!";
        StringBuffer sb1 = new StringBuffer();
        StringBuffer sb2 = new StringBuffer(6);//设置容量
        StringBuffer sb3 = new StringBuffer(poem);//通过String字符串来创建StringBuffer对象.


        System.out.println("\n使用各种构造函数, 创建一个StringBuffer---");
        sb1.append(12);//int
        sb1.append("hello world!");//str
        sb1.append(new Object().toString());//对象
        sb1.append(36.8d);//duble
        sb1.append(poem, 2, 8);//从String字符串之中取一部分
        System.out.println(sb1.toString());//StringBuffer转换成String, toString


        System.out.println("\n使用delete, insert等api");
        sb1.deleteCharAt(2);//按位置删除, 第2个char
        sb1.delete(3, 12);//删除第3-12个char, 范围是[3,12]
        System.out.println(sb1.toString());
        System.out.println(sb1.capacity());//容量
        sb1.insert(5, 12345678);/*offset的含义是什么?*/
        System.out.println(sb1.toString());
        System.out.println(sb1.capacity());//容量
        sb1.insert(0, "你说什么?");//insert String,offset=0, 表示从现在的第0个位置插入
        char[] ch1 = new char[]{'中', '❀', '民', '果'};
        sb1.insert(sb1.length(), ch1);//末尾插入, 插入一个char 数组
        System.out.println(sb1.toString());


        System.out.println("\n使用index, subString, reverse, replace和getChars等api");
        int num = sb1.lastIndexOf("8");//最后一个8出现的位置
        int index = sb1.indexOf("❀");
        String sb7_end = sb1.substring(7);//取其中一部分就变成了String类型
        String sb3_9 = sb1.substring(3, 9);
        System.out.println("num: " + num + ", index: " + index + ", sb7_end:" + sb7_end + ", sb3_9:" + sb3_9);

        char[] chars = new char[]{'h', 'e', 'l', 'l', 'o', '!', 'M', 'I', 'A'};//size为7, 不过貌似没什么异常发生
        sb2.append(chars);
        System.out.println(sb2.toString() + ", " + sb2.toString().length());
        System.out.println(sb2.reverse());//reverse
        sb2.replace(2, 4, "******(敏感词屏蔽掉)******");
        System.out.println(sb2.toString());
        char[] chars123 = new char[10];
        sb2.getChars(1, 7, chars123, 3);//去填充一个char[]数组
        for (char ch : chars123) {
            System.out.print(ch);
        }
        System.out.println(" ");
        System.out.println(sb3.toString());
    }

    public static void useStringBuilder() {
        System.out.println("\n\n\n---使用StrigBuilder的功能---");
        String poem = "我欲抽到断扬子, 问天谁敢与争锋!";
        StringBuilder stringBuilder1 = new StringBuilder();
        StringBuilder stringBuilder2 = new StringBuilder(6);//设置容量
        StringBuilder stringBuilder3 = new StringBuilder(poem);//通过String字符串来创建StringBuilder对象.


        System.out.println("\n使用各种构造函数, 创建一个StringBuffer---");
        stringBuilder1.append(12);//int
        stringBuilder1.append("hello world!");//str
        stringBuilder1.append(new Object().toString());//对象
        stringBuilder1.append(36.8d);//duble
        stringBuilder1.append(poem, 2, 8);//从String字符串之中取一部分
        System.out.println(stringBuilder1.toString());//StringBuffer转换成String, toString


        System.out.println("\n使用delete, insert等api");
        stringBuilder1.deleteCharAt(2);//按位置删除, 第2个char
        stringBuilder1.delete(3, 12);//删除第3-12个char, 范围是[3,12]
        System.out.println(stringBuilder1.toString());
        System.out.println(stringBuilder1.capacity());//容量
        stringBuilder1.insert(5, 12345678);/*offset的含义是什么?*/
        System.out.println(stringBuilder1.toString());
        System.out.println(stringBuilder1.capacity());//容量
        stringBuilder1.insert(0, "你说什么?");//insert String,offset=0, 表示从现在的第0个位置插入
        char[] ch1 = new char[]{'中', '❀', '民', '果'};
        stringBuilder1.insert(stringBuilder1.length(), ch1);//末尾插入, 插入一个char 数组
        System.out.println(stringBuilder1.toString());


        System.out.println("\n使用index, subString, reverse, replace和getChars等api");
        int num = stringBuilder1.lastIndexOf("8");//最后一个8出现的位置
        int index = stringBuilder1.indexOf("❀");
        String sb7_end = stringBuilder1.substring(7);//取其中一部分就变成了String类型
        String sb3_9 = stringBuilder1.substring(3, 9);
        System.out.println("num: " + num + ", index: " + index + ", sb7_end:" + sb7_end + ", sb3_9:" + sb3_9);

        char[] chars = new char[]{'h', 'e', 'l', 'l', 'o', '!', 'M', 'I', 'A'};//size为7, 不过貌似没什么异常发生
        stringBuilder2.append(chars);
        System.out.println(stringBuilder2.toString() + ", " + stringBuilder2.toString().length());
        System.out.println(stringBuilder2.reverse());//reverse
        stringBuilder2.replace(2, 4, "******(敏感词屏蔽掉)******");
        System.out.println(stringBuilder2.toString());
        char[] chars123 = new char[10];
        stringBuilder2.getChars(1, 7, chars123, 3);//去填充一个char[]数组
        for (char ch : chars123) {
            System.out.print(ch);
        }
        System.out.println(" ");
        System.out.println(stringBuilder3.toString());

    }
}
```



##### 105 : Arrays类的基本方法
A : 区别如下



##### 106 : Collections类的基本方法
A : 区别如下



##### 107 : Comparable接口和Comparator接口的用法比较
A : Comparable和Comparator接口都是为了对类进行比较, 众所周知, 诸如Integer, double等基本数据类型, java可以对他们进行比较, 而对于类的比较, 需要人工定义比较用到的字段比较逻辑. 可以把**Comparable理解为内部比较, 实现了内部比较**, 而**Comparator是外部比较器, 专门用来比较**.  基本的写法如下:

> *Comparable接口在`java.lang`包之中, 而Comparator接口在`java.util`包之中*.
> 创建了比较器Comparator来compare对象o1和o2, 而Comparable是让一个类的对象拥有自己和自己对象比较的compareTo()方法, Comparator是用来创建比较某种类型的比较器的专门的接口

SlaveKindOneComparable(使用Comparable)
```java
//Comparable接口的使用
import lombok.Data;

/**
 * @Author: prayjourney
 * @Despcription:
 * @Date: Created in 2018/8/13 0:35
 * @Modified by:
 */
@Data
public class SlaveKindOneComparable extends Slave implements Comparable {
    private int age;
    private String name;
    private float price;

    SlaveKindOneComparable(int age, String name, float price) {
        super();
        this.age = age;
        this.name = name;
        this.price = price;
    }

    //仅仅按照年龄来比较
    @Override
    public int compareTo(Object o) {
        if (this.age < ((SlaveKindOneComparable) o).getAge()) {
            return -1;
        } else if (this.age == ((SlaveKindOneComparable) o).getAge()) {
            return 0;
        } else {
            return 1;
        }
    }

    public static void main(String[] args) {
        SlaveKindOneComparable slave1 = new SlaveKindOneComparable(18, "jim", 67.9f);
        SlaveKindOneComparable slave2 = new SlaveKindOneComparable(13, "fg1", 67.2f);
        System.out.println(slave1.compareTo(slave2));//比较
    }
}

@Data
class Slave {
    private int age;
    private String name;
    private float price;
}
```

SlaveKindTwoComparator(使用Comparator)
```java
//Comparator接口的使用
import lombok.Data;

import java.util.Comparator;

/**
 * @Author: prayjourney
 * @Despcription:
 * @Date: Created in 2018/8/13 0:56
 * @Modified by:
 */
public class SlaveKindTwoComparator implements Comparator {

    //仅仅按照年龄来比较
    @Override
    public int compare(Object o1, Object o2) {
        if (((SlaveKindTwo) o1).getAge() > ((SlaveKindTwo) o2).getAge()) {
            return 1;
        } else if (((SlaveKindTwo) o1).getAge() == ((SlaveKindTwo) o2).getAge()) {
            return 0;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        SlaveKindTwo slave1 = new SlaveKindTwo(18, "jim", 67.9f);
        SlaveKindTwo slave2 = new SlaveKindTwo(21, "张三", 97.2f);
        SlaveKindTwo slave3 = new SlaveKindTwo(21, "罗斯托夫斯基", 17.2f);
        SlaveKindTwo slave4 = new SlaveKindTwo(32, "瓦洛佳", 22.2f);

        /*这是比较器*/
        SlaveKindTwoComparator sktc = new SlaveKindTwoComparator();
        //在外部比较
        System.out.println(sktc.compare(slave1, slave2));
        System.out.println(sktc.compare(slave2, slave3));
        System.out.println(sktc.compare(slave3, slave1));
        System.out.println(sktc.compare(slave1, slave4));

    }
}

@Data
class SlaveKindTwo extends Slave {
    private int age;
    private String name;
    private float price;

    SlaveKindTwo(int age, String name, float price) {
        super();
        this.age = age;
        this.name = name;
        this.price = price;
    }
}

@Data
class Slave {
    private int age;
    private String name;
    private float price;
}
```



##### 108 : 去掉String字符后的最后一个字符
A : 如下

```java
String listStrTemp2 = sb2.toString();
String listStr2 = listStrTemp2.substring(0, listStrTemp2.length() - 1);
System.out.println("最后一个,去除: " + listStr2);
```



##### 109 : Apache工具类的使用

A : 示例如下



##### 110 : String 和 CharSequence 关系与区别

A : String 继承于CharSequence, 也就是说**String也是CharSequence类型**. CharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口. 除了String实现了CharSequence之外, StringBuffer和StringBuilder也实现了 CharSequence接口. 需要说明的是, **CharSequence就是字符序列，String, StringBuilder和StringBuffer本质上都是通过字符数组实现的!**
**CharSequence 是 char 值的一个可读序列**. 此接口对许多不同种类的 char 序列提供统一的只读访问(个人理解应该算得上是char类型得一个集合, 是interface). **String 类代表字符串, 实现了CharSequence 接口**. Java 程序中的所有字符串字面值(如"abc")都作为此类的实例来实现. CharSequence是String实现的一个接口, 就是要求是一串字符. 所以每个参数类型是CharSequence的方法，**都可以实际代入String对象**. *为什么这些方法不干脆定义String作为参数类型* ? 因为还有其他的CharSequence类型的类, 比如StringBuffer和StringBuilder这两个很重要的类. String对象是不可变的, 这两个可变, 所以我们在构造字符串的过程中往往要用到StringBuffer和StringBuilder.  如果那些方法定义String作为参数类型, 那么就没法对它们用那些方法, 先得转化成String才能用. 但StringBuffer和StringBuilder转换为String再转换过来很耗费时间，用它们而不是直接用String的“加法”来构造新String本来就是为了省时间, 所以如果用String作为参数类型就无法达到期待的效果.

![](../../../images/stringsbuffersbuilder.png)

```java
public final class String extends Object 
implements Serializable, Comparable<String>, CharSequence

The String class represents character strings. All string literals in Java programs, such as "abc", are implemented as instances of this class.
Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. For example:
```



ref:

80.[java中Comparable和Comparator两种比较器的区别](https://www.cnblogs.com/andywithu/p/7239613.html),   81.[Comparable和Comparator的区别](https://www.cnblogs.com/szlbm/p/5504634.html),   82.[Comparator和Comparable之间的区别](https://blog.csdn.net/u014133299/article/details/78608454),   83.[Java中数组、List、Set互相转换](https://blog.csdn.net/my_precious/article/details/53010232),   84.[String空格删除和java删除字符串最后一个字符的几种方法](https://www.cnblogs.com/ceshi2016/p/7574005.html),   85.[详解Java异常Throwable、Error、Exception、RuntimeException的区别](https://blog.csdn.net/kwu_ganymede/article/details/51382461),   86.[String详解, String和CharSequence区别, StringBuilder和StringBuffer的区别 (String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html) ,   87.[String 和 CharSequence 关系与区别](https://www.cnblogs.com/ChrisMurphy/p/4760197.html)