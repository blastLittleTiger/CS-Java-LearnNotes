### 后端框架学习笔记4

***

[TOC]

##### 102 : Throwable, Error, Exception, RuntimeException, throw, throws的区别
A : 区别如下

在Java中, 根据错误性质将运行错误分为两类: 错误和异常. 在Java程序的执行过程中, 如果出现了异常事件, 就会生成一个异常对象. 生成的异常对象将传递Java运行时系统, 这一异常的产生和提交过程称为抛弃(throw)异常.当Java运行时系统得到一个异常对象时, 它将会沿着方法的调用栈逐层回溯, 寻找处理这一异常的代码. 找到能够处理这类异常的方法后, 运行时系统把当前异常对象交给这个方法进行处理, 这一过程称为捕获(catch)异常.
![](F:/CodeBank/MyGit/SummaryOfProgramming/images/exception%20series.png)



**Throwable**
类是 Java 语言中所有错误或异常的超类, 它的两个子类是Error和Exception



**Error**
是Throwable 的子类, 用于指示**合理的应用程序不应该试图捕获的严重问题**. 大多数这样的错误都是异常条件. 虽然   ThreadDeath 错误是一个"正规"的条件, 但它也是 Error 的子类, 因为**大多数应用程序都不应该试图捕获它**. 在执行该方法期间, 无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类, 因为这些错误可能是再也不会发生的异常条件. Error类包括一些严重的程序不能处理的系统错误类, 如内存溢出, 虚拟机错误, 栈溢出等. 这类错误一般与硬件有关, 与程序本身无关, 通常由系统进行处理, 程序本身无法捕获和处理.

1.OutOfMemoryError内存溢出一般是出现在申请了较多的内存空间没有释放的情形

```java
//java.lang.OutOfMemoryError  -Xmx150m
try {
	byte[] b = new byte[1024*1024*600];
} catch (OutOfMemoryError e) {
	e.printStackTrace();
}
```

运行时，设置jvm最大的heap内存150m，此时申请600m的内存，因此会报error

```java
java.lang.OutOfMemoryError: Java heap space
```

2.StackOverflowError
堆栈溢出错误. 当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误. 

```java
public static void main(String[] args) {
	method();
}
public static void method() {
	while (true) {
		method();
	}
}
```

无限次的递归调用出现

```java
Exception in thread "main" java.lang.StackOverflowError
```



**Exception**
类及其子类是 Throwable 的一种形式, 它指出了**合理的应用程序想要捕获的条件**. 有些异常在编写程序时无法预料的, 如中断异常, 非法存取异常等. 为了保证程序的健壮性, **Java要求必须对这些可能出现的异常进行捕获, 并对其进行处理**. Exception的除RuntimeException类的对象, 都是可检查的异常(Checked exception), Checked exception需要明确声明.

> public class Exception extends Throwable
>
> The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.
>
> The class Exception and any subclasses that are not also subclasses of RuntimeException are checked exceptions. Checked exceptions need to be declared in a method or constructor's throws clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary.



**RuntimeException**
类是Exception类的子类. **RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类**, 可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明. 它是Exception的子类. 常见的运行时异常:

```java
try {
	String str = new String("AA");
	str = null;
	System.out.println(str.length());
} catch (NullPointerException e) {
	e.printStackTrace();
	System.out.println("出现空指针的异常了");
}

try {
	Object obj = new Date();
	String str = (String) obj;
} catch (ClassCastException e) {
	System.out.println("出现类型转换的异常了");
} catch (Exception e) {
	e.printStackTrace();
} finally {
	System.out.println("处理完异常后的逻辑");
}

try {
	int i = 10;
	System.out.println(i / 0);
} catch (ArithmeticException e) {
	System.out.println("算术异常"+e.getMessage());
}

try {
	int[] i = new int[10];
	System.out.println(i[-10]);
} catch (ArrayIndexOutOfBoundsException e) {
	System.out.println("数组下标越界的异常！");
}
```

 

**IOExeption**

类是Exception类的子类, 从一个不存在的文件中读取数据, 越过文件结尾继续读取, 连接一个不存在的URL

```java
FileInputStream fis = null;
try {
	fis = new FileInputStream(new File("hello1.txt"));
	int b;
	while ((b = fis.read()) != -1) {
		System.out.print((char) b);
	}
} catch (FileNotFoundException e1) {
	System.out.println("文件找不到了！");
} catch (IOException e1) {
	System.out.println(e1.getMessage());
} finally {
	try {
		fis.close();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
```

 **throws用来声明一种可能要抛出的异常类型, throw用来抛出一个异常对象**.



##### 103 : Java中数组、List、Set互相转换
A : 主要是List和Set之中的toArray方法, 以及List和Set创建的时候, 由于可以使用collection参数, 所以相当于可以直接转换.

```java
import java.util.*;

public class ArrayListSet {
    //Array, List, Set之间的相互转换
    public static void main(String[] args) {
        //定义数组, 数据来源
        String[] names = new String[]{"关羽", "Justin", "大桥未久", "天海翼", "爱因斯坦", "白素贞"};
        /*数组转换成其他类型的数据*/
        Array2ListNoAddRemove(names);//数组-->List
        Array2ListHaveAddRemove(names);
        Array2Set(names);//数组-->Set

        /*List转换成Set和Array*/
        List2Set(names);//List-->Set
        List2Array(names);//List-->Array

        /*Set转换成List和Array*/
        HashSet<String> hashSet = new HashSet<>();
        hashSet.add("北京");
        hashSet.add("北京");
        hashSet.add("上海");
        hashSet.add("天津");
        hashSet.add("成都");
        hashSet.add("杭州");
        hashSet.add("广州");
        Set2Array(hashSet);//Set-->数组
        Set2List(hashSet);//Set-->List
    }

    public static void Array2Set(String[] nameArray) {
        System.out.println("\nArray------>Set");
        Set<String> starts = new HashSet<>(Arrays.asList(nameArray));
        starts.add("Mary"); // ok
        starts.remove("Tom"); // ok
        System.out.println("set长度: " + starts.size());

    }

    // array 转换 Collection(不可添加删除元素, 固定大小)
    public static void Array2ListHaveAddRemove(String[] nameArray) {
        System.out.println("\nArray------>List(可以add & remove)");
        List nameList = new ArrayList<String>();
        for (String temp : nameArray) {
            nameList.add(temp);
        }
        nameList.add("Mary"); // ok
        nameList.remove(0); // ok
        StringBuilder sb2 = new StringBuilder();
        Iterator<String> iterator = nameList.iterator();
        while (iterator.hasNext()) {
            sb2.append(iterator.next() + " ,");
        }
        String listStrTemp2 = sb2.toString();
        String listStr2 = listStrTemp2.substring(0, listStrTemp2.length() - 1);
        System.out.println("最后一个,去除: " + listStr2);
    }

    // array 转换 list(不可添加删除元素, 固定大小)
    public static void Array2ListNoAddRemove(String[] nameArray) {
        System.out.println("\nArray------>List(不能add & remove)");
        List<String> list = Arrays.asList(nameArray);
        System.out.println("list的size(): " + list.size());
        StringBuilder sb1 = new StringBuilder();
        ListIterator<String> it = list.listIterator();
        while (it.hasNext()) {
            sb1.append(it.next() + " ,");
        }
        String listStrTemp = sb1.toString();//去除掉最后一个","
        System.out.println("最后一个,未去除: " + listStrTemp);
        String listStr = listStrTemp.substring(0, listStrTemp.length() - 1);
        System.out.println("最后一个,去除: " + listStr);
        //list.add("123"); // Arrays.asList()方法, 只能产生固定长度的list, 转换后添加和删除都不可以
    }

    public static void List2Array(String[] nameArray) {
        System.out.println("\nList------>Array");
        List<String> list = Arrays.asList(nameArray);
        String[] strArray = (String[]) list.toArray();//toarray
        for (String obj : strArray) {
            System.out.print((obj + ", "));
        }
        System.out.println("\n转换后数组的size:" + strArray.length);
    }

    public static void List2Set(String[] nameArray) {
        System.out.println("\nList------>Set");
        List<String> list = Arrays.asList(nameArray);
        HashSet hashSet = new HashSet(list);
        for (Object obj : hashSet) {
            System.out.print((String) obj + ", ");
        }
        System.out.println("\nhashSet的size:" + hashSet.size());
    }

    public static void Set2Array(HashSet hashSet) {
        System.out.println("\nSet------>Array");
        Object[] strArr = hashSet.toArray();//List,Set自带 toArray方法
        System.out.println("strArr.size(): " + strArr.length);
    }

    public static void Set2List(HashSet hashSet) {
        System.out.println("\nSet------>Hash");
        List<String> list = new ArrayList<>(hashSet);//这个是来自于Collection的构造函数
        list.add("123");
        System.out.println("list.size(): " + list.size());
    }
}
```



##### 104 : String类的基本方法

A : 区别如下



##### 105 : Arrays类的基本方法
A : 区别如下



##### 106 : Collections类的基本方法
A : 区别如下



##### 107 : Comparable接口和Comparator接口的用法比较
A : Comparable和Comparator接口都是为了对类进行比较, 众所周知, 诸如Integer, double等基本数据类型, java可以对他们进行比较, 而对于类的比较, 需要人工定义比较用到的字段比较逻辑. 可以把**Comparable理解为内部比较, 实现了内部比较**, 而**Comparator是外部比较器, 专门用来比较**.  基本的写法如下:

> *Comparable接口在`java.lang`包之中, 而Comparator接口在`java.util`包之中*.
> 创建了比较器Comparator来compare对象o1和o2, 而Comparable是让一个类的对象拥有自己和自己对象比较的compareTo()方法, Comparator是用来创建比较某种类型的比较器的专门的接口

SlaveKindOneComparable(使用Comparable)
```java
//Comparable接口的使用
import lombok.Data;

/**
 * @Author: prayjourney
 * @Despcription:
 * @Date: Created in 2018/8/13 0:35
 * @Modified by:
 */
@Data
public class SlaveKindOneComparable extends Slave implements Comparable {
    private int age;
    private String name;
    private float price;

    SlaveKindOneComparable(int age, String name, float price) {
        super();
        this.age = age;
        this.name = name;
        this.price = price;
    }

    //仅仅按照年龄来比较
    @Override
    public int compareTo(Object o) {
        if (this.age < ((SlaveKindOneComparable) o).getAge()) {
            return -1;
        } else if (this.age == ((SlaveKindOneComparable) o).getAge()) {
            return 0;
        } else {
            return 1;
        }
    }

    public static void main(String[] args) {
        SlaveKindOneComparable slave1 = new SlaveKindOneComparable(18, "jim", 67.9f);
        SlaveKindOneComparable slave2 = new SlaveKindOneComparable(13, "fg1", 67.2f);
        System.out.println(slave1.compareTo(slave2));//比较
    }
}

@Data
class Slave {
    private int age;
    private String name;
    private float price;
}
```

SlaveKindTwoComparator(使用Comparator)
```java
//Comparator接口的使用
import lombok.Data;

import java.util.Comparator;

/**
 * @Author: prayjourney
 * @Despcription:
 * @Date: Created in 2018/8/13 0:56
 * @Modified by:
 */
public class SlaveKindTwoComparator implements Comparator {

    //仅仅按照年龄来比较
    @Override
    public int compare(Object o1, Object o2) {
        if (((SlaveKindTwo) o1).getAge() > ((SlaveKindTwo) o2).getAge()) {
            return 1;
        } else if (((SlaveKindTwo) o1).getAge() == ((SlaveKindTwo) o2).getAge()) {
            return 0;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        SlaveKindTwo slave1 = new SlaveKindTwo(18, "jim", 67.9f);
        SlaveKindTwo slave2 = new SlaveKindTwo(21, "张三", 97.2f);
        SlaveKindTwo slave3 = new SlaveKindTwo(21, "罗斯托夫斯基", 17.2f);
        SlaveKindTwo slave4 = new SlaveKindTwo(32, "瓦洛佳", 22.2f);

        /*这是比较器*/
        SlaveKindTwoComparator sktc = new SlaveKindTwoComparator();
        //在外部比较
        System.out.println(sktc.compare(slave1, slave2));
        System.out.println(sktc.compare(slave2, slave3));
        System.out.println(sktc.compare(slave3, slave1));
        System.out.println(sktc.compare(slave1, slave4));

    }
}

@Data
class SlaveKindTwo extends Slave {
    private int age;
    private String name;
    private float price;

    SlaveKindTwo(int age, String name, float price) {
        super();
        this.age = age;
        this.name = name;
        this.price = price;
    }
}

@Data
class Slave {
    private int age;
    private String name;
    private float price;
}
```



##### 108 : 去掉String字符后的最后一个字符
A : 如下

```java
String listStrTemp2 = sb2.toString();
String listStr2 = listStrTemp2.substring(0, listStrTemp2.length() - 1);
System.out.println("最后一个,去除: " + listStr2);
```



##### 109 : Apache工具类的使用

A : 示例如下



ref:

80.[java中Comparable和Comparator两种比较器的区别](https://www.cnblogs.com/andywithu/p/7239613.html),   81.[Comparable和Comparator的区别](https://www.cnblogs.com/szlbm/p/5504634.html),   82.[Comparator和Comparable之间的区别](https://blog.csdn.net/u014133299/article/details/78608454),   83.[Java中数组、List、Set互相转换](https://blog.csdn.net/my_precious/article/details/53010232),   84.[String空格删除和java删除字符串最后一个字符的几种方法](https://www.cnblogs.com/ceshi2016/p/7574005.html),   85.[详解Java异常Throwable、Error、Exception、RuntimeException的区别](https://blog.csdn.net/kwu_ganymede/article/details/51382461)